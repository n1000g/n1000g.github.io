<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何对接口鉴权这样一个功能开发做面向对象分析</title>
    <link href="/2022/02/18/%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E5%81%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/18/%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E5%81%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>整合自极客时间王争《设计模式之美》课程关于开闭原则的解释案例</p><p>软件实体应该对扩展开放、对修改关闭，详细表述就是添加一个新功能应该是，在已有代码的基础上扩展代码，而非修改已有代码。</p><h2 id="初步设计"><a class="markdownIt-Anchor" href="#初步设计"></a> 初步设计</h2><ul><li>AlertRule 存储告警规则，可自由设置</li><li>Notification 是告警通知类，支持邮件、短信等多种渠道，核心方法是 notify() 方法<ul><li>NotificationEmergencyLevel 枚举类表示警告级别</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alert</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> AlertRule rule;<br>  <span class="hljs-keyword">private</span> Notification notification;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Alert</span><span class="hljs-params">(AlertRule rule, Notification notification)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.rule = rule;<br>    <span class="hljs-keyword">this</span>.notification = notification;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(String api, <span class="hljs-keyword">long</span> requestCount, <span class="hljs-keyword">long</span> errorCount, <span class="hljs-keyword">long</span> durationOfSeconds)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> tps = requestCount / durationOfSeconds;<br>    <span class="hljs-keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;<br>      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;<br>      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码主要业务逻辑在 <code>check()</code> 函数，当接口 TPS 超过某个阈值时，以及接口请求出错数大于某个允许的最大值时，就会触发告警。</p><h2 id="添加新功能"><a class="markdownIt-Anchor" href="#添加新功能"></a> 添加新功能</h2><p>上述代码的扩展性显然很差。如果现在有一个新功能需求。当每秒钟接口超时请求个数超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这时候主要的改动有两处</p><ul><li>第一处是修改 <code>check()</code> 函数的入参，添加一个新的统计数据表示超时接口请求数</li><li>第二处是在 <code>check()</code> 函数中添加新的告警逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alert</span> </span>&#123;<br>  <span class="hljs-comment">// ...省略AlertRule/Notification属性和构造函数...</span><br>  <br>  <span class="hljs-comment">// 改动一：添加参数timeoutCount</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(String api, <span class="hljs-keyword">long</span> requestCount, <span class="hljs-keyword">long</span> errorCount, <span class="hljs-keyword">long</span> timeoutCount, <span class="hljs-keyword">long</span> durationOfSeconds)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> tps = requestCount / durationOfSeconds;<br>    <span class="hljs-keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;<br>      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;<br>      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 改动二：添加接口超时处理逻辑</span><br>    <span class="hljs-keyword">long</span> timeoutTps = timeoutCount / durationOfSeconds;<br>    <span class="hljs-keyword">if</span> (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;<br>      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的代码修改实际上存在挺多问题的。一方面，我们对接口进行了修改，这就意味着调用这接口的代码都要做相应的修改方面，修改了 <code>check()</code> 函数，相应的单元测试都需要修改</p><p>上面的改动都是基于“修改”的方式实现的，如果要遵循开闭原则，如何通过“扩展”方式来实现？</p><h2 id="重构"><a class="markdownIt-Anchor" href="#重构"></a> 重构</h2><p>重构的内容主要包含两部分</p><ul><li>第一部分是将 <code>check()</code> 函数的多个入参封装成 ApiStatInfo 类</li><li>第二部分是引入 handler 概念，将 if 判断逻辑分散在各个 handler 中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alert</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAlertHandler</span><span class="hljs-params">(AlertHandler alertHandler)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.alertHandlers.add(alertHandler);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(ApiStatInfo apiStatInfo)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (AlertHandler handler : alertHandlers) &#123;<br>      handler.check(apiStatInfo);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiStatInfo</span> </span>&#123;<span class="hljs-comment">//省略constructor/getter/setter方法</span><br>  <span class="hljs-keyword">private</span> String api;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> requestCount;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> errorCount;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> durationOfSeconds;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertHandler</span> </span>&#123;<br>  <span class="hljs-keyword">protected</span> AlertRule rule;<br>  <span class="hljs-keyword">protected</span> Notification notification;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AlertHandler</span><span class="hljs-params">(AlertRule rule, Notification notification)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.rule = rule;<br>    <span class="hljs-keyword">this</span>.notification = notification;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(ApiStatInfo apiStatInfo)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TpsAlertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AlertHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TpsAlertHandler</span><span class="hljs-params">(AlertRule rule, Notification notification)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(rule, notification);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(ApiStatInfo apiStatInfo)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();<br>    <span class="hljs-keyword">if</span> (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;<br>      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorAlertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AlertHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ErrorAlertHandler</span><span class="hljs-params">(AlertRule rule, Notification notification)</span></span>&#123;<br>    <span class="hljs-keyword">super</span>(rule, notification);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(ApiStatInfo apiStatInfo)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;<br>      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><p>重构后的 Alter 的使用如下：</p><p>其中，ApplicationContext 是一个单例类，负责 Alter 的创建、组装（rule 和 notification 的依赖注入）、初始化（添加 handlers）工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContext</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> AlertRule alertRule;<br>  <span class="hljs-keyword">private</span> Notification notification;<br>  <span class="hljs-keyword">private</span> Alert alert;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeBeans</span><span class="hljs-params">()</span> </span>&#123;<br>    alertRule = <span class="hljs-keyword">new</span> AlertRule(<span class="hljs-comment">/*.省略参数.*/</span>); <span class="hljs-comment">//省略一些初始化代码</span><br>    notification = <span class="hljs-keyword">new</span> Notification(<span class="hljs-comment">/*.省略参数.*/</span>); <span class="hljs-comment">//省略一些初始化代码</span><br>    alert = <span class="hljs-keyword">new</span> Alert();<br>    alert.addAlertHandler(<span class="hljs-keyword">new</span> TpsAlertHandler(alertRule, notification));<br>    alert.addAlertHandler(<span class="hljs-keyword">new</span> ErrorAlertHandler(alertRule, notification));<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Alert <span class="hljs-title">getAlert</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> alert; &#125;<br><br>  <span class="hljs-comment">// 饿汉式单例</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ApplicationContext instance = <span class="hljs-keyword">new</span> ApplicationContext();<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>    initializeBeans();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApplicationContext <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ApiStatInfo apiStatInfo = <span class="hljs-keyword">new</span> ApiStatInfo();<br>    <span class="hljs-comment">// ...省略设置apiStatInfo数据值的代码</span><br>    ApplicationContext.getInstance().getAlert().check(apiStatInfo);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重构后的新功能扩展"><a class="markdownIt-Anchor" href="#重构后的新功能扩展"></a> 重构后的新功能扩展</h2><p>现在，我们再来看下基于重构之后的代码，如果再添加上面讲到的那个新功能（每秒钟接超时请求个数超过某个最大阈值就告警）我们又该如何改动代码，主要的改动有下面四处</p><ul><li>第一处改动是在 ApiStatInfo 类中添加新的属性 timeoutCount</li><li>第二处改动是添加新的 TimeoutAlertHander 类</li><li>第三处改动是在 ApplicationContext 类的 <code>initializeBeans()</code> 方法中往 alter 对象里注册新的 handler</li><li>第四处改动是在使用 Alert 类的时候，需要给 <code>check()</code> 函数的入参 apiStatlnfo 对象设置 timeoutCount 的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alert</span> </span>&#123; <span class="hljs-comment">// 代码未改动... &#125;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiStatInfo</span> </span>&#123;<span class="hljs-comment">//省略constructor/getter/setter方法</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeoutCount; <span class="hljs-comment">// 改动一：添加新字段</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertHandler</span> </span>&#123; <span class="hljs-comment">//代码未改动... &#125;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TpsAlertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AlertHandler</span> </span>&#123;<span class="hljs-comment">//代码未改动...&#125;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorAlertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AlertHandler</span> </span>&#123;<span class="hljs-comment">//代码未改动...&#125;</span><br><span class="hljs-comment">// 改动二：添加新的handler</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeoutAlertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AlertHandler</span> </span>&#123;<span class="hljs-comment">//省略代码...&#125;</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContext</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> AlertRule alertRule;<br>  <span class="hljs-keyword">private</span> Notification notification;<br>  <span class="hljs-keyword">private</span> Alert alert;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeBeans</span><span class="hljs-params">()</span> </span>&#123;<br>    alertRule = <span class="hljs-keyword">new</span> AlertRule(<span class="hljs-comment">/*.省略参数.*/</span>); <span class="hljs-comment">//省略一些初始化代码</span><br>    notification = <span class="hljs-keyword">new</span> Notification(<span class="hljs-comment">/*.省略参数.*/</span>); <span class="hljs-comment">//省略一些初始化代码</span><br>    alert = <span class="hljs-keyword">new</span> Alert();<br>    alert.addAlertHandler(<span class="hljs-keyword">new</span> TpsAlertHandler(alertRule, notification));<br>    alert.addAlertHandler(<span class="hljs-keyword">new</span> ErrorAlertHandler(alertRule, notification));<br>    <span class="hljs-comment">// 改动三：注册handler</span><br>    alert.addAlertHandler(<span class="hljs-keyword">new</span> TimeoutAlertHandler(alertRule, notification));<br>  &#125;<br>  <span class="hljs-comment">//...省略其他未改动代码...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ApiStatInfo apiStatInfo = <span class="hljs-keyword">new</span> ApiStatInfo();<br>    <span class="hljs-comment">// ...省略apiStatInfo的set字段代码</span><br>    apiStatInfo.setTimeoutCount(<span class="hljs-number">289</span>); <span class="hljs-comment">// 改动四：设置tiemoutCount值</span><br>    ApplicationContext.getInstance().getAlert().check(apiStatInfo);<br>&#125;<br></code></pre></td></tr></table></figure><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 <code>check()</code> 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO 和 NIO</title>
    <link href="/2022/02/18/Java%20IO%20%E5%92%8C%20NIO/"/>
    <url>/2022/02/18/Java%20IO%20%E5%92%8C%20NIO/</url>
    
    <content type="html"><![CDATA[<h2 id="java-io-方式"><a class="markdownIt-Anchor" href="#java-io-方式"></a> java IO 方式</h2><p>IO 一直是软件开发中的核心部分之一，伴随着海量数据增长和分布式系统的发展，IO 扩展能力愈发重要。</p><ul><li>传统的 <a href="http://java.io">java.io</a> 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是<strong>同步、阻塞</strong>的方式（BIO），也就是说在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序 <a href="http://java.io">java.io</a> 包的好处是代码简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。<br />很多时候人们也把 <a href="http://java.net">java.net</a> 下提供的部分网络 API 如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为</li><li>Java 1.4 引入了 NIO 框架，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、<strong>同步非阻塞 IO</strong> 程序，同时提供了更接近 OS 底层性能的数据操作方式</li><li>Java 7 中，NIO 进一步改进，即 NIO 2，引入<strong>异步非阻塞 IO</strong> 方式，也常称 AIO。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回而不会阻塞在那里，当后台处理完成，OS 会通知相应线程进程后续工作</li></ul><blockquote><p>同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</p><p>阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</p></blockquote><h2 id="javaio"><a class="markdownIt-Anchor" href="#javaio"></a> <a href="http://java.io">java.io</a></h2><p><img src="https://s2.loli.net/2022/02/20/fs4Je78klWYjiPa.png" alt="IO流" /></p><h3 id="inputstreamoutputstream-和-readerwriter-的区别"><a class="markdownIt-Anchor" href="#inputstreamoutputstream-和-readerwriter-的区别"></a> InputStream/OutputStream 和 Reader/Writer 的区别</h3><ul><li>字节流处理的最基本单位为单个字节，它通常用来处理二进制数据，默认情况下是不支持缓存，一个 read 方法的调用对应一次 IO，要使用缓存提高读取效率应使用带缓冲区实现的 BufferedInputStream（网络 IO 常用）和 BufferedOutputStream</li><li>字符流处理的最基本单元为两字节大小的 Unicode 码元，通常处理文本数据，如字符串，字节流的读取和写入都要设置相应的编码方式。由于字符流在输出前实际上是要完成Unicode码元序列到相应编码方式的字节序列的转换，所以它会使用内存缓冲区来存放转换后得到的字节序列，等待都转换完毕再一同写入磁盘文件中</li><li>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的 IO 操作的功能，但它不能直接处理Unicode字符</li><li>底层以字节流为基础，实际总线中流动的只有字节流。</li></ul><h2 id="javanio"><a class="markdownIt-Anchor" href="#javanio"></a> java.nio</h2><p>NIO包含下面几个核心的组件：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><h4 id="channel-通道"><a class="markdownIt-Anchor" href="#channel-通道"></a> Channel 通道</h4><p>Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h4 id="buffer-缓冲区"><a class="markdownIt-Anchor" href="#buffer-缓冲区"></a> Buffer 缓冲区</h4><p>Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。</p><p><img src="https://s2.loli.net/2022/02/21/nDyojMl5iwV4c3T.png" alt="image-20220221033312059" /></p><p>Buffer 本质上就是一块内存区，可以用来写入数据，并在稍后读取出来。这块内存被NIO Buffer包裹起来，对外提供一系列的读写方便开发的接口。</p><h4 id="selector-选择器"><a class="markdownIt-Anchor" href="#selector-选择器"></a> Selector 选择器</h4><p>Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别。</p><p><img src="https://s2.loli.net/2022/02/21/n9Od4yHGMu8qcWe.png" alt="img" /></p><h2 id="netty"><a class="markdownIt-Anchor" href="#netty"></a> Netty</h2><p>按照官方定义，它是一个异步的、基于事件 Client/Server 的网络框架，目标是提供一种简单、快速构建网络应用的方式，同时保证高吞吐量、低延时、高可靠性。</p><blockquote><p>Java 的标准类库，由于其基础性、通用性的定位，往往过于关注技术模型上的抽象，而不是从一线应用开发者的角度去思考。引入并发包的一个重要原因就是，应用开发者使用 Thread API 比较痛苦，需要操心的不仅仅是业务逻辑，而且还要自己负责将其映射到 Thread 模型上。Java NIO 的设计也有类似的特点，开发者需要深入掌握线程、IO、网络等相关概念，学习路径很长，很容易导致代码复杂、晦涩，即使是有经验的工程师，也难以快速地写出高可靠性的实现。</p><p>Netty 的设计强调了 “Separation Of Concerns”，通过精巧设计的事件机制，将业务逻辑和无关技术逻辑进行隔离，并通过各种方便的抽象，一定程度上填补了了基础平台和业务开发之间的鸿沟，更有利于在应用开发中普及业界的最佳实践。</p><p>另外，Netty &gt; java.nio + java. net！</p></blockquote><h4 id="netty-相对-java-nio-为什么具有更高的性能"><a class="markdownIt-Anchor" href="#netty-相对-java-nio-为什么具有更高的性能"></a> Netty 相对 Java NIO 为什么具有更高的性能</h4><p>单独从性能角度，Netty 在基础的 NIO 等类库之上进行了很多改进，例如：</p><ul><li>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</li><li>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</li><li>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li><li>在通信协议、序列化等其他角度的优化。</li></ul><p>总的来说，Netty 并没有 Java 核心类库那些强烈的通用性、跨平台等各种负担，针对性能等特定目标以及 Linux 等特定环境，采取了一些极致的优化手段。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“API 接口监控告警”的优秀代码实践</title>
    <link href="/2022/02/18/%E2%80%9CAPI%20%E6%8E%A5%E5%8F%A3%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6%E2%80%9D%E7%9A%84%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/02/18/%E2%80%9CAPI%20%E6%8E%A5%E5%8F%A3%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6%E2%80%9D%E7%9A%84%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h2><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开 发的三个主要环节。在前面的章节中，我对三者的讲解比较偏理论、偏概括性，目的是让你 先有一个宏观的了解，知道什么是 OOA、OOD、OOP。不过，光知道“是什么”是不够的，我们更重要的还是要知道“如何做”，也就是，如何进行面向对象分析、设计与编程。</p><p>在过往的工作中，我发现，很多工程师，特别是初级工程师，本身没有太多的项目经验，或者参与的项目都是基于开发框架填写 CRUD 模板似的代码，导致分析、设计能力比较欠缺。当他们拿到一个比较笼统的开发需求的时候，往往不知道从何入手。</p><p>对于“如何做需求分析，如何做职责划分？需要定义哪些类？每个类应该具有哪些属性、方法？类与类之间该如何交互？如何组装类成一个可执行的程序？”等等诸多问题，都没有清晰的思路，更别提利用成熟的设计原则、思想或者设计模式，开发出具有高内聚低耦合、易 扩展、易读等优秀特性的代码了。</p><h3 id="案例介绍和难点剖析"><a class="markdownIt-Anchor" href="#案例介绍和难点剖析"></a> 案例介绍和难点剖析</h3><p>假设，你正在参与开发一个微服务。微服务通过 HTTP 协议暴露接口给其他系统调用，说直白点就是，其他系统通过 URL 来调用微服务的接口。有一天，你的 leader 找到你说，“为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认 证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。”</p><p>leader 丢下这些话就走了。这个时候，你该如何来做呢？有没有脑子里一团浆糊，一时间 无从下手的感觉呢？为什么会有这种感觉呢？我个人觉得主要有下面两点原因。</p><ol><li>需求不明确。leader 给到的需求过于模糊、笼统，不够具体、细化，离落地到设计、编码还有一定的距离。而人的大脑不擅长思考这种过于抽象的问题。</li><li>缺少锻炼。相比单纯的业务 CRUD 开发，鉴权这个开发任务，要更有难度。鉴权作为一个跟具体业务无关的功能，我们完全可以把它开发成一个独立的框架，集成到很多业务系统中。而作为被很多系统复用的通用框架，比起普通的业务代码，我们对框架的代码质量要求要更高。开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力，甚至逻辑思维能力 的要求，都是比较高的。如果你平时做的都是简单的 CRUD 业务开发，那这方面的锻炼肯 定不会很多。</li></ol><h3 id="对案例进行需求分析"><a class="markdownIt-Anchor" href="#对案例进行需求分析"></a> 对案例进行需求分析</h3><p>实际上，需求分析的工作很琐碎，也没有太多固定的章法可寻，所以，我不打算很牵强地罗列那些听着有用、实际没用的方法论，而是希望通过鉴权这个例子，来给你展示一下，面对需求分析的时候，我的完整的思考路径是什么样的。希望你能自己去体会，举一反三地类比应用到其他项目的需求分析中。</p><p>尽管针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求，但这并不代表我们就可以脱离具体的应用场景，闷头拍脑袋做需求分析。多跟业务团队聊聊天，甚至自己去参与几个业务系统的开发，只有这样，我们才能真正知道业务系统的痛点，才能分析出最有价值的需求。不过，针对鉴权这一功能的开发，最大的需求方还是我们自己，所以，我们也可以先从满足我们自己系统的需求开始，然后再迭代优化。</p><p>现在，我们来看一下，针对鉴权这个功能的开发，我们该如何做需求分析？</p><p>实际上，这跟做算法题类似，先从最简单的方案想起，然后再优化。所以，我把整个的分析 过程分为了循序渐进的四轮。每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表。</p><h4 id="1-第一轮基础分析"><a class="markdownIt-Anchor" href="#1-第一轮基础分析"></a> 1. 第一轮基础分析</h4><p>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p><h4 id="2-第二轮分析优化"><a class="markdownIt-Anchor" href="#2-第二轮分析优化"></a> 2. 第二轮分析优化</h4><p>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果我们借助加密算法（比如 SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上，这样也是不安全的，因为加密之后的密码及 AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问我们的接口。这就是典型的“重放攻击”。</p><p>提出问题，然后再解决问题，是一个非常好的迭代优化方法。对于刚刚这个问题，我们可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求；否则， 就拒绝接口调用请求。</p><p><img src="https://s2.loli.net/2022/02/19/Q5ge8hEBaJ71ufU.jpg" alt="" /></p><h4 id="3-第三轮分析优化"><a class="markdownIt-Anchor" href="#3-第三轮分析优化"></a> 3. 第三轮分析优化</h4><p>不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个 URL 拼接上 AppID、密码生成的 token 都是固定的。未认证系统截获 URL、token 和 AppID 之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个 URL 对应的接口。</p><p>为了解决这个问题，我们可以进一步优化 token 生成算法，引入一个随机变量，让每次接口请求生成的 token 都不一样。我们可以选择时间戳作为随机变量。原来的 token 是对 URL、AppID、密码三者进行加密生成的，现在我们将 URL、AppID、密码、时间戳四者进行加密来生成 token。调用方在进行接口请求的时候，将 token、AppID、时间戳，随 URL 一并传递给微服务端。</p><p>微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定 token 过期，拒绝接口请求。如果没有超过一分钟，则说明 token 没有过期，就再通过同样的 token 生成算法，在服务端生成新的 token，与调用方传递过来的 token 比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p><img src="https://s2.loli.net/2022/02/19/7PoyMaxXNDwHtei.jpg" alt="" /></p><h4 id="4-第四轮分析优化"><a class="markdownIt-Anchor" href="#4-第四轮分析优化"></a> 4. 第四轮分析优化</h4><p>不过，你可能会说，这样还是不够安全啊。未认证系统还是可以在这一分钟的 token 失效窗口内，通过截获请求、重放请求，来调用我们的接口啊！</p><p>你说得没错。不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。</p><p>实际上，还有一个细节我们没有考虑到，那就是，如何在微服务端存储每个授权调用方的 AppID 和密码。当然，这个问题并不难。最容易想到的方案就是存储到数据库里，比如 MySQL。不过，开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。</p><p>针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</p><h4 id="5-最终确定需求"><a class="markdownIt-Anchor" href="#5-最终确定需求"></a> 5. 最终确定需求</h4><p>到此，需求已经足够细化和具体了。现在，我们按照鉴权的流程，对需求再重新描述一下。如果你熟悉 UML，也可以用时序图、流程图来描述。不过，用什么描述不是重点，描述清楚才是最重要的。考虑到在接下来的面向对象设计环节中，我会基于文字版本的需求描述，来进行类、属性、方法、交互等的设计，所以，这里我给出的最终需求描述是文字版本的。</p><ul><li>调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。</li><li>微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。</li><li>微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li><li>如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进 行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</li></ul><p>这就是我们需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过“提出问题 - 解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。</p><h3 id="重点回顾"><a class="markdownIt-Anchor" href="#重点回顾"></a> 重点回顾</h3><p>针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。</p><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p><h2 id="设计"><a class="markdownIt-Anchor" href="#设计"></a> 设计</h2><p>在上一节课中，针对接口鉴权功能的开发，我们讲了如何进行面向对象分析（OOA），也就是需求分析。实际上，需求定义清楚之后，这个问题就已经解决了一大半，这也是为什么我花了那么多篇幅来讲解需求分析。今天，我们再来看一下，针对面向对象分析产出的需求，如何来进行面向对象设计（OOD）和面向对象编程（OOP）。</p><h3 id="如何进行面向对象设计"><a class="markdownIt-Anchor" href="#如何进行面向对象设计"></a> 如何进行面向对象设计？</h3><p>我们知道，面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。在面向对象设计环节，我们将需求描述转化为具体的类的设计。我们把这一设计环节拆解细化一下，主要包含以下几个部分：</p><ul><li>划分职责进而识别出有哪些类；</li><li>定义类及其属性和方法；</li><li>定义类与类之间的交互关系；</li><li>将类组装起来并提供执行入口。</li></ul><p>实话讲，不管是面向对象分析还是面向对象设计，理论的东西都不多，所以我们还是结合鉴权这个例子，在实战中体会如何做面向对象设计。</p><h3 id="1-划分职责进而识别出有哪些类"><a class="markdownIt-Anchor" href="#1-划分职责进而识别出有哪些类"></a> 1. 划分职责进而识别出有哪些类</h3><p>在面向对象有关书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都与现实世界中的事物一一对应。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。</p><p>所以，大多数讲面向对象的书籍中，还会讲到另外一种识别类的方法，那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。对于没有经验的初学者来说，这个方法比较简单、明确，可以直接照着做。</p><p>不过，我个人更喜欢另外一种方法，那就是根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。我们来看一下，针对鉴权这个例子，具体该如何来做。</p><p>在上一节课中，我们已经给出了详细的[需求描述](#5. 最终确定需求)。</p><p>首先，我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法 是“单一职责”，后面章节中我们会讲到）。下面是我逐句拆解上述需求描述之后，得到的功能点列表：</p><ol><li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li><li>对字符串通过加密算法加密生成 token；</li><li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li><li>解析 URL，得到 token、AppID、时间戳等信息；</li><li>从存储中取出 AppID 和对应的密码；</li><li>根据时间戳判断 token 是否过期失效；</li><li>验证两个 token 是否匹配</li></ol><p>从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。</p><p>当然，这是一个初步的类的划分，其他一些不重要的、边边角角的类，我们可能暂时没法一下子想全，但这也没关系，面向对象分析、设计、编程本来就是一个循环迭代、不断优化的过程。根据需求，我们先给出一个粗糙版本的设计方案，然后基于这样一个基础，再去迭代优化，会更加容易一些，思路也会更加清晰一些。</p><p>不过，我还要再强调一点，接口调用鉴权这个开发需求比较简单，所以，需求对应的面向对象设计并不复杂，识别出来的类也并不多。但如果我们面对的是更加大型的软件开发、更加复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多，像刚刚那样根据需求逐句罗列功能点的方法，最后会得到一个长长的列表，就会有点凌乱、没有规律。针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。</p><h3 id="2-定义类及其属性和方法"><a class="markdownIt-Anchor" href="#2-定义类及其属性和方法"></a> 2. 定义类及其属性和方法</h3><p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage。现在我们来看下，每个类都有哪些属性和方法。我们还是从功能点列表中挖掘。</p><h4 id="authtoken-类"><a class="markdownIt-Anchor" href="#authtoken-类"></a> AuthToken 类</h4><p>AuthToken 类相关的功能点有四个：</p><ul><li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li><li>对字符串通过加密算法加密生成 token；</li><li>根据时间戳判断 token 是否过期失效；</li><li>验证两个 token 是否匹配。</li></ul><p>对于方法的识别，很多面向对象相关的书籍，一般都是这么讲的，识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。</p><p>我们可以借用这个思路，根据功能点描述，识别出来 AuthToken 类的属性和方法，如下所示：</p><p><img src="https://s2.loli.net/2022/02/19/mJYw1sFVx2SduvI.jpg" alt="" /></p><p>从上面的类图中，我们可以发现这样三个小细节：</p><ul><li>并不是所有出现的名词都被定义为类的属性，比如 URL、AppID、密码、 时间戳这几个名词，我们把它作为了方法的参数。</li><li>我们还需要挖掘一些没有出现在功能点描述中属性，比如 createTime，expireTimeInterval，它们用在 isExpired() 函数中，用来判定 token 是否过期。</li><li>我们还给 AuthToken 类添加了一个功能点描述中没有提到的方法 getToken()</li></ul><p>第一个细节告诉我们，从业务模型上来说，不应该属于这个类的属性和方法，不应该被放到这个类里。比如 URL、AppID 这些信息，从业务模型上来说，不应该属于 AuthToken，所以我们不应该放到这个类中。</p><p>第二、第三个细节告诉我们，在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备。</p><h4 id="url-类"><a class="markdownIt-Anchor" href="#url-类"></a> Url 类</h4><p>Url 类相关的功能点有两个：</p><ul><li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li><li>解析 URL，得到 token、AppID、时间戳等信息。</li></ul><p>虽然需求描述中，我们都是以 URL 来代指接口请求，但是，接口请求并不一定是以 URL 的形式来表达，还有可能是 dubbo RPC 等其他形式。为了让这个类更加通用，命名更加贴切，我们接下来把它命名为 ApiRequest。下面是我根据功能点描述设计的 ApiRequest 类。</p><p><img src="https://s2.loli.net/2022/02/19/cWE2TKns3FH7jIk.jpg" alt="" /></p><h4 id="credentialstorage-类"><a class="markdownIt-Anchor" href="#credentialstorage-类"></a> CredentialStorage 类</h4><p>CredentialStorage 类相关的功能点有一个：</p><ul><li>从存储中取出 AppID 和对应的密码</li></ul><p>CredentialStorage 类非常简单，类图如下所示。为了做到抽象封装具体的存储方式，我们将 CredentialStorage 设计成了接口，基于接口而非具体的实现编程。</p><p><img src="https://s2.loli.net/2022/02/19/fwY8mZIgAzebJlX.jpg" alt="" /></p><h3 id="3-定义类与类之间的交互关系"><a class="markdownIt-Anchor" href="#3-定义类与类之间的交互关系"></a> 3. 定义类与类之间的交互关系</h3><p>类与类之间都哪些交互关系呢？UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合，接下来我就逐一讲解一下。</p><h4 id="泛化generalization"><a class="markdownIt-Anchor" href="#泛化generalization"></a> 泛化（Generalization）</h4><p>泛化可以简单理解为继承关系。具体到 Java 代码就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><h4 id="实现realization"><a class="markdownIt-Anchor" href="#实现realization"></a> 实现（Realization）</h4><p>实现一般是指接口和实现类之间的关系。具体到 Java 代码就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><h4 id="聚合aggregation"><a class="markdownIt-Anchor" href="#聚合aggregation"></a> 聚合（Aggregation）</h4><p>聚合是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课程与学生之间的关系。具体到 Java 代码就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">(B b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组合composition"><a class="markdownIt-Anchor" href="#组合composition"></a> 组合（Composition）</h4><p>组合也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。具体到 Java 代码就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.b = <span class="hljs-keyword">new</span> B();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关联association"><a class="markdownIt-Anchor" href="#关联association"></a> 关联（Association）</h4><p>关联是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。具体到 Java 代码就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">(B b)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.b = <span class="hljs-keyword">new</span> B();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖dependency"><a class="markdownIt-Anchor" href="#依赖dependency"></a> 依赖（Dependency）</h4><p>依赖是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。具体到 Java 代码就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">(B b)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.b = <span class="hljs-keyword">new</span> B();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B b)</span> </span>&#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看完了 UML 六种类关系的详细介绍，不知道你有何感受？我个人觉得这样拆分有点太细，增加了学习成本，对于指导编程开发没有太大意义。所以，我从更加贴近编程的角度，对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖，这样你掌握起来 会更加容易。</p><p>其中，泛化、实现、依赖的定义不变，组合关系替代 UML 中组合、聚合、关联三个概念，也就相当于重新命名关联关系为组合关系，并且不再区分 UML 中的组合和聚合两个概念。之所以这样重新命名，是为了跟我们前面讲的“多用组合少用继承”设计原则中的“组合”统一含义。只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关系。</p><p>理论的东西讲完了，让我们来看一下，刚刚我们定义的类之间都有哪些关系呢？因为目前只有三个核心的类，所以只用到了实现关系，也即 CredentialStorage 和 MysqlCredentialStorage 之间的关系。接下来讲到组装类的时候，我们还会用到依赖关系、组合关系，但是泛化关系暂时没有用到。</p><h3 id="4-将类组装起来并提供执行入口"><a class="markdownIt-Anchor" href="#4-将类组装起来并提供执行入口"></a> 4. 将类组装起来并提供执行入口</h3><p>类定义好了，类之间必要的交互关系也设计好了，接下来我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p><p>接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件，所以，我们封装所有的实现细节，设计了一个最顶层的 ApiAuthencator 接口类，暴露一组给外部调用者使用的 API 接口，作为触发执行鉴权逻辑的入口。具体的类的设计如下所示：</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>面向对象设计完成之后，我们已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口。接下来，面向对象编程的工作，就是将这些设计思路翻译成代码实现。有了前面的类图，这部分工作相对来说就比较简单了。所以，这里我只给出比较复杂的 ApiAuthencator 的实现。</p><p>对于 AuthToken、ApiRequest、CredentialStorage 这三个类，在这里我就不给出具体的代码实现了。给你留一个课后作业，你可以试着把整个鉴权框架自己去实现一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApiAuthencator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">auth</span><span class="hljs-params">(String url)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">auth</span><span class="hljs-params">(ApiRequest apiRequest)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultApiAuthencatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApiAuthencator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CredentialStorage credentialStorage;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiAuthencator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.credentialStorage = <span class="hljs-keyword">new</span> MysqlCredentialStorage();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiAuthencator</span><span class="hljs-params">(CredentialStorage credentialStorage)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.credentialStorage = credentialStorage;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">auth</span><span class="hljs-params">(String url)</span> </span>&#123;<br>        ApiRequest apiRequest = ApiRequest.buildFromUrl(url);<br>        auth(apiRequest);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">auth</span><span class="hljs-params">(ApiRequest apiRequest)</span> </span>&#123;<br>        String appId = apiRequest.getAppId();<br>        String token = apiRequest.getToken();<br>        <span class="hljs-keyword">long</span> timestamp = apiRequest.getTimestamp();<br>        String originalUrl = apiRequest.getOriginalUrl();<br>        <br>        AuthToken clientAuthToken = <span class="hljs-keyword">new</span> AuthToken(token, timestamp);<br>        <span class="hljs-keyword">if</span> (clientAuthToken.isExpired()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Token is expired.&quot;</span>);<br>        &#125;<br>        <br>        String password = credentialStorage.getPasswordByAppId(appId);<br>        AuthToken serverAuthToken = AuthToken.generate(originalUrl, appId, <span class="hljs-function">password</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(!serverAuthToken.match(clientAuthToken)</span>) </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Token verfication failed.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="辩证思考与灵活应用"><a class="markdownIt-Anchor" href="#辩证思考与灵活应用"></a> 辩证思考与灵活应用</h3><p>在之前的讲解中，面向对象分析、设计、实现，每个环节的界限划分都比较清楚。而且，设计和实现基本上是按照功能点的描述，逐句照着翻译过来的。这样做的好处是先做什么、后做什么，非常清晰、明确，有章可循，即便是没有太多设计经验的初级工程师，都可以按部就班地参照着这个流程来做分析、设计和实现。</p><p>不过，在平时的工作中，大部分程序员往往都是在脑子里或者草纸上完成面向对象分析和设计，然后就开始写代码了，边写边思考边重构，并不会严格地按照刚刚的流程来执行。而且，说实话，即便我们在写代码之前，花很多时间做分析和设计，绘制出完美的类图、UML 图，也不可能把每个细节、交互都想得很清楚。在落实到代码的时候，我们还是要反复迭代、重构、打破重写。</p><p>毕竟，整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程。我们没法严格地按照顺序执行各个步骤。这就类似你去学驾照，驾校教的都是比较正规的流程，先做什么，后做什么，你只要照着做就能顺利倒车入库，但实际上，等你开熟练了，倒车入库很多时候靠的都是经验和感觉。</p><h3 id="重点回顾-2"><a class="markdownIt-Anchor" href="#重点回顾-2"></a> 重点回顾</h3><p>面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><ol><li>划分职责进而识别出有哪些类</li><li>定义类及其属性和方法</li><li>定义类与类之间的交互关系</li><li>将类组装起来并提供执行入口</li></ol><p>软件设计的自由度很大，这也是软件的复杂之处。不同的人对类的划分、定义、类之间交互 的设计，可能都不大一样。那除了我今天给出的设计思路，你还有没有其他设计思路呢？</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 应用统一参数校验</title>
    <link href="/2022/01/26/Spring-%E5%BA%94%E7%94%A8%E7%BB%9F%E4%B8%80%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <url>/2022/01/26/Spring-%E5%BA%94%E7%94%A8%E7%BB%9F%E4%B8%80%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="1-bean-validation-概述"><a class="markdownIt-Anchor" href="#1-bean-validation-概述"></a> 1. Bean Validation 概述</h2><p>Spring Boot 直接为“验证用户输入”这个常见且关键的任务提供了强大的支持。尽管 Spring Boot 支持与自定义验证器的无缝集成，但执行验证的事实标准是 Hibernate Validator，它同时也是 Java <strong><a href="https://beanvalidation.org/2.0/spec/#introduction-goals">Bean Validation</a></strong> 框架（JSR 303、349、380）的参考实现。其版本规范对应关系如下：</p><table><thead><tr><th>Bean Validation 版本</th><th>Java EE 版本</th><th>Hibernate 实现版本</th></tr></thead><tbody><tr><td>Bean Validation 1.0（JSR 303）</td><td>Java EE 6</td><td>4.3.1.Final</td></tr><tr><td>Bean Validation 1.1（JSR 349）</td><td>Java EE 7</td><td>5.1.1.Final</td></tr><tr><td>Bean Validation 2.0（JSR 380）</td><td>Java EE 8</td><td>6.0.1.Final</td></tr></tbody></table><blockquote><p><a href="https://beanvalidation.org/">https://beanvalidation.org/</a></p></blockquote><h2 id="2-maven-依赖"><a class="markdownIt-Anchor" href="#2-maven-依赖"></a> 2. maven 依赖</h2><ul><li><p>Bean Validation</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.validation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>validation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Hibernate Validator（内含 validation-api）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.17.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>hibernate-validator 依赖 javax.el-api</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.el<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Spring Boot 2.3+ 提供的 starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-约束-constraint"><a class="markdownIt-Anchor" href="#3-约束-constraint"></a> 3. 约束 Constraint</h2><p><code>javax.validation.Constraint</code> 注解用于定义一个约束注解，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123; ANNOTATION_TYPE &#125;)</span> <span class="hljs-comment">// 注解在注解上</span><br><span class="hljs-meta">@Retention(RUNTIME)</span> <span class="hljs-comment">// 运行时解析</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Constraint &#123;<br>    Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;[] validatedBy(); <span class="hljs-comment">// 校验器</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注解了 <code>@Constraint</code> 的注解即为可用约束，然后通过指定的约束校验器 <code>ConstraintValidator</code> 实现校验功能。</p><h3 id="31-约束分类"><a class="markdownIt-Anchor" href="#31-约束分类"></a> 3.1. 约束分类</h3><p>Bean Validation 的约束是通过 Java 注解（annotation）标注实现的，按注解级别可分为以下三种：</p><ul><li><p>字段级（filed level）约束——标注在字段上，通过字段访问策略获取并验证，即 Bean Validation 会直接访问实例变量而不调用属性的访问器（getter）即使它存在，</p><ul><li>无所谓该字段的访问级别（private、public 或 protected）</li><li>不校验静态字段或属性</li></ul></li><li><p>属性级（property level）约束——标注在访问器（getter）上，Bean Validation 通过访问器方法访问属性</p><ul><li>优于前者之处是——“约束成为受约束类型 API 的一部分，用户无需检查类型的实现就可以知道现有的约束”</li><li>在一个类上使用字段或属性注解要统一，避免重复校验</li></ul></li><li><p>容器元素约束（container element constraints）——通过指定 <code>ElementType.TYPE_USE</code> 指定 <code>@Target</code> 的约束，可用于 <code>java.util.Iterable</code>、<code>java.util.Map</code>、<code>java.util.Optional</code> 等的实现并支持自定义容器类型。</p></li><li><p>类级别约束——注解在类上</p><ul><li><p>当需要同时校验多个属性来验证一个对象或一个属性在验证的时候需要另外的属性的信息的时候，类级别的约束会很有用。</p></li><li><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mycompany;<br><br><span class="hljs-keyword">import</span> javax.validation.constraints.Min;<br><span class="hljs-keyword">import</span> javax.validation.constraints.NotNull;<br><span class="hljs-keyword">import</span> javax.validation.constraints.Size;<br><br><span class="hljs-meta">@PassengerCount</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-keyword">private</span> String manufacturer;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Size(min = 2, max = 14)</span><br>    <span class="hljs-keyword">private</span> String licensePlate;<br><br>    <span class="hljs-meta">@Min(2)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> seatCount;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Person&gt; passengers;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(String manufacturer, String licencePlate, <span class="hljs-keyword">int</span> seatCount)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.manufacturer = manufacturer;<br>        <span class="hljs-keyword">this</span>.licensePlate = licencePlate;<br>        <span class="hljs-keyword">this</span>.seatCount = seatCount;<br>    &#125;<br><br>    <span class="hljs-comment">//getters and setters ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义约束 <code>@PassengerCount</code> 实现保证这个车里乘客的数量不会超过它的座位数。</p></li></ul></li></ul><h3 id="32-约束的继承"><a class="markdownIt-Anchor" href="#32-约束的继承"></a> 3.2. 约束的继承</h3><p>基类或接口中的约束会在要校验的派生类或实现类对象校验时自动加载，重写方法上的约束也要继承并重复校验。</p><h3 id="33-关联校验和-valid-注解"><a class="markdownIt-Anchor" href="#33-关联校验和-valid-注解"></a> 3.3. 关联校验和 <code>@Valid</code> 注解</h3><p>Bean Validation API 不仅能够用来校验单个的实例对象，还能够用来校验完整的对象图。要使用这个功能，只需要在一个有关联关系的字段或者属性上标注 <code>@Valid</code>。这样，如果一个对象被校验，那么它的所有的标注了 <code>@Valid</code> 的关联对象都会被校验。</p><p>关联校验也适用于集合类型的字段。</p><p>应用于在应用控制层对前端请求参数进行校验的常见写法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxxController</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EntityCreateResponse <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> EntityCreateRequest request)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong><code>@Valid</code> vs <code>@Validated</code></strong></p><p>前者是 JSR 303 API 提供用于关联校验，后者是 spring-context 提供用于指定校验组 groups，<br /><a href="https://www.baeldung.com/spring-valid-vs-validated">https://www.baeldung.com/spring-valid-vs-validated</a></p></blockquote><h3 id="34-bean-validation-api-内置约束注解"><a class="markdownIt-Anchor" href="#34-bean-validation-api-内置约束注解"></a> 3.4. Bean Validation API 内置约束注解</h3><p>Bean Validation API 中所有内置约束都适用于字段级别或属性级别，没有定义类级别的约束。</p><p>如果当前应用正在使用 Hibernate 对象关系映射技术，部分内置约束会对 DDL（数据库模式定义语言）的创建产生影响。</p><p>Hibernate Validator 允许一些约束被应用于比 Bean Validation 规范要求的更多的数据类型（例如 <code>@Max</code> 可以应用于字符串）。这个特性会影响应用程序在 Bean Validation 提供者之间的可移植性。（目前可用 JSR 380 实现只此一家，不用考虑这个问题）</p><table><thead><tr><th>注解</th><th>支持数据类型</th><th>作用</th><th>Hibernate 元数据影响</th></tr></thead><tbody><tr><td><code>@AssetFalse</code>、<code>@AssertTrue</code></td><td>Boolean、boolean</td><td>被标注的值须为假（真）</td><td>无</td></tr><tr><td><code>@DecimalMax</code>、<code>@DecimalMin</code></td><td>BigDecimal、BigInteger、String、any sub-type of Number</td><td>不大于约束中指定的最大（小）值</td><td>无</td></tr><tr><td><code>@Digits(integer=, fraction=)</code></td><td>同上</td><td>检查标注的值是否为最多为整数和分数的数字。</td><td>对应的数据库表字段会被设置精度(precision)和准度(scale)。</td></tr><tr><td><code>@Max</code>、<code>@Min</code></td><td>同上</td><td>&lt;=（&gt;=）</td><td>会给对应的数据库表字段添加一个 check 的约束条件。</td></tr><tr><td><code>@NotNull</code></td><td>Any Type</td><td>不为空</td><td>对应的表字段不允许为null。</td></tr><tr><td><code>@Pattern(regex=, flag=)</code></td><td>String</td><td>匹配指定正则表达式</td><td>无</td></tr><tr><td><code>@Size(min=, max=)</code></td><td>String、Collection、Arrays</td><td>min&lt;=size&lt;=max</td><td>对应的数据库表字段的长度会被设置成约束中定义的最大值。</td></tr><tr><td><code>@Valid</code></td><td>Any non-primitive type</td><td>递归的对关联对象进行校验，如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个map，则对其中的值部分进行校验。</td><td>无</td></tr></tbody></table><blockquote><p>由匹配正则处可知 validation-api 需要 javax.el-api 的支持。</p></blockquote><h3 id="35-hibernate-validator-添加的约束"><a class="markdownIt-Anchor" href="#35-hibernate-validator-添加的约束"></a> 3.5. Hibernate Validator 添加的约束</h3><p><code>@Email</code>、<code>@CreditCardNumber</code>、<code>@Length(min=, max=)</code>、<code>@NotBlank</code>、<code>@NotEmpty</code>、<code>@SafeHtml(whitelistType=, additionalTags=)</code>、<code>@URL(protocol=, host=, port=, regexp=, flags=)</code> 等，具体见</p><h2 id="4-校验器-validator"><a class="markdownIt-Anchor" href="#4-校验器-validator"></a> 4. 校验器 Validator</h2><p><code>javax.validation.Validator</code> 接口是最主要的 Bean Validation API。一个 <code>Validator</code> 实例能够用于验证 bean 实例及其关联对象。推荐将 <code>Validator</code> 实例缓存在 <code>ValidatorFactory</code> 中。<code>Validator</code> 须保证线程安全。</p><h3 id="41-获取一个-validator-实例"><a class="markdownIt-Anchor" href="#41-获取一个-validator-实例"></a> 4.1. 获取一个 Validator 实例</h3><p>对一个实体对象验证之前首先需要有个 <code>Validator</code> 对象，而这个对象是需要通过 <code>Validation</code> 类和 <code>ValidatorFactory</code> 来创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();<br>Validator validator = factory.getValidator();<br></code></pre></td></tr></table></figure><blockquote><p><strong>其他获取 Validator 实例的方法</strong></p><ol><li><p><strong>Validation.byDefaultProvider()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Configuration&lt;?&gt; config = Validation.byDefaultProvider().configure();<br>config.messageInterpolator(<span class="hljs-keyword">new</span> MyMessageInterpolator())<br>    .traversableResolver( <span class="hljs-keyword">new</span> MyTraversableResolver())<br>    .constraintValidatorFactory(<span class="hljs-keyword">new</span> MyConstraintValidatorFactory());<br><br>ValidatorFactory factory = config.buildValidatorFactory();<br>Validator validator = factory.getValidator();<br></code></pre></td></tr></table></figure></li><li><p><strong>Validation.byProvider( HibernateValidator.class )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">HibernateValidatorConfiguration config = Validation.byProvider( HibernateValidator.class ).configure();<br>config.messageInterpolator(<span class="hljs-keyword">new</span> MyMessageInterpolator())<br>    .traversableResolver( <span class="hljs-keyword">new</span> MyTraversableResolver())<br>    .constraintValidatorFactory(<span class="hljs-keyword">new</span> MyConstraintValidatorFactory());<br><br>ValidatorFactory factory = config.buildValidatorFactory();<br>Validator validator = factory.getValidator();<br></code></pre></td></tr></table></figure></li></ol></blockquote><p>以上方法获取的 <code>Validator</code> 实例均是线程安全的</p><h3 id="42-validate-方法"><a class="markdownIt-Anchor" href="#42-validate-方法"></a> 4.2. validate 方法</h3><p><code>Validator</code> 中有三个方法能够被用来校验实体对象或其属性：</p><ul><li><code>validate()</code></li><li><code>validateProperty()</code></li><li><code>validateValue()</code></li></ul><p>三者均返回 <code>ConstraintViolation&lt;T&gt;</code> 的集合，用法相似 <code>validateProperty()</code>  和 <code>validateValue()</code> 会忽略被验证属性上定义的 <code>@Valid</code>。</p><h3 id="43-constraintviolation"><a class="markdownIt-Anchor" href="#43-constraintviolation"></a> 4.3. ConstraintViolation</h3><p>violation 译为“违规；违反”，<code>ConstraintViolation</code> 即校验失败信息，它有如下方法</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>getMessage()</code></td><td>校验错误信息</td></tr><tr><td><code>getMessageTemplate()</code></td><td>校验错误信息模板（可自定义）</td></tr><tr><td><code>getRootBean()</code></td><td>被校验的根实体对象</td></tr><tr><td><code>getRootBeanClass()</code></td><td>被校验的根实体类</td></tr><tr><td><code>getLeafBean()</code></td><td>被校验 Bean 的实例对象</td></tr><tr><td><code>getPropertyPath()</code></td><td>从根对象到被校验属性的路径</td></tr><tr><td><code>getInvalidValue()</code></td><td>导致校验失败的值</td></tr><tr><td><code>getConstraintDescriptor()</code></td><td>导致校验失败的约束定义</td></tr></tbody></table><h3 id="44-executablevalidator"><a class="markdownIt-Anchor" href="#44-executablevalidator"></a> 4.4. ExecutableValidator</h3><p><code>Validator</code> 接口还有一个重要方法：</p><ul><li><code>forExecutables()</code></li></ul><p>返回方法或构造函数验证的 contract（译为“合同”）。无参，返回 <code>ExecutableValidator</code> 接口的实例，接口下有函数</p><ul><li><code>validateParameters()</code></li><li><code>validateReturnValue()</code></li><li><code>validateConstructorParameters()</code></li><li><code>validateConstructorReturnValue()</code></li></ul><p>方法构造参数相关的验证通常不会通过手动调用，一般在拦截器、AOP 或动态代理技术中使用。</p><p>以下是验证拦截器中对这些方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Interceptor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleMethodInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">private</span> Validator validator;<br><br>    <span class="hljs-meta">@AroundInvoke</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">validateMethodInvocation</span><span class="hljs-params">(InvocationContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//validate parameters</span><br>        Set&lt;ConstraintViolation&lt;Object&gt;&gt; violations;<br>        violations = validator.forExecutables().validateParameters(<br>                ctx.getTarget(),<br>                ctx.getMethod(),<br>                ctx.getParameters()<br>        );<br><br>        <span class="hljs-comment">//if a violation occurs for parameters, raise an exception</span><br>        <span class="hljs-keyword">if</span> ( !violations.isEmpty() ) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConstraintViolationException(<br>                    buildMessage( ctx.getMethod(), ctx.getParameters(), violations ),<br>                    violations<br>            );<br>        &#125;<br><br>        <span class="hljs-comment">//execute the method proper</span><br>        Object result = ctx.proceed();<br><br>        <span class="hljs-comment">//validate the return type</span><br>        violations = validator.forExecutables().validateReturnValue(<br>                ctx.getTarget(),<br>                ctx.getMethod(),<br>                result<br>        );<br><br>        <span class="hljs-comment">//if a violation occurs for the return type, raise an exception</span><br>        <span class="hljs-keyword">if</span> ( !violations.isEmpty() ) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConstraintViolationException(<br>                    buildMessage( ctx.getMethod(), ctx.getParameters(), violations ),<br>                    violations<br>            );<br>        &#125;<br><br>        <span class="hljs-comment">//return the result</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-自定义约束"><a class="markdownIt-Anchor" href="#5-自定义约束"></a> 5. 自定义约束</h2><h3 id="51-约束注解"><a class="markdownIt-Anchor" href="#51-约束注解"></a> 5.1. 约束注解</h3><p>内置约束 <code>@NotNull</code> 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Repeatable(List.class)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Constraint(validatedBy = &#123; &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NotNull &#123;<br><br><span class="hljs-function">String <span class="hljs-title">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;</span>&#123;javax.validation.constraints.NotNull.message&#125;<span class="hljs-string">&quot;;</span><br><span class="hljs-string">Class&lt;?&gt;[] groups() default &#123; &#125;;</span><br><span class="hljs-string">Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    @Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><br><span class="hljs-string">@Retention(RUNTIME)</span><br><span class="hljs-string">@Documented</span><br><span class="hljs-string">@interface List &#123;</span><br><span class="hljs-string">NotNull[] value();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>参考易知自定义约束关键在以下两点</p><ul><li>实现三个强制性要求的属性<ul><li>message——校验失败消息</li><li>groups——校验组</li><li>payload——设计用于指定约束条件严重级别，不被 API 自身所用，供应用使用</li></ul></li><li><code>@Constraint(validatedBy = XxxValidator.class)</code> 指明使用那个校验器（类）去校验使用了此标注的元素。</li></ul><p>以定义一个 <code>@CheckCase</code> 约束注解为例，它用于验证字符串的大小写情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 枚举类 CaseMode 表示大写模式或小写模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CaseMode</span> </span>&#123;   UPPER,   LOWER; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// import ...</span><br><span class="hljs-meta">@Target( &#123; METHOD, FIELD, ANNOTATION_TYPE &#125;)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Constraint(validatedBy = CheckCaseValidator.class)</span> <span class="hljs-comment">// 指定约束校验器</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CheckCase &#123;<br>    <span class="hljs-function">String <span class="hljs-title">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;</span>&#123;com.mycompany.constraints.checkcase&#125;<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="hljs-string">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="hljs-string">    CaseMode value();</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="52-约束校验器-constraintvalidator"><a class="markdownIt-Anchor" href="#52-约束校验器-constraintvalidator"></a> 5.2. 约束校验器 ConstraintValidator</h3><p>下一步是实现 <code>ConstraintValidator</code> 接口。在类上定义约束时，正在验证的类实例将传递给 <code>ConstraintValidator</code>。在字段上定义约束时，该字段的值将传递给 <code>ConstraintValidator</code> 。当在 getter() 上定义约束时，getter() 调用的结果将传递给 <code>ConstraintValidator</code>。</p><p>须指定两个泛型参数——第一个是校验器所服务到标注类型（即自定义约束注解类），第二个为需要校验的数据类型（本例中是 <code>@CheckCase</code> 和 <code>String</code>）</p><p>并重写 <code>initialize()</code> 方法和 <code>isValid()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.validation.ConstraintValidator;<br><span class="hljs-keyword">import</span> javax.validation.ConstraintValidatorContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckCaseValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConstraintValidator</span>&lt;<span class="hljs-title">CheckCase</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> CaseMode caseMode;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(CheckCase constraintAnnotation)</span> </span>&#123; <span class="hljs-keyword">this</span>.caseMode = constraintAnnotation.value(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String object, ConstraintValidatorContext constraintContext)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (caseMode == CaseMode.UPPER) <span class="hljs-keyword">return</span> object.equals(object.toUpperCase());<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> object.equals(object.toLowerCase());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="53-约束校验器上下文-constraintvalidatorcontext"><a class="markdownIt-Anchor" href="#53-约束校验器上下文-constraintvalidatorcontext"></a> 5.3. 约束校验器上下文 ConstraintValidatorContext</h3><p>通过使用传入的 <code>ConstraintValidatorContext</code> 对象, 我们还可以给约束条件中定义的错误信息模板来添加额外的信息或者完全创建一个新的错误信息模板。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String object, ConstraintValidatorContext constraintContext)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">boolean</span> isValid;<br>    <span class="hljs-keyword">if</span> (caseMode == CaseMode.UPPER) isValid = object.equals(object.toUpperCase());<br>    <span class="hljs-keyword">else</span> isValid = object.equals(object.toLowerCase());<br>    <span class="hljs-keyword">if</span>(!isValid) &#123;<br>    constraintContext.disableDefaultConstraintViolation();<br>    constraintContext<br>            .buildConstraintViolationWithTemplate(<span class="hljs-string">&quot;&#123;com.mycompany.constraints.CheckCase.message&#125;&quot;</span>)<br>            .addConstraintViolation();<br>    &#125;<br>    <span class="hljs-keyword">return</span> isValid;<br>&#125;<br></code></pre></td></tr></table></figure><p>在本例中, 实际上通过调用 <code>ConstraintValidatorContext</code> 达到了一个使用默认消息模板的效果。</p><h3 id="54-使用演示"><a class="markdownIt-Anchor" href="#54-使用演示"></a> 5.4. 使用演示</h3><p><strong>model</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxxEntity</span> </span>&#123;<br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Size(min = 2, max = 14)</span><br>    <span class="hljs-meta">@CheckCase(CaseMode.UPPER)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// constructor, setter and getter</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">com.mycompany.constraints.CheckCase.message</span>=<span class="hljs-string">Case mode must be &#123;value&#125;.</span><br></code></pre></td></tr></table></figure><p><strong>junit test</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxxTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Validator validator;<br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>&#123;<br>        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();<br>        validator = factory.getValidator();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNameNotUpperCase</span><span class="hljs-params">()</span> </span>&#123;<br>        XxxEntity entity = <span class="hljs-keyword">new</span> XxxEntity(<span class="hljs-string">&quot;aaabbbccc&quot;</span>);<br>        Set&lt;ConstraintViolation&lt;XxxEntity&gt;&gt; constraintViolations = validator.validate(entity);<br>        assertEquals(<span class="hljs-number">1</span>, constraintViolations.size());<br>        assertEquals(<span class="hljs-string">&quot;Case mode must be UPPER.&quot;</span>, constraintViolations.iterator().next().getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例中同一属性上的多个注解也可以定义成组合注解。</p><h2 id="6-统一异常处理"><a class="markdownIt-Anchor" href="#6-统一异常处理"></a> 6. 统一异常处理</h2><h3 id="61-restcontrolleradvice-和-exceptionhandler"><a class="markdownIt-Anchor" href="#61-restcontrolleradvice-和-exceptionhandler"></a> 6.1. RestControllerAdvice 和 ExceptionHandler</h3><p>前文只是梳理了 Bean Validation 规范的基础概念和其实现 Hibernate Validator 的基本使用。实现自定义参数校验后，Web 应用还需要对参数校验结果做统一异常处理，处理成统一的格式（例中是 <code>BaseResponse</code>）抛出到前端。</p><p>Spring Web Restful 应用中，这个捕获异常并统一处理的机制是 <code>RestControllerAdvice</code> + <code>ExceptionHandler</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionTranslator</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-meta">@ExceptionHandler(ConstraintViolationException .class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseResponse <span class="hljs-title">handleError</span><span class="hljs-params">(ConstraintViolationException e)</span> </span>&#123;...&#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseResponse <span class="hljs-title">handleError</span><span class="hljs-params">(MethodArgumentNotValidException e)</span> </span>&#123;...&#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(Throwable.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseResponse <span class="hljs-title">handleError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/weixin_36142042/article/details/104850543">@RestControllerAdvice 全局异常处理起作用的原理</a></p></blockquote><p>Spring Mvc 应用中统一异常处理方式由于需返回 HTML 页面，实现方式则是，实现 <code>ErrorController</code> 接口，定制不同页面。</p><h3 id="62-spring-security-统一异常处理"><a class="markdownIt-Anchor" href="#62-spring-security-统一异常处理"></a> 6.2. spring security 统一异常处理</h3><p><a href="#">待填</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>堆建立的两种方法——“上浮”和“下沉”</title>
    <link href="/2022/01/10/%E5%A0%86%E5%BB%BA%E7%AB%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E2%80%9C%E4%B8%8A%E6%B5%AE%E2%80%9D%E5%92%8C%E2%80%9C%E4%B8%8B%E6%B2%89%E2%80%9D/"/>
    <url>/2022/01/10/%E5%A0%86%E5%BB%BA%E7%AB%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E2%80%9C%E4%B8%8A%E6%B5%AE%E2%80%9D%E5%92%8C%E2%80%9C%E4%B8%8B%E6%B2%89%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="堆结构"><a class="markdownIt-Anchor" href="#堆结构"></a> 堆结构</h3><p>堆通常是一个可以被看做一棵完全二叉树的数组对象。核心也是唯一特征是堆中某个节点的值总是不大于或不小于其父节点的值。</p><p><img src="https://s2.loli.net/2022/01/09/JlEo2LXAwrDtTSR.png" alt="image-20190914152039272.png" /></p><h3 id="建堆算法"><a class="markdownIt-Anchor" href="#建堆算法"></a> 建堆算法</h3><p>以大顶堆为例讨论两种常用的堆建立的方法</p><h4 id="1-上浮"><a class="markdownIt-Anchor" href="#1-上浮"></a> 1. “上浮”</h4><p>一个常见场景是要在无序而数据量未知的输入流中动态地建立堆。这种场景下建堆实现较简单，即依次将新结点插入到堆中。</p><h5 id="算法思路和实现"><a class="markdownIt-Anchor" href="#算法思路和实现"></a> 算法思路和实现</h5><p>对每个新结点同父节点比较，大于父结点就与之交换，然后递归这个过程直到根节点，类似一个“上浮”的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heap.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j = (j - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">int</span> parent = heap[(j - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (parent &lt; heap[j]) &#123;<br>                heap[(j - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = heap[j];<br>                heap[j] = parent;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h5><p>算法的时间复杂度分析也较为容易，设输入数组长为 N，堆的深度为 log<sub>2</sub>N（设为 k），考虑最坏情况：要用 <code>[0, 1, 2, 3, 4, 5...]</code> 建立大顶堆</p><ol><li>第 1 层 1 个结点（0）比较 0 次交换 0 次</li><li>第 2 层 2 个结点（1，2）各比较 1 次交换 1 次</li><li>第 3 层 4 个结点（3，4，5，6）各比较 2 次交换 2 次</li><li>第 i 层 2<sup>i-1</sup> 个结点各比较 i 次交换 i 次</li><li>…</li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></munderover><msup><mn>2</mn><mi>i</mi></msup><mo>∗</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">S = \sum_{i=0}^{k} 2^i*i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mn>2</mn><mi>S</mi><mo>−</mo><mi>S</mi><mspace linebreak="newline"></mspace><mo>=</mo><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></munderover><msup><mn>2</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>∗</mo><mi>i</mi></mrow><mo>−</mo><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></munderover><msup><mn>2</mn><mi>i</mi></msup><mo>∗</mo><mi>i</mi></mrow><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">S=2S-S\\={\sum_{i=0}^{k} 2^{i+1}*i}-{\sum_{i=0}^{k}2^i*i}\\=(k-2)2^k-4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></span></p><p>即时间复杂度为 O(nlogn)</p><h4 id="2-下沉"><a class="markdownIt-Anchor" href="#2-下沉"></a> 2. “下沉”</h4><p>适用场景是将给定的数组调整为堆，性能更好，也是堆排序的常用建堆方式。</p><h5 id="算法思路和实现-2"><a class="markdownIt-Anchor" href="#算法思路和实现-2"></a> 算法思路和实现</h5><p>相对前者，它是一种自底向上建堆的方法，即从后向前遍历，判断当前结点与其两个孩子结点的大小关系，小于孩子结点则交换，类似一个“下沉”的过程。</p><p><code>arr.length/2 - 1</code> 是最后一个非叶结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        heapAdjust(arr, i, arr.length);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rc = heap[start]; <span class="hljs-comment">// 记录该要调整的结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * start + <span class="hljs-number">1</span>; i &lt; end; i = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; end &amp;&amp; heap[i] &lt; heap[i + <span class="hljs-number">1</span>]) i++; <span class="hljs-comment">// 取左右孩子中较大结点</span><br>        <span class="hljs-keyword">if</span> (rc &lt; heap[i]) &#123;<br>            heap[start] = heap[i]; <span class="hljs-comment">// 更新当前要调整的结点值的</span><br>            start = i; <span class="hljs-comment">// 下沉</span><br>        &#125;<br>    &#125;<br>    heap[start] = rc; <span class="hljs-comment">// 插入根节点（归位）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>递归写法易读性更好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heap, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> rc = heap[start];<br>    <span class="hljs-comment">// 取左右孩子结点点中较大者下标为 i</span><br>    <span class="hljs-keyword">int</span> i = start * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; end &amp;&amp; heap[i] &lt; heap[i + <span class="hljs-number">1</span>]) i++;<br>    <span class="hljs-keyword">if</span> (i &lt; end &amp;&amp; rc &lt; heap[i]) &#123;<br>        heap[start] = heap[i];<br>        heap[i] = rc;<br>        heapAdjust2(heap, i, end);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法参考了严蔚敏奶奶《数据结构》教材的实现，交换这一过程处理相对巧妙</p><h5 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h5><p>设输入数组长为 N，堆的深度为 log<sub>2</sub>N（设为 k），考虑最坏情况：要用 <code>[0, 1, 2, 3, 4, 5...]</code> 建立大顶堆</p><ol><li>第 k 层 2<sup>k-1</sup> 个结点均为叶子结点不需要考虑</li><li>第 k-1 层 2<sup>k-2</sup> 个结点各比较 1 次交换 1 次</li><li>…</li><li>第 3 层 4 个结点（3，4，5，6）各比较 k-3 次交换 k-3 次</li><li>第 2 层 2 个结点（1，2）各比较 k-2 次交换 k-2 次</li><li>第 1 层根节点（1）比较 k-1 次，交换 k-1 次</li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mi>i</mi></mrow></msup><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S = \sum_{i=1}^{k-1} 2^{k-i}(k-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mn>2</mn><mi>S</mi><mo>−</mo><mi>S</mi><mspace linebreak="newline"></mspace><mo>=</mo><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo>−</mo><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mi>i</mi></mrow></msup><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mspace linebreak="newline"></mspace><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mi>k</mi><mspace linebreak="newline"></mspace><mo>=</mo><mi>N</mi><mo>−</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">S=2S-S\\={\sum_{i=1}^{k-1}2^{k-i+1}(k-i)}-{\sum_{i=1}^{k-1}2^{k-i}(k-i)}\\=2^k-k\\=N - \log_{2}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9824379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span></span></p><ul><li>S = k-1 + 2(k-2) + 2<sup>2</sup>(k-3) + 2<sup>3</sup>(k-4) + … + 2<sup>k-3</sup> * 2 + 2<sup>k-2</sup></li><li>2S =        2(k-1) + 2<sup>2</sup>(k-2) + 2<sup>3</sup>(k-3) + … + 2<sup>k-3</sup> * 3 + 2 <sup>k-2</sup> *2 + 2<sup>k-1</sup></li></ul><p>即时间复杂度为 O(n)</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/09/hello-world/"/>
    <url>/2022/01/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【OS 基础课笔记】经典进程同步问题的记录型信号量机制解决方案</title>
    <link href="/2021/12/16/KKnYhVDri/"/>
    <url>/2021/12/16/KKnYhVDri/</url>
    
    <content type="html"><![CDATA[<p>信号量（Semaphore）机制由圣 Dijkstra 于1956 年提出，是一种卓有成效的进程同步工具，现已被广泛运用在各类单处理机、多处理机和网络系统中。</p><span id="more"></span><h2 id="1-记录型信号量机制"><a class="markdownIt-Anchor" href="#1-记录型信号量机制"></a> 1. 记录型信号量机制</h2><p>除了初始化操作外，信号量只能通过两个原子操作 <code>wait()</code> 和 <code>signal()</code>，也称 P 操作和 V 操作。其中记录型信号量定义为 ① 一个整型的 <code>S-&gt;value</code> 表示资源数目（大于 0）或阻塞队列的长度（小于 0）；② 进程列表 <code>S-&gt;list</code> 表示阻塞在该信号量上的进程队列。<br />当 <code>S-&gt;value</code> 定义为 1 时，记录型信号量转化为互斥信号量表示一个用于互斥访问的临界资源。</p><p>记录型信号量的数据结构和 P、V 操作描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 记录型信号量的进程阻塞队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process_control_block</span> &#123;</span><br>    <span class="hljs-keyword">int</span> pid; <span class="hljs-comment">// 进程标识符</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process_control_block</span> * <span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 队列指针</span><br>&#125; process_control_block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * semaphore 记录型信号量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> value; <span class="hljs-comment">// 资源数量</span><br>    process_control_block * <span class="hljs-built_in">list</span>; <span class="hljs-comment">// 阻塞队列头</span><br>&#125; semaphore;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(semaphore * S)</span> </span>&#123;<br>    S-&gt;value --;<br>    <span class="hljs-keyword">if</span> (S-&gt;value &lt; <span class="hljs-number">0</span>) block(S-&gt;<span class="hljs-built_in">list</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">(semaphore * S)</span> </span>&#123;<br>    S-&gt;value ++;<br>    <span class="hljs-keyword">if</span> (S-&gt;value &lt;= <span class="hljs-number">0</span>) wakeup(S-&gt;<span class="hljs-built_in">list</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 block() 和 wakeup() 是操作系统原语，分别用于 阻塞 和 唤醒 进程。</p><h2 id="2-生产者-消费者问题"><a class="markdownIt-Anchor" href="#2-生产者-消费者问题"></a> 2. 生产者-消费者问题</h2><blockquote><p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多进程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p></blockquote><h3 id="21-基于循环缓冲的解决方案"><a class="markdownIt-Anchor" href="#21-基于循环缓冲的解决方案"></a> 2.1 基于循环缓冲的解决方案</h3><p>假定缓冲池中有 n 个缓冲区并用循环结构组织，可以利用互斥信号量 mutex 实现各进程对缓冲池的互斥使用，用信号量 empty 和 full 分别表示缓冲池中空缓冲和满缓冲资源的数目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> in = <span class="hljs-number">0</span>, out = <span class="hljs-number">0</span>;<br>item buffer[n];<br>semaphore mutex = <span class="hljs-number">1</span>, full = <span class="hljs-number">0</span>, empty = n;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产者进程——</span><br><span class="hljs-comment"> * 申请空缓冲并生产数据项，如果无空缓冲区资源则自我阻塞直到被空缓冲区资源唤醒</span><br><span class="hljs-comment"> * 需注意缓冲池资源的互斥访问</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        item nextp = produce_an_item();<br>        P(empty);<br>        P(mutex);<br>        buffer[in] = nextp;<br>        in = (in+<span class="hljs-number">1</span>) % n;<br>        V(mutex);<br>        V(full);<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消费者进程——</span><br><span class="hljs-comment"> * 申请满缓冲区并消费数据项，如果无满缓冲区资源则自我阻塞直到被满缓冲区资源唤醒</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(full);<br>        P(mutex);<br>        item nextc = buffer[out];<br>        out = (out+<span class="hljs-number">1</span>) % n;<br>        V(mutex);<br>        V(empty);<br>        consume_the_item(nextc);<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主程序描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">cobegin</span><br><span class="hljs-function">        <span class="hljs-title">producer</span><span class="hljs-params">()</span></span>; consumer();<br>    coend<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="22-基于单缓冲的但生产者-单消费者类同步问题"><a class="markdownIt-Anchor" href="#22-基于单缓冲的但生产者-单消费者类同步问题"></a> 2.2 基于单缓冲的但生产者-单消费者类同步问题</h3><p>在测控系统中，数据采集任务将数据送入一单缓冲区，计算任务对该但缓冲区中数据取出并做计算处理。在这类问题中，信号量 full 和 empty 已经可以表示单缓冲资源的互斥属性了，相对 2.1 的代码描述，可以不再定义互斥信号量 mutex。</p><h2 id="3-哲学家进餐问题"><a class="markdownIt-Anchor" href="#3-哲学家进餐问题"></a> 3. 哲学家进餐问题</h2><p>由圣 Dijkstra 于1971 年提出并解决的用来演示在并发计算中多线程同步时产生的问题，旨在说明避免死锁和资源耗尽等问题。它的具体描述如下：</p><blockquote><p>有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子，平时哲学家进行思考，饥饿时便试图取其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐，该哲学家进餐完毕后，放下左右两只筷子又继续思考。</p></blockquote><h3 id="31-信号量定义和哲学家活动描述"><a class="markdownIt-Anchor" href="#31-信号量定义和哲学家活动描述"></a> 3.1 信号量定义和哲学家活动描述</h3><p>筷子作为临界资源，一段时间仅允许一位哲学家使用，为了实现对筷子的互斥使用，可以为每根筷子设置一个互斥信号量，于是第 i 位 哲学家的活动可描述为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 临界资源筷子</span><br><span class="hljs-comment"> */</span><br>semaphore chopstick[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第 i 位哲学家</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">philosopher_i</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(chopstick[i]);<br>        P(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        <span class="hljs-comment">// eat</span><br>        V(chopstick[i]);<br>        V(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        <span class="hljs-comment">// think</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="32-存在问题分析和进一步解决方案"><a class="markdownIt-Anchor" href="#32-存在问题分析和进一步解决方案"></a> 3.2 存在问题分析和进一步解决方案</h3><p>上述方案中，每个哲学家先拿起左边筷子再拿起右边筷子，不会出现相邻的两个哲学家竞争同一根筷子的情况，但可能出现每个哲学家同时饥饿并拿起自己左边的筷子，引起死锁。</p><p>为了避免死锁，有如下三种解决方案：</p><ol><li>双筷同举——当且仅当拿起两根筷子才允许进餐</li><li>奇偶有别——1、3、5 号哲学家先左后右，2、4 号哲学家先右后左</li><li>进餐限制——最多允许 4 根筷子被同时申请</li></ol><p>代码描述分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 双筷齐举</span><br><span class="hljs-comment"> * 设置一个互斥信号量，同一时间只允许一个进程做申请资源 wait 操作</span><br><span class="hljs-comment"> * 可以解决死锁问题，但是显然进程并发性变差</span><br><span class="hljs-comment"> */</span><br>semaphore mutex = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">philosopher_i</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(mutex);<br>        P(chopstick[i]);<br>        P(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        V(mutex);<br>        <span class="hljs-comment">// eat</span><br>        V(chopstick[i]);<br>        V(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        <span class="hljs-comment">// think</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 2. 奇偶有别</span><br><span class="hljs-comment"> * 1、3、5 号哲学家先申请 i 号筷子后申请 (i+1) % 5 号筷子</span><br><span class="hljs-comment"> * 2、4 号哲学家先申请  (i+1) % 5 号筷子后申请 i 号 筷子</span><br><span class="hljs-comment"> * 经分析，解决了死锁问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 实现略</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 3. 进餐限数</span><br><span class="hljs-comment"> * 设置一个初始化值为 4 资源信号量表示申请资源的权力</span><br><span class="hljs-comment"> * 最多只允许 4 个哲学家在申请筷子资源</span><br><span class="hljs-comment"> * 可以解决死锁问题，而进程并发性也未变差</span><br><span class="hljs-comment"> */</span><br>semaphore limit = <span class="hljs-number">4</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">philosopher_i</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(limit);<br>        P(chopstick[i]);<br>        P(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        V(limit);<br>        <span class="hljs-comment">// eat</span><br>        V(chopstick[i]);<br>        V(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        <span class="hljs-comment">// think</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="33-其他资料"><a class="markdownIt-Anchor" href="#33-其他资料"></a> 3.3 其他资料</h3><blockquote><p><a href="https://leetcode-cn.com/problems/the-dining-philosophers/">https://leetcode-cn.com/problems/the-dining-philosophers/</a></p></blockquote><h2 id="4-读者-写者问题"><a class="markdownIt-Anchor" href="#4-读者-写者问题"></a> 4. 读者-写者问题</h2><p>读者-写者问题常用于测试新同步原语，其问题描述如下：<br />多个进程共享一个数据对象，只要求读的进程称读者进程，有写或修改要求的进程称写者进程。读操作可由多个读者进程同时执行，而写操作具有排他性。</p><h3 id="41-读者优先"><a class="markdownIt-Anchor" href="#41-读者优先"></a> 4.1 读者优先</h3><p>下图是读者-写者问题的读者优先解决方案也即一般化的解决方案<br /><img src="https://n1000g.github.io/post-images/1639600123226.png" alt="读者优先" /></p><p>即第一个到来的读者进程和其他写者进程一同竞争数据对象的资源信号量，如果发现资源所有者为读者进程，新来的读者进程可以跳过申请，直接进行读操作。而实现这个过程又需要对读者进程进行计数：</p><ul><li>考虑到写者进程要与其他进程互斥执行，设置写互斥信号量 wmutex；</li><li>读者进程之间可并发执行，设置计数变量 readercount 初始为 0；</li><li>readercount 对于多个读者进程而言是临界资源，应为之设立互斥信号量 rmutex。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> readercount = <span class="hljs-number">0</span>;<br>semaphore rmutex = <span class="hljs-number">1</span>, wmutex = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写者进程——互斥访问</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(wmutex);<br>        写操作<br>        V(wmutex);<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读者进程——</span><br><span class="hljs-comment"> * 系统中只存在的当前唯一的读者进程 0 时，与写者进程竞争临界资源</span><br><span class="hljs-comment"> * 访问 readercount 并计数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(rmutex);<br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) P(wmutex);<br>        readercount++;<br>        V(rmutex);<br>        读操作<br>        P(rmutex);<br>        readercount--;<br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) V(wmutex);<br>        V(rmutex);<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主程序描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cobegin<br>        reader₁(); reader₂(); ...<br>        writer₁(); writer₂(); ...<br>    coend<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="42-公平型读者-写者问题即解决方案"><a class="markdownIt-Anchor" href="#42-公平型读者-写者问题即解决方案"></a> 4.2 公平型读者-写者问题即解决方案</h3><p>上述解决方案对写者进程来说，一旦系统中有读者进程在进行读操作，就必须等待，直到 readercount 等于 0。要消除这个读者优先，实现新来进程无论是读者还是写者都阻塞于同一队列，公平竞争临界资源，即“公平型读者-写者问题”的解决方案如下：<br /><img src="https://n1000g.github.io/post-images/1639601542576.png" alt="公平型读者写者" /></p><p>如图，设置一个互斥信号量 S，读者进程和写者进程都需要先竞争 S，再进行之前的操作，使得阻塞在 S 上的进程是什么属性都无所谓，实现公平竞争。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> readercount = <span class="hljs-number">0</span>;<br>semaphore rmutex = <span class="hljs-number">1</span>, wmutex = <span class="hljs-number">1</span>, S = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写者进程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(S);<br>        P(wmutex)<br>        V(S);<br>        写操作<br>        V(wmutex);<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读者进程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(S);<br>        P(rmutex);<br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) P(wmutex);<br>        readercount++;<br>        V(rmutex);<br>        V(S);<br>        读操作<br>        P(rmutex);<br>        readercount--;<br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) V(wmutex);<br>        V(rmutex);<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="43-写者优先"><a class="markdownIt-Anchor" href="#43-写者优先"></a> 4.3 写者优先</h3><p>如题。<br /><img src="https://n1000g.github.io/post-images/1639601905558.png" alt="写者优先" /></p><p>仅第一个到达的写者进程与读者进程一起去 S 处排队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> readercount = <span class="hljs-number">0</span>, writercount = <span class="hljs-number">0</span>;<br>semaphore rmutex = <span class="hljs-number">1</span>, wmutex = <span class="hljs-number">1</span>, S = <span class="hljs-number">1</span>, mutex = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写者进程——添加了与读者优先解决方案中与读者相似的逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(mutex);<br>        <span class="hljs-keyword">if</span> (writercount == <span class="hljs-number">0</span>) P(S);<br>        writercount ++;<br>        V(mutex);<br><br>        P(wmutex)<br>        写操作<br>        V(wmutex);<br>        <br>        P(mutex);<br>        writercount --;<br>        <span class="hljs-keyword">if</span> (writercount == <span class="hljs-number">0</span>) V(S);<br>        V(mutex);<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读者进程——同 4.3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(S);<br>        P(rmutex);<br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) P(wmutex);<br>        readercount++;<br>        V(rmutex);<br>        V(S);<br>        读操作<br>        P(rmutex);<br>        readercount--;<br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) V(wmutex);<br>        V(rmutex);<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="44-限定读者问题"><a class="markdownIt-Anchor" href="#44-限定读者问题"></a> 4.4 限定读者问题</h3><p>如题<br />可增设 rmax 信号量，使多出来的读者进程阻塞至此。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> readercount = <span class="hljs-number">0</span>;<br>semaphore rmutex = <span class="hljs-number">1</span>, wmutex = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写者进程——同 4.1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(wmutex);<br>        写操作<br>        V(wmutex);<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读者进程——多余读者挂至 rmax 信号量阻塞队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(rmax);<br><br>        P(rmutex);<br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) P(wmutex);<br>        readercount++;<br>        V(rmutex);<br>        读操作<br>        P(rmutex);<br>        readercount--;<br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) V(wmutex);<br>        V(rmutex);<br><br>        V(rmax);<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-其他经典-p-v-操作问题"><a class="markdownIt-Anchor" href="#5-其他经典-p-v-操作问题"></a> 5. 其他经典 P-V 操作问题</h2><h3 id="51-独木桥-单行道问题"><a class="markdownIt-Anchor" href="#51-独木桥-单行道问题"></a> 5.1 独木桥、单行道问题</h3><p>如题，南北通车，单行道上只能走同一方向的车辆。使用记录型信号量模拟道路情况。<br />分析：两个方向的车辆基本性质完全相同，均类似读者-写者问题中写者进程。使每类第一个到达的进程与另一类进程竞争单行道这一临界资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 南边来的和北边来的车辆数量</span><br><span class="hljs-comment"> * 和临界资源——单行道</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">int</span> southcount = <span class="hljs-number">0</span>, northcount = <span class="hljs-number">0</span>;<br>semaphore road = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟由南向北的车辆</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">S2N</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(smutex);<br>        <span class="hljs-keyword">if</span> (southcount == <span class="hljs-number">0</span>) P(road);<br>        southcount++;<br>        V(smutex);<br>        通过单行道<br>        P(smutex);<br>        southcount--;<br>        <span class="hljs-keyword">if</span> (southcount == <span class="hljs-number">0</span>) V(road);<br>        V(smutex);<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟由北向南的车辆</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">N2S</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        P(nmutex);<br>        <span class="hljs-keyword">if</span> (northcount == <span class="hljs-number">0</span>) P(road);<br>        northcount++;<br>        V(nmutex);<br>        通过单行道<br>        P(nmutex);<br>        northcount--;<br>        <span class="hljs-keyword">if</span> (northcount == <span class="hljs-number">0</span>) V(road);<br>        V(nmutex);<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="52-司机售票员同步问题"><a class="markdownIt-Anchor" href="#52-司机售票员同步问题"></a> 5.2 司机售票员同步问题</h3><p>问题描述：汽车司机与售票员之间必须协同工作，一方面，只有售票员把车门关好了司机才能开车，因此，售票员关好车门应通知司机开车。另一方面，只有当司机已经停下，售票员才能开门上下客，故司机停车后应通知售票员。假定某辆公共汽车上有两名售票员与一名司机，汽车当前正在始发站停车上客，试设必要的信号灯及赋初值，写出他们的同步过程。</p><p><strong>问题解答</strong></p><blockquote><p><a href="https://www.codeleading.com/article/32956105455/">https://www.codeleading.com/article/32956105455/</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【OS 基础课笔记】二、进程管理</title>
    <link href="/2021/12/13/k2efUYuav/"/>
    <url>/2021/12/13/k2efUYuav/</url>
    
    <content type="html"><![CDATA[<h2 id="1-进程与线程"><a class="markdownIt-Anchor" href="#1-进程与线程"></a> 1. 进程与线程</h2><h3 id="11-进程的定义与特征"><a class="markdownIt-Anchor" href="#11-进程的定义与特征"></a> 1.1 进程的定义与特征</h3><p>在多道程序环境下，允许多个程序并发执行，此时它们失去封闭性，并具有间断性及不可再现性的特征。为此映入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><p>为使并发的程序能独立运行，必须为止配置一个专门的数据结构，称为进程控制块（Process Control Block，PCB）。操作系统利用 PCB 描述一个进程的基本情况和运行状态，所谓创建进程就是创建一个 PCB。PCB、程序段和数据段三部分共同构成了<strong>进程实体</strong>，也即进程映像。进程是动态的，进程映像是静态的；</p><p>由此给出进程的定义——<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p><p>并可知进程的主要特征有动态性、并发性、独立性、异步性和结构性。</p><h3 id="12-进程控制块process-control-blockpcb"><a class="markdownIt-Anchor" href="#12-进程控制块process-control-blockpcb"></a> 1.2 进程控制块（Process Control Block，PCB）</h3><p><strong>PCB 是进程存在的唯一标志</strong>，也是操作系统管理和控制并发执行进程的依据。它常驻内存并存放在操作系统专门开辟的 PCB 区。进程控制块中有如下信息：</p><ul><li>进程标识符<ul><li>内部 PID、外部 PID</li><li>父进程、子进程、用户标识符</li></ul></li><li>处理器状态信息<ul><li>通用寄存器、PC、PSW、用户栈指针寄存器等</li></ul></li><li>进程调度信息<ul><li>进程状态、进程优先级、事件等</li></ul></li><li>进程控制信息<ul><li>程序和数据地址、进程同步通信机制</li><li>资源清单、链接指针、进程图</li></ul></li></ul><p><strong>Linux 中对 PCB 的描述</strong></p><blockquote><p><a href="https://blog.csdn.net/a1414345/article/details/55550460">Linux中进程控制块（PCB）的task_struct结构描述</a></p></blockquote><blockquote><p><a href="https://github.com/liexusong/linux-source-code-analyze/blob/master/process-management.md">linux-source-code-analyze/process-management.md</a></p></blockquote><h3 id="13-进程状态变迁"><a class="markdownIt-Anchor" href="#13-进程状态变迁"></a> 1.3 进程状态变迁</h3><p>进程在其生命周期内由于系统中各个进程之间相互制约关系和系统环境的变换，使得进程状态也在不断变化，通常具有如下五种状态：<br /><img src="https://n1000g.github.io/post-images/1639525596602.png" alt="进程五态模型" /></p><p>进程的五态模型假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的，即七态模型：<br /><img src="https://n1000g.github.io/post-images/1639525745466.png" alt="进程七态模型" /></p><p><strong>Linux 中的进程状态</strong></p><blockquote><p><a href="https://blog.csdn.net/zyboy2000/article/details/4179834">Linux进程状态(ps stat)之R、S、D、T、Z、X</a></p></blockquote><h3 id="14-进程同步"><a class="markdownIt-Anchor" href="#14-进程同步"></a> 1.4 进程同步</h3><p>为了协调并发执行的进程只键的相互制约关系，引入了进程同步的概念。</p><h4 id="141-基本概念"><a class="markdownIt-Anchor" href="#141-基本概念"></a> 1.4.1 基本概念</h4><p><strong>同步和互斥</strong><br />同步也称直接制约关系，互斥也称间接制约关系。前者例如 A 进程通过单缓冲向 B 进程提供数据，缓冲区空时，B 进程需阻塞等待；后者例如 A、B进程都需要使用系统中仅有的唯一的 I/O 设备 C，C 被分配给 A 时，B 需要阻塞等待。</p><p><strong>临界资源和临界区</strong><br />临界资源指一次仅仅运行一个进程使用的资源，例如打印机等物理设备、共享变量等；<br />临界区指访问临界资源那段代码，又称临界段。临界区前的检查部分称进入区，临界区后的标志清除部分称退出区。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    entry section;<br>    critical section;<br>    <span class="hljs-built_in">exit</span> section;<br>    remainder section;<br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><h4 id="142-进程同步准则"><a class="markdownIt-Anchor" href="#142-进程同步准则"></a> 1.4.2 进程同步准则</h4><p>同步机制应当遵循如下准则：</p><ol><li>空闲让进——临界区空闲时，当运行一个请求进入临界区的进程立刻进入；</li><li>忙则等待——有进程进入临界区，其他试图进入临界区的进程必须等待；</li><li>有限等待——对请求访问的进程，需保证能在有限时间内进入临界区；</li><li>让权等待——当进程不能进入临界区时，应当释放处理器资源，防止进程忙等待。</li></ol><h4 id="143-进程同步机制"><a class="markdownIt-Anchor" href="#143-进程同步机制"></a> 1.4.3 进程同步机制</h4><h5 id="1431-硬件方法"><a class="markdownIt-Anchor" href="#1431-硬件方法"></a> 1.4.3.1 硬件方法</h5><ol><li>关中断——进入锁测试前屏蔽一切中断请求，不进行进程或线程切换；</li><li>Test-and-Set——指令，指令执行期间不允许被中断，获取所访问的临界资源的占用情况；</li><li>Swap 指令——同上，硬件逻辑实现</li></ol><h5 id="1432-软件方法"><a class="markdownIt-Anchor" href="#1432-软件方法"></a> 1.4.3.2 软件方法</h5><ol><li><p>单标志位——设置单标志位 <code>turn</code> 用于指示允许进入临界区的进程编号，两个进程循环进入临界区，一个进程结束另一个进程也无法访问自己的临界区，违反“空闲让进”原则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Process0:    Process1:<br><span class="hljs-keyword">while</span>(turn != <span class="hljs-number">0</span>);    <span class="hljs-keyword">while</span>(turn != <span class="hljs-number">1</span>);<br>critical section;    criticla section;<br>turn = <span class="hljs-number">1</span>;    turn = <span class="hljs-number">0</span>;<br>remainder section;    remainder section;<br></code></pre></td></tr></table></figure></li><li><p>双标志位先检查——进入临界区前先检查是否被占用，但可能多个进程同时进入临界区，违反“忙则等待”原则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Process0:    Process1:<br><span class="hljs-keyword">while</span>(flag1);    <span class="hljs-keyword">while</span>(flag0);<br>flag0 = <span class="hljs-literal">true</span>;    flag1 = <span class="hljs-literal">true</span>;<br>critical section;    criticla section;<br>flag0 = <span class="hljs-literal">false</span>;    flag1 = <span class="hljs-literal">false</span>;<br>remainder section;    remainder section;<br></code></pre></td></tr></table></figure></li><li><p>双标志位后检查——算法二先检查占用情况再设置自己占用标志位，算法三则先设置标志位后检查占用情况，避免了同时进入临界区违反“忙则等待“的情况，但出现了”饥饿“的现象，违反”空闲让进“原则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Process0:    Process1:<br>flag0 = <span class="hljs-literal">true</span>;    flag1 = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(flag1);    <span class="hljs-keyword">while</span>(flag0);<br>critical section;    criticla section;<br>flag0 = <span class="hljs-literal">false</span>;    flag1 = <span class="hljs-literal">false</span>;<br>remainder section;    remainder section;<br></code></pre></td></tr></table></figure></li><li><p>Peterson’s Algorithm——既设置占用标志位 <code>flag</code> 也设置 <code>turn</code> 标志，利用 <code>flag</code> 解决互斥访问问题，利用 <code>turn</code> 解决”饥饿“现象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Process0:    Process1:<br>flag0 = <span class="hljs-literal">true</span>; turn=<span class="hljs-number">1</span>;    flag1 = <span class="hljs-literal">true</span>;turn = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(flag1 &amp;&amp; turn == <span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span>(flag0 &amp;&amp; turn == <span class="hljs-number">0</span>);<br>critical section;    criticla section;<br>flag0 = <span class="hljs-literal">false</span>;    flag1 = <span class="hljs-literal">false</span>;<br>remainder section;    remainder section;<br></code></pre></td></tr></table></figure></li></ol><p>以上方案都没有遵守”让权等待“原则。</p><h5 id="1433-信号量机制"><a class="markdownIt-Anchor" href="#1433-信号量机制"></a> 1.4.3.3 信号量机制</h5><p>信号量（Semaphore）机制于 1956 年由圣 Dijkstra 提出，是一种卓有成效的进程同步工具，现已被广泛运用在各类单处理机、多处理机和网络系统中。除了初始化操作外，信号量只能通过两个原子操作 <code>wait()</code> 和 <code>signal()</code>，也称 P 操作和 V 操作。</p><ol><li><p>整型信号量——整型信号量被定义为一个用于表示资源数目的整型量 S，P、V 操作分别定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">wait(S) &#123;<br>    <span class="hljs-keyword">while</span>(S &lt;= <span class="hljs-number">0</span>);<br>    S--;<br>&#125;<br><br>signal(S)&#123;<br>    S++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>记录型信号量——一个整型的 <code>S-&gt;value</code> 表示资源数目（大于 0）或阻塞队列的长度（小于 0）；进程列表 <code>S-&gt;list</code> 表示阻塞在该信号量上的进程队列；<code>S-&gt;value</code> 等于 1 时，记录型信号量转化为互斥信号量表示一个用于互斥访问的临界资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 记录型信号量的进程阻塞队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process_control_block</span> &#123;</span><br>    <span class="hljs-keyword">int</span> pid; <span class="hljs-comment">// 进程标识符</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process_control_block</span> * <span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 队列指针</span><br>&#125; process_control_block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * semaphore 记录型信号量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> value; <span class="hljs-comment">// 资源数量</span><br>    process_control_block * <span class="hljs-built_in">list</span>; <span class="hljs-comment">// 阻塞队列头</span><br>&#125; semaphore;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(semaphore * S)</span> </span>&#123;<br>    S-&gt;value --;<br>    <span class="hljs-keyword">if</span> (S-&gt;value &lt; <span class="hljs-number">0</span>) block(S-&gt;<span class="hljs-built_in">list</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">(semaphore * S)</span> </span>&#123;<br>    S-&gt;value ++;<br>    <span class="hljs-keyword">if</span> (S-&gt;value &lt;= <span class="hljs-number">0</span>) wakeup(S-&gt;<span class="hljs-built_in">list</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>AND 型信号量</p></li><li><p>信号量集机制（Unix）</p></li></ol><h5 id="1434-管程机制"><a class="markdownIt-Anchor" href="#1434-管程机制"></a> 1.4.3.4 管程机制</h5><p>信号量机制要求每个要访问临界资源的进程都自备同步操作 P 和 V，这给系统管理带来了极大的麻烦。计算机系统中的各类软硬件资源都可以用数据结构进行抽象描述，即用少量信息表征该资源而忽略内部结构和实现细节。据此，可用共享数据结构抽象地表示系统中的共享资源，并对该共享数据结构实施特定的操作定义为一组过程。管程是由一组数据及定义在这组数据上的对这组数据的操作组成的软件模块。</p><p>管程有如下基本特性：</p><ol><li>局部于管程的数据只能被局部与管程内的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程。</li></ol><p><strong>理解和相关资料</strong></p><blockquote><p><a href="https://www.zhihu.com/question/30641734">知乎：如何理解管程</a><br /><a href="https://icecrea-blog.gitbook.io/blog/bing-fa/guan-cheng-mo-xing-yu-deng-dai-tong-zhi-ji-zhi">https://icecrea-blog.gitbook.io/blog/bing-fa/guan-cheng-mo-xing-yu-deng-dai-tong-zhi-ji-zhi</a><br /><a href="https://segmentfault.com/a/1190000021557492">https://segmentfault.com/a/1190000021557492</a></p></blockquote><h4 id="144-进程同步经典问题"><a class="markdownIt-Anchor" href="#144-进程同步经典问题"></a> 1.4.4 进程同步经典问题</h4><p><a href="https://n1000g.github.io/post/KKnYhVDri/">https://n1000g.github.io/post/KKnYhVDri/</a></p><h3 id="15-进程通信"><a class="markdownIt-Anchor" href="#15-进程通信"></a> 1.5 进程通信</h3><p>进程通信指的是进程之间的信息交换。由于进程的互斥与同步也需要在进程间交换一些信息，故也可以把它们归为进程通信，称为低级进程通信。以信号量机制为例，它之所以低级的原因在于：① 效率低；② 通信对用户不透明。要在进程间传送大量数据，应当利用 OS 提供的高级通讯工具。<br /><img src="https://n1000g.github.io/post-images/1639621745101.png" alt="进程通信模型" /></p><h4 id="151-进程通信的类型"><a class="markdownIt-Anchor" href="#151-进程通信的类型"></a> 1.5.1 进程通信的类型</h4><p>高级通信机制可分为四大类：</p><ol><li>共享存储器系统——基于共享存储结构或共享存储区；</li><li>管道（pipe）通信系统——所谓“管道”是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件；</li><li>消息传递系统——进程将要传递的数据封装到格式化的“消息”（message）中，利用 OS 提供的通信原语（直接通信方式）或某个共享的中间实体“邮箱”（间接通信方式）进行消息传递；</li><li>客户机-服务器系统——当前最主流的通信实现方式，可分为套接字（socket）、远程过程调用（RPC）和远程方法调用三类。</li></ol><h4 id="152-管道机制"><a class="markdownIt-Anchor" href="#152-管道机制"></a> 1.5.2 管道机制</h4><p>传统的 Unix 系统为进程间的通信提供了管道机制，分为有名管道和无名管道。管道本质上是一个内核缓冲区，Unix 下“一切皆文件”，但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中；无名管道一般使用 fork 函数实现父子进程的通信，命名管道用于没有血缘关系的进程也可以进程间通信；管道面向字节流、自带同步互斥机制、半双工，只能单向通信。<br /><img src="https://n1000g.github.io/post-images/1639622356041.png" alt="管道模型" /></p><h4 id="153-直接消息传递系统"><a class="markdownIt-Anchor" href="#153-直接消息传递系统"></a> 1.5.3 直接消息传递系统</h4><p>直接消息传递系统中，发送进程利用 OS 提供消息发送原语，直接把消息发送给目标进程：<code>send(receiver, message);</code>，接收进程利用接收原语 <code>receive(sender, message);</code> 或 <code>receive(id, message);</code> 接收消息。</p><p>Unix 系统提供了消息队列的构建（msgget）、操作（msgctl）、发送（msgsnd）、接收（msgrcv）等系统调用。</p><h4 id="154-信箱通信间接消息传递系统"><a class="markdownIt-Anchor" href="#154-信箱通信间接消息传递系统"></a> 1.5.4 信箱通信（间接消息传递系统）</h4><p>类似直接消息传递系统，OS 提供邮箱的创建、撤销和消息的发送、接收等原语，信箱被定义为一种共享数据结构，既可以实现实时通信也可以实现延时通信。</p><h4 id="155-消息缓冲队列通信机制"><a class="markdownIt-Anchor" href="#155-消息缓冲队列通信机制"></a> 1.5.5 消息缓冲队列通信机制</h4><p>消息缓冲队列通信机制最先由 Hansan 提出并实现，后来广泛运用于本地进程之间的通信中。它根据”生产者-消费者”原理，利用内存中公用消息缓冲区实现进程之间的信息交换。发送者进程使用 Send 原语将消息直接发送给接收进程，接收进程则利用 Receive 原语接收消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息缓冲区——定义消息格式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_buffer</span> &#123;</span><br>    <span class="hljs-keyword">int</span> sender;             <span class="hljs-comment">// 发送进程 PID</span><br>    <span class="hljs-keyword">int</span> size;                  <span class="hljs-comment">// 消息大小（用于向 OS 申请消息缓冲区时）</span><br>    <span class="hljs-keyword">char</span>* text;             <span class="hljs-comment">// 消息正文</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_buffer</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//指向下一个消息缓冲区的指针</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在进程 PCB 中新增的数据项</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process_control_block</span> &#123;</span><br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_buffer</span> *<span class="hljs-title">mq</span>;</span>      <span class="hljs-comment">// 消息缓冲队列队首指针</span><br>    semaphore mq_mutex;             <span class="hljs-comment">// 消息缓冲队列互斥信号量</span><br>    semaphore mq_resource;            <span class="hljs-comment">// 消息缓冲队列资源信号量</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>A 进程调用 Send 原语，申请一个消息缓冲区 buffer，把自身发送区数据拷贝到 buffer 中并挂载到 B 进程的 *mq 上；</li><li>B 进程调用 Receive 原语，从自身 *mq 上取下一个 buffer，读出数据到自身接受区，然后释放 buffer。</li></ol><p>以下是接受原语 Send 和发送原语 Receive 的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送原语（a 为发送区地址）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(receiver, a)</span> </span>&#123;<br>    getbuf(a.size, buffer_i);<br>    buffer_i.sender = a.sender; buffer_i.size = a.size; copy(a.text, buffer_i.text);<br>    buffer_i.next = <span class="hljs-number">0</span>;<br>    P(receiver.mq_mutex);<br>    insert(&amp;reveiver.mq, buffer_i);             <span class="hljs-comment">// inqueue</span><br>    V(receiver.mq_mutex);<br>    V(receiver.mq_resource);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收原语（b 为接收区地址）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(b)</span> </span>&#123;<br>    p = get_cur_process();          <span class="hljs-comment">// 进程自身 PCB</span><br>    P(p.mq_resource);<br>    P(p.mq_mutex);<br>    remove(p.mq, buffer_i);                        <span class="hljs-comment">// dequeue</span><br>    V(p.mq_mutex);<br>    b.sender = buffer_i.sender; b.size = buffer_i.size; copy(buffer_i.text, b.text);<br>    releasebuf(buffer_i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-线程thread和多线程模型"><a class="markdownIt-Anchor" href="#16-线程thread和多线程模型"></a> 1.6 线程（Thread）和多线程模型</h3><p>引入进程是为例更好地使多道程序并发执行，提高系统资源利用率和吞吐量，增加并发程度，但进程并发机制存在一定缺陷如进程切换创建时空开销大，通信效率低等。克服这些缺陷的一个思路是使资源拥有与调度分派这两个进程的基本属性相分离，这就引入了线程。</p><p>**线程即”轻量级进程“，是一个基本的 CPU 执行单元，也即 CPU 独立调度的基本单位。**其基本特征除了 ① 是处理机的独立调度单位，可以并发执行外还有 ② 轻型实体，不拥有系统资源、③ 同一个进程下的线程共享进程资源和 ④ 有自己独立的生命周期。</p><h4 id="161-线程实现方式"><a class="markdownIt-Anchor" href="#161-线程实现方式"></a> 1.6.1 线程实现方式</h4><p>线程分为<strong>内核支持线程</strong>（Kernel Supported Thread，KST）和<strong>用户级线程</strong>（User-Level Thread，ULT）。</p><ul><li>用户级线程中有关线程的实现与管理工作由应用程序完成，与 OS 平台无关。线程切换不涉及内核空间的转换，内核意识不到线程的存在，应用程序可以通过使用编程语言提供的线程库设计成多线程程序。故当某个线程执行一个系统调用时，进程下所有线程一起阻塞。所以在单纯的用户级线程实现方式中，即使是多线程应用也无法利用多处理机的并行优势。</li><li>内核级线程中，线程管理的所有工作由内核完成，内核为进程及其内部每个线程设立<em>线程控制块</em>维护上下文信息，应用程序没有进行线程管理的代码，只有一个到内核级线程的编码接口。大多数 OS 都支持内核级线程。相对进程，它只占有很小的数据结构和堆栈，切换快开销小；相对 ULK，多处理机系统下可调度同一个进程多线程并行执行，提高系统效率。</li></ul><h4 id="162-多线程模型"><a class="markdownIt-Anchor" href="#162-多线程模型"></a> 1.6.2 多线程模型</h4><p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的链接方式。即下图所示的一对一模型、一对多模型和多对多模型。<br /><img src="https://n1000g.github.io/post-images/1639680944096.jpg" alt="多线程模型" /></p><ul><li>多对一模型，即将用户线程映射到一个内核控制线程（也就是内核里不支持线程），这些线程的管理调度在用户空间实现，仅当用户线程访问内核时才进行映射，每次仅允许一个线程进行映射。Unix 中内核中并不支持线程，可视作采用了这一模型；</li><li>一对一模型，下将每个用户级线程映射到一个内核支持线程，内核管理其调度运行，并发性最好，但系统开销巨大，OS 要对内核空间里的最大线程数有限制。Linux、Windows 等系统实现了该模型；</li><li>多对多模型，即允许多个用户级线程映射到若干个内核级线程上。综合了前两者的优缺点，但实现极端复杂，是个理论模型，曾由 IBM 主导的 NGPT 采用了多对多的线程模型，不过现在已废弃；</li></ul><h4 id="163-linux-多线程模型的实现linuxthreads-和-nptl"><a class="markdownIt-Anchor" href="#163-linux-多线程模型的实现linuxthreads-和-nptl"></a> 1.6.3 Linux 多线程模型的实现——LinuxThreads 和 NPTL</h4><p>多线程最初是由 LinuxThreads 这个工程带入到 Linux 的，但是 LinuxThreads 并不符合 POSIX 在线程方面的标准。之后的原生 POSIX 线程库（Native POSIX Thread Library，NPTL）比 LinuxThreads 更符合标准，且克服了后者的许多缺陷。</p><blockquote><p><strong><a href="https://en.wikipedia.org/wiki/POSIX">可移植操作系统接口 POSIX</a></strong> 和 <strong><a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">原生 POSIX 线程库 NPTL</a></strong><br /><a href="http://cs.uns.edu.ar/~jechaiz/sosd/clases/extras/03-LinuxThreads%20and%20NPTL.pdf">Linux threading models compared: LinuxThreads<br />and NPTL</a><br /><a href="https://www.jianshu.com/p/6c507b966ad1">【译】Linux 线程模型比较：LinuxThreads 和 NPTL</a></p></blockquote><h2 id="2-处理机调度"><a class="markdownIt-Anchor" href="#2-处理机调度"></a> 2. 处理机调度</h2><p>调度的实质是资源分配，处理机调度即对处理机这个资源进行分配。处理机调度是多道程序操作系统的基础，也是操作系统设计的核心问题。</p><h3 id="21-处理机调度类型与模型"><a class="markdownIt-Anchor" href="#21-处理机调度类型与模型"></a> 2.1 处理机调度类型与模型</h3><p>一个作业从提交到完成往往要经历三级调度。</p><ul><li>作业调度。又称高级调度，指内存与辅存之间的调度；</li><li>内存调度。又称中级调度，其作用是提高内存利用率与系统吞吐量，将暂时不能运行的进程调至外存等待，把此时的进程状态称为挂起态。</li><li>低级调度。又称进程调度，指分配处理机资源。<br /><img src="https://n1000g.github.io/post-images/1639685424450.png" alt="多级调度示意图" /></li></ul><h3 id="22-处理机调度实现机制"><a class="markdownIt-Anchor" href="#22-处理机调度实现机制"></a> 2.2 处理机调度实现机制</h3><p>作业调度即创建和销毁进程，核心问题是内存分配，其实现机制主要在第三章内存管理讨论；中级调度涉及内存空间管理的兑换技术或虚拟存储技术，也是内存管理的主要功能；进程调度是 OS 中必不可少的一种调度，也是对系统性能影响最大的一种处理机调度，这里只讨论进程调度的实现方式和具体机制。</p><h4 id="221-进程调度的任务"><a class="markdownIt-Anchor" href="#221-进程调度的任务"></a> 2.2.1 进程调度的任务</h4><p>进程调度的任务主要有三：</p><ul><li>保护处理机的现场信息；</li><li>按某种算法选取进程；</li><li>分配处理机资源给进程，装入 PCB 中处理机现场信息到各寄存器，使之从上次断点处恢复运行。</li></ul><h4 id="222-进程调度机制"><a class="markdownIt-Anchor" href="#222-进程调度机制"></a> 2.2.2 进程调度机制</h4><p>从进程调度的任务分析来看，进程调度机制中应当有如下三个基本部分：</p><ul><li>排队器，负责将每个就绪状态的进程插入就绪队列；</li><li>分派器，负责把进程调度程序所选定的进程从就绪队列中取出；</li><li>上下文切换器，处理机切换时候有两对上下文切换操作，即 ① 当前进程进程↔分派程序和 ② 分派程序↔新进程。这个过程要执行大量 load 和 store 等指令，一次上下文切换执行近千条指令，及其耗时。一般多使用硬件机制（加寄存器）加速这个过程。<br /><img src="https://n1000g.github.io/post-images/1639687579233.png" alt="进程调度机制" /></li></ul><h4 id="223-进程调度方式"><a class="markdownIt-Anchor" href="#223-进程调度方式"></a> 2.2.3 进程调度方式</h4><p>进程调度有非抢占式与抢占式两种调度方式</p><ul><li>非抢占式方式（Nonpreemptive Mode）。一旦处理机资源分配给某个进程，不会因为时钟中断或其他原因抢占其处理机，直到完成或被阻塞；</li><li>抢占式方式（Preemptive Mode）。允许调度程序根据某种原则抢占当前执行进程的处理机资源。这里的某种原则包括 ① 优先权原则、② 短作业优先原则和 ③ 时间片原则。</li></ul><h3 id="23-调度算法"><a class="markdownIt-Anchor" href="#23-调度算法"></a> 2.3 调度算法</h3><h4 id="232-选择调度算法的若干准则"><a class="markdownIt-Anchor" href="#232-选择调度算法的若干准则"></a> 2.3.2 选择调度算法的若干准则</h4><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑这些特性。为了比较不同处理机调度算法的性能，人民提出了若干评价准则：</p><ul><li>CPU 利用率；</li><li>系统吞吐量：单位时间 CPU 完成作业的数量。显然短作业越多系统吞吐量越大；</li><li>周转时间（从作业被提交给系统开始，到作业完成为止的这段时间间隔）：作业完成时间 - 作业提交时间<ul><li>带权周转时间：周转时间 / 实际运行时间</li><li>平均周转时间：系统中多个进程的周转时间的平均值</li><li>平均带权周转时间</li></ul></li><li>等待时间：进程处于等待状态的时间总和；</li><li>响应时间：用户提交请求到系统首次产生响应所用的时间</li></ul><h4 id="232-典型的调度算法"><a class="markdownIt-Anchor" href="#232-典型的调度算法"></a> 2.3.2 典型的调度算法</h4><ul><li>非抢占式的先来先服务（First Come First Severd, FCFS）算法</li><li>最短作业优先（Shortest Job First, SJF）算法</li><li>优先级调度算法<ul><li>抢占式优先级调度算法</li><li>非抢占式优先级调度算法</li><li>静态优先级调度算法</li><li>动态优先级调度算法</li></ul></li><li>高响应比优先调度算法<ul><li>响应比 R<sub>p</sub> = (等待时间 + 要求服务时间) / 要求服务时间</li></ul></li><li>时间片轮转调度算法</li><li>多级反馈队列调度算法<ul><li>设置多个优先级、时间片大小不同的就绪队列</li><li>抢占式方式</li></ul></li></ul><h2 id="3-死锁及处理方法"><a class="markdownIt-Anchor" href="#3-死锁及处理方法"></a> 3 死锁及处理方法</h2><p>死锁（Deadlock）指多道程序系统中并发执行的多个进程因争夺资源而造成一种若无外力则有关进程都将永远不能向前推进的僵持状态。</p><h3 id="31-死锁产生的原因"><a class="markdownIt-Anchor" href="#31-死锁产生的原因"></a> 3.1 死锁产生的原因</h3><p>死锁产生的原因有：</p><ol><li>对不可剥夺资源的竞争</li><li>非法的进程推进顺序</li><li>死锁产生的四个必要条件<ol><li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</li></ol></li></ol><h3 id="32-死锁的处理策略"><a class="markdownIt-Anchor" href="#32-死锁的处理策略"></a> 3.2 死锁的处理策略</h3><p>死锁的处理可从如下四个角度分析：</p><ol><li>预防死锁。即破坏产生死锁的必要条件</li><li>避免死锁。资源分配时利用某种算法防止系统进入不安全状态</li><li>检测死锁。动态检测系统中死锁的发生，定位相关进程和相关资源</li><li>解除死锁。检测到死锁发生后撤销或挂起某进程以回收资源和再分配</li></ol><h4 id="321-死锁的预防策略"><a class="markdownIt-Anchor" href="#321-死锁的预防策略"></a> 3.2.1 死锁的预防策略</h4><p>预防死锁指破坏死锁产生的必要条件即“互斥”条件、“不可剥夺”条件、“请求和保持”条件和“循环等待”条件。<br />“互斥”条件作为资源的固有属性，无法破坏；<br />破坏“请求和保持”条件，即在进程运行前就分配全部需要资源，显然不合理；<br />破坏“不可剥夺”条件，即进程请求某个资源得不到响应是释放已得到的资源，结果是系统效率极大降低；<br />破坏“循环等待”条件，即位资源按类型线性排列，让进程的资源请求严格按这个次序，使系统扩展性变差且有资源浪费的可能。</p><h4 id="322-死锁的检测与解除"><a class="markdownIt-Anchor" href="#322-死锁的检测与解除"></a> 3.2.2 死锁的检测与解除</h4><h5 id="3221-资源分配图"><a class="markdownIt-Anchor" href="#3221-资源分配图"></a> 3.2.2.1 资源分配图</h5><p>用资源分配图描述系统死锁。如图，P 指进程，R 指资源，P 指向 R 的弧称请求边，R 指向 P 的弧称分配边。<br />下图表示 P1 进程分配到了两个 R1 资源，且正在申请一个 R2 资源；P2 进程分配到了一个 R1 资源和一个 R2 资源且正在申请一个 R1 资源：<br /><img src="https://n1000g.github.io/post-images/1639696366105.png" alt="资源分配图" /></p><h5 id="3222-死锁定理"><a class="markdownIt-Anchor" href="#3222-死锁定理"></a> 3.2.2.2 死锁定理</h5><p>系统状态 S 为死锁当且仅当该状态下的资源分配图不可完全化简。</p><h5 id="3221-死锁解除"><a class="markdownIt-Anchor" href="#3221-死锁解除"></a> 3.2.2.1 死锁解除</h5><p>解除死锁的方法有：</p><ol><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li><li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol><h4 id="324-死锁的避免策略和银行家算法"><a class="markdownIt-Anchor" href="#324-死锁的避免策略和银行家算法"></a> 3.2.4 死锁的避免策略和银行家算法</h4><p>死锁避免的基本思想是：运行进程动态地申请资源，但系统在进行资源分配前要进行安全性检查，当且仅当此次分配不会导致系统陷入不安全状态才分配，否则拒绝。</p><h5 id="3221-系统的安全状态"><a class="markdownIt-Anchor" href="#3221-系统的安全状态"></a> 3.2.2.1 系统的安全状态</h5><p>所谓安全状态指系统可按某个进程序列 &lt;P1, P2, P3, P4&gt; 来为进程分配资源所需资源，直至每个进程对资源的最大需求使每个进程都能顺利完成。例：</p><p>某系统中有总计 12 个磁带机资源，当前可用资源量为 3 ，相关进程和资源分配情况如下表：</p><table><thead><tr><th>进程</th><th>需求</th><th>已分配（尚需）</th></tr></thead><tbody><tr><td>P1</td><td>10</td><td>5（5）</td></tr><tr><td>P2</td><td>4</td><td>2（2）</td></tr><tr><td>P3</td><td>9</td><td>2（7）</td></tr></tbody></table><p>则对 T0 时刻，系统中存在安全分配序列 &lt;P2, P1, P3&gt;；<br />若 T0 时刻当前资源可用量为 2，系统找不到一个安全分配序列，称系统处于不安全状态。</p><p>不安全分配状态不一定发生死锁。</p><h5 id="3222-银行家算法"><a class="markdownIt-Anchor" href="#3222-银行家算法"></a> 3.2.2.2 银行家算法</h5><p>银行家算法是最著名的死锁避免算法。<br />银行家算法的数据结构描述：</p><ul><li>可用资源向量 Available</li><li>最大需求矩阵 Max</li><li>分配矩阵 Allocation</li><li>需求矩阵 Need</li><li>请求向量 Request</li></ul><p>银行家算法描述：<br /><img src="https://n1000g.github.io/post-images/1639699328472.png" alt="银行家算法" /></p><p>安全性检测算法描述：<br /><img src="https://n1000g.github.io/post-images/1639699353822.png" alt="安全性检查" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OS 基础课笔记】一、操作系统引论</title>
    <link href="/2021/12/13/f-vIjJNtK/"/>
    <url>/2021/12/13/f-vIjJNtK/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-操作系统概述"><a class="markdownIt-Anchor" href="#1-操作系统概述"></a> 1. 操作系统概述</h1><h2 id="11操作系统的概念和特征"><a class="markdownIt-Anchor" href="#11操作系统的概念和特征"></a> 1.1操作系统的概念和特征</h2><p>计算机系统的由软硬件共同组成，其中软件又可划分为应用软件和系统软件，操作系统（Operating System，OS）是配置在计算机硬件社上的第一层软件是对硬件系统的首次扩充。管理下层硬件设备，提高设备利用效率，并为上层用户程序提供方便的接口以操作硬件设备完成目标功能即是操作系统的主要功能。</p><p>操作系统的基本特征包括并发、共享、虚拟和异步。</p><ul><li>并发（Concurrence）指同一时间间隔内处理和调度多个程序的能力，主要通过分时得以实现；</li><li>共享（Sharing）指系统中资源可供多个并发执行的进程共享使用，包括互斥共享方式和同时访问方式；</li><li>虚拟（Virtual）指把一个物理上的实体抽象为若干个逻辑上的对应物，虚拟技术包括时分复用技术（如处理器的分时）和空分复用技术（如虚拟存储技术）；</li><li>异步（Asynchronism）指 OS 要保证多个并发执行的进程在同一个环境下多次运行后能获得相同的结果。</li></ul><h2 id="12-操作系统的目标和作用"><a class="markdownIt-Anchor" href="#12-操作系统的目标和作用"></a> 1.2 操作系统的目标和作用</h2><p>操作系统的设计目标包括<strong>方便性</strong>、<strong>有效性</strong>、<strong>可扩充性</strong>和<strong>开放性</strong>。</p><ul><li>方便性即提供用户接口，使计算机更方便使用；</li><li>有效性即有效管理和分配软硬件资源以及合理组织计算机工作流程，以改善资源利用率提高系统吞吐量；</li><li>可扩充性是面向未来的，OS 应当适应计算机硬件和体系架构的迅猛发展及其对应的更高的功能和性能要求；</li><li>开放性指适应不同厂家与不同类型的计算机及其设备的网络化集成和协同工作，实现应用程序的可移植性和互操作性；</li></ul><p>操作系统在计算机系统中所起的作用，可从用户、资源管理和资源抽象等角度分析讨论。</p><ul><li>OS 是用户与计算机硬件系统之间的接口，包括面向一般用户的命令式、图形化接口和面向应用程序的<a href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">系统调用</a>接口；</li><li>OS 是系统资源的管理者，管理对象包括处理器、存储器、各类外围设备以及其信息（数据和软件），管理操作例如资源的分配回收、访问操作、共享保护等；</li><li>OS 实现了对计算机资源的抽象，例如为了方便用户使用 I/O 设备，人们在裸机上铺设一层 I/O 设备管理软件，隐藏具体细节并向用户提供一个对硬件设备操作的抽象模型，用户无需了解硬件物理接口等细节便可用该模型提供的抽象接口使用计算机硬件资源。同理，为了方便用户使用文件系统，可在第一层软件上再覆盖一层用于文件管理的软件，以此类推。由此可知，OS 是铺设在计算机硬件上的多层软件的集合。</li></ul><h1 id="2-操作系统层次模型"><a class="markdownIt-Anchor" href="#2-操作系统层次模型"></a> 2. 操作系统层次模型</h1><p>笼统地说，操作系统层次模型分为三层，自底向上分别是操作系统对象、操作和管理有关对象的软件集合、用户接口：<br /><img src="https://n1000g.github.io/post-images/1639348511445.png" alt="OS 层次模型 1" /><br />对这个层次模型以 Linux 或 Unix 系统为例进行细化。由下至上，操作系统内核（Kernel）通过读写硬件接口实现对硬件资源的管理，然后应用程序或命令解释程序（外壳 Shell）通过内核提供的系统调用程序实现用户功能：<br /><img src="https://n1000g.github.io/post-images/1639348723935.png" alt="OS 层次模型 2" /></p><h1 id="3-操作系统接口分类和组成"><a class="markdownIt-Anchor" href="#3-操作系统接口分类和组成"></a> 3. 操作系统接口分类和组成</h1><p>用户接口是系统和用户之间进行交互和信息交换的媒介，方便用户使用和管理计算机系统资源，基于接口表现形式可分为用户交互接口和用户程序接口，前者包括脱机/联机命令接口和图形化用户接口方便一般用户直接使用系统资源，后者方便用户程序访问系统资源，由一组系统调用组成。<br /><img src="https://n1000g.github.io/post-images/1639511501081.jpg" alt="用户接口分类" /></p><h2 id="31-命令接口"><a class="markdownIt-Anchor" href="#31-命令接口"></a> 3.1 命令接口</h2><p>按照作业控制方式的不同，可分为联机命令接口（交互式）和脱机命令接口（批处理），由命令解释程序（shell、cmd 等）控制执行。</p><blockquote><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></p></blockquote><h2 id="32-图形用户接口gui"><a class="markdownIt-Anchor" href="#32-图形用户接口gui"></a> 3.2 图形用户接口（GUI）</h2><p>现代主流操作系统一般都提供 GUI，方便用户使用，以 Windows 为例，系统初始化后 OS 为终端用户生成一个名为 explorer.exe 的进程，它允许一个巨头窗口界面的命令解释程序，即所谓“桌面”。</p><h2 id="33-程序接口"><a class="markdownIt-Anchor" href="#33-程序接口"></a> 3.3 程序接口</h2><p>程序接口是 OS 专门为用户程序设置的，供程序员编程使用，也是用户程序获取 OS 服务的唯一途径。它由一组系统调用（system call）组成。系统调用不仅可供所有应用程序使用，也可供 OS 自身使用，每个操作系统中通常有几十上百条系统调用，每条系统调用都是一个完成特定功能的子程序。</p><h3 id="331-系统调用的基本概念"><a class="markdownIt-Anchor" href="#331-系统调用的基本概念"></a> 3.3.1 系统调用的基本概念</h3><p>大多数计算机系统将 CPU 执行状态分为<strong>目态</strong>（核心态）与<strong>管态</strong>（用户态），CPU 的状态属于程序状态字 PSW 的一位，即系统模式（0）和用户模式（1），CPU 交替执行操作系统程序和用户程序。相应地，现代多数 OS 将 CPU 的指令集分为特权指令和非特权指令两类。前者指在系统态下运行的指令，为外设和内存的访问不受限制；后者是在用户态运行的指令，不能对系统硬件和软件直接访问，对内存的访问也限制在用户空间。</p><p>OS 提供系统调用的目的显而易见，即为用户程序提供调用 OS 内核中相关过程的手段，以获取 OS 内核的系统服务。系统调用本质是应用程序请求 OS 内核完成某个功能时的一种过程调用。</p><p>系统调用区别于一般过程调用的显著特征：</p><ul><li>调用程序运行在管态，被调用程序运行在目态；</li><li>涉及系统状态（CPU 状态）的转换；</li><li>返回问题，调用过程结束后不一定返回被调用过程；</li><li>嵌套调用，一般 OS 要设置最大嵌套深度。</li></ul><h3 id="332-系统调用的分类"><a class="markdownIt-Anchor" href="#332-系统调用的分类"></a> 3.3.2 系统调用的分类</h3><p>一般 OS 的系统调用可分为如下几大类：</p><ul><li>进程控制类<ul><li>进程创建、结束、等待子进程结束</li><li>进程属性设置和获取</li><li>执行一个文件</li></ul></li><li>文件操纵类<ul><li>文件创建、打开、关闭、读写等</li></ul></li><li>进程通信类<ul><li>连接的打开关闭、消息的发送接收等</li></ul></li><li>系统信息的维护<ul><li>时间的设置与获取等</li></ul></li></ul><h3 id="333-系统调用的实现机理"><a class="markdownIt-Anchor" href="#333-系统调用的实现机理"></a> 3.3.3 系统调用的实现机理</h3><p>系统调用是通过中断机制实现的，并且一个操作系统所有的系统调用都通过一个中断入口实现。在 Windows 操作系统中是 <code>int 0x21</code> 号中断，Linux 系统中是 <code>int 0x80</code> 号中断。与其他中断实现机制类似，以下是有关系统调用实现机理的数据结构和详细过程。</p><p>涉及的两个数据结构：</p><ul><li>中断向量表（interrupt vector table，IVT）——中断源的识别标志，提供中断类型号到中断处理程序的映射；</li><li>系统调用表（sys_call_table）——系统调用号到对应的系统过程映射。</li></ul><p>实现流程（以 Linux 为例）：</p><ol><li>用户进程形成一个系统调用号（送入 EAX 寄存器）和参数（送入参数表），执行系统调用命令并触发 <code>int 0x80</code> 号中断；</li><li>中断总控模块处理 128 号中断，跳到它的中断处理程序（即系统调用总控模块）；<ol><li>切换处理机状态（核心态 → 用户态）；</li><li>由硬件和内核程序进行系统调用的一般性处理，即保护 CPU 现场，保存用户定义的参数；</li></ol></li><li>终端总控模块查系统调用表并转到对应的系统调用处理子程序；</li><li>恢复 CPU 现场返回被中断进程或设置新的 CPU 现场转入新进程。</li></ol><blockquote><p><strong>外中断与内中断</strong>——中断也称外中断、硬中断，由来自 CPU 执行指令以外的发生事件造成，通常来自外设请求，中断号由中断控制器提供；内中断也称异常、陷入、软中断，源自 CPU 指令内部事件如缺页指令、非法操作码、地址越界、Linux 1、2、3、128 号中断等，中断号由指令直接指出，无需使用中断控制器。</p></blockquote><h2 id="34-linux-系统调用"><a class="markdownIt-Anchor" href="#34-linux-系统调用"></a> 3.4 Linux 系统调用</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1492374">Linux syscall过程分析（万字长文）</a><br /><a href="https://docs.huihoo.com/joyfire.net/6-1.html#I452">https://docs.huihoo.com/joyfire.net/6-1.html#I452</a></p></blockquote><h1 id="4-操作系统的发展与演化"><a class="markdownIt-Anchor" href="#4-操作系统的发展与演化"></a> 4. 操作系统的发展与演化</h1><p><img src="https://n1000g.github.io/post-images/1639520072572.jpg" alt="OS 的发展与演化" /></p><ul><li>批处理系统——作业先进入磁盘再调入进内存<ul><li>单道批处理系统——把一批作业脱机方式输入磁带上，在所系统配置的监督程序控制下依次连续处理</li><li>多道批处理系统——用作业调度算法分配资源，具有多道性、无序性、调度性</li></ul></li><li>分时系统——一台主机、多个终端、多个用户同时以交互方式使用、作业直接进入内存、按时间片轮转策略分配处理机，具有多路性、独立性、及时性和交互性</li><li>实时系统——及时响应外部事件请求并能控制所有事实任务协调一致地运行，相对分时系统，系统高度可靠</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> @Import vs @ComponentScan</title>
    <link href="/2021/07/26/WFejoTCZs/"/>
    <url>/2021/07/26/WFejoTCZs/</url>
    
    <content type="html"><![CDATA[<p>译自 <a href="https://www.baeldung.com/spring-import-annotation">baeldung</a><br />本文将系统介绍 Spring 中用于注册 Bean 对象的两个重要注解 <code>@Import</code> 和 <code>@ComponentScan</code> 的联系与区别，以及它们各自的适用场景。</p><span id="more"></span><h2 id="联系"><a class="markdownIt-Anchor" href="#联系"></a> 联系</h2><p>两者都可以接收任何 <code>@Component</code> 或 <code>@Configuration</code> 注解的类（Bean 和配置类）</p><p>下面是使用 <code>@Import</code> 注册 Bean 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(Bug.class)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BugConfig</span> </span>&#123;<br>&#125;<br><br><span class="hljs-meta">@Component(value = &quot;bug&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bug</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="概念上的区别subconceptual-differencessub"><a class="markdownIt-Anchor" href="#概念上的区别subconceptual-differencessub"></a> 概念上的区别<sub>Conceptual Differences</sub></h2><p>简单地说，我们可以用这两个注释得到相同的结果。那么，它们之间有什么区别？</p><p>要回答这个问题，让我们记住 Spring 通常提倡<strong>约定高于配置</strong>的方法。</p><p>与我们的注释进行类比，<code>@ComponentScan</code> 更像是约定，而 <code>@Import</code> 更像是配置。</p><h2 id="实际应用中真正发生了什么"><a class="markdownIt-Anchor" href="#实际应用中真正发生了什么"></a> 实际应用中真正发生了什么</h2><p>通常，我们在根包中使用 <code>@ComponentScan</code> 启动应用程序，这样它就可以为我们找到所有组件。正如 Spring Boot 中 <code>@SpringBootApplication</code> 已经包含了 <code>@ComponentScan</code>。这显示了约定的力量。<br />现在，让我们假设我们的应用程序扩展了很多。现在我们需要处理来自所有不同地方的 bean，比如组件、不同的包结构，以及我们自己和第三方构建的模块。<br />在这种情况下，将所有内容添加到上下文可能会引发关于使用哪个bean的冲突。除此之外，我们的启动时间可能会比较慢。另一方面，我们也不想为每个新组件都写一个 <code>@Import</code>，因为这样做会适得其反。<br />以我们的动物为例。我们确实可以在上下文声明中隐藏导入，但是我们仍然需要记住每个 Config 类的 <code>@Import</code>。</p><h2 id="协同使用两者"><a class="markdownIt-Anchor" href="#协同使用两者"></a> 协同使用两者</h2><p>我们也可以以兼顾两者为目标。试想，我们有一个只包含 animals 的包（或组件或模块等等）。</p><p>这个包上有一个 <code>@ComponentScan</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.importannotation.animal;<br><br><span class="hljs-comment">// imports...</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimalScanConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>和一个 <code>@Import</code> 注解用于控制我们要添加到上下文的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.importannotation.zoo;<br><br><span class="hljs-comment">// imports...</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(AnimalScanConfiguration.class)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZooApplication</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，添加到动物包中的任何新 bean 都将由上下文自动找到。我们仍然可以明确地控制我们所使用的构型。</p><h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2><p>*<strong>@Import* is very</strong> <strong>similar to @*ComponentScan*</strong>, except for the fact that <strong>@*Import* has an explicit approach while @*ComponentScan* uses an implicit one</strong>.</p><p><a href="https://github.com/eugenp/tutorials/tree/master/spring-core-4">示例项目地址</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JPA Criteria Queries</title>
    <link href="/2021/07/26/hfZT72Yi5/"/>
    <url>/2021/07/26/hfZT72Yi5/</url>
    
    <content type="html"><![CDATA[<p>摘译自 <a href="https://www.baeldung.com/hibernate-criteria-queries#Criteria">baeldung</a><br />条件查询（Criteria Query）是 JPA 的一个重要特性。自 Hibernate 5.2 以后，Hibernate Criteria API 被官方声明为弃用方法，转而推荐使用 JPA Criteria API。本教程将围绕如何使用 Hibernate 和 JPA 来构建 Criteria Queries 展开讨论。</p><span id="more"></span><h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1. 概述</h2><p>在本教程中，我们将讨论一个非常有用的 JPA 特性——条件查询。</p><p>它不仅使我们能够在不使用纯 SQL 的情况下编写查询，而且还为查询提供了一些面向对象的控制，这也即 Hibernate 的主要特性之一。Criteria API 允许我们以编程的方式构建一个应用不同的过滤规则和逻辑条件的 Criteria 查询对象。</p><p>从Hibernate 5.2开始，Hibernate Criteria API 就被弃用了，新的开发集中在 JPA Criteria API 上。我们将探索如何使用 Hibernate 和 JPA 来构建 Criteria Queries。</p><h2 id="2-maven-依赖"><a class="markdownIt-Anchor" href="#2-maven-依赖"></a> 2. Maven 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.2.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-简单示例"><a class="markdownIt-Anchor" href="#3-简单示例"></a> 3. 简单示例</h2><p>我们以如何从数据库中获取特定类（Item）的所有实例为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer itemId;<br>    <span class="hljs-keyword">private</span> String itemName;<br>    <span class="hljs-keyword">private</span> String itemDescription;<br>    <span class="hljs-keyword">private</span> Integer itemPrice;<br><br>   <span class="hljs-comment">// standard setters and getters</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它的 Criteria Query 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span> </span>&#123;<br>    Session session = HibernateUtil.getHibernateSession();<br>    CriteriaBuilder cb = session.getCriteriaBuilder();<br>    CriteriaQuery&lt;Item&gt; cr = cb.createQuery(Item.class);<br>    Root&lt;Item&gt; root = cr.from(Item.class);<br>    cr.select(root);<br>    Query&lt;Item&gt; query = session.createQuery(cr);<br>    <span class="hljs-keyword">return</span> query.getResultList();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的查询是如何获取所有项的简单演示。让我们一步一步来看看我们做了什么：</p><ol><li>从 SessionFactory 对象创建一个 Session 实例</li><li>通过调用 getCriteriaBuilder() 方法创建一个 CriteriaBuilder 实例</li><li>通过调用 CriteriaBuilder 的 createQuery()方法创建一个 CriteriaQuery 实例</li><li>通过调用 Session 的 createQuery() 方法创建 Query 的实例</li><li>调用查询对象的getResultList()方法，它将给出结果</li></ol><pre><code class=" mermaid">graph LR;    SessionFactory --&gt; Session;    Session --&gt; CriteriaBuilder;    subgraph build criteriaQuery;    CriteriaBuilder --Item.class--&gt; CriteriaQuery;    Root --Item.class--&gt; CriteriaQuery;    end;    CriteriaQuery --&gt; Query;    Query --&gt; results;</code></pre><p>现在我们已经介绍了基础知识，让我们继续了解条件查询的一些特性:</p><h3 id="31-expressions"><a class="markdownIt-Anchor" href="#31-expressions"></a> 3.1 Expressions</h3><p>CriteriaBuilder 可用于基于特定条件限制查询结果：</p><h4 id="where-子句"><a class="markdownIt-Anchor" href="#where-子句"></a> Where 子句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// where itemPrice &gt; 1000</span><br>cr.select(root).where(cb.gt(root.get(<span class="hljs-string">&quot;itemPrice&quot;</span>), <span class="hljs-number">1000</span>));<br><span class="hljs-comment">// where itemPrice &lt; 1000</span><br>cr.select(root).where(cb.lt(root.get(<span class="hljs-string">&quot;itemPrice&quot;</span>), <span class="hljs-number">1000</span>));<br><span class="hljs-comment">// Items having itemName contain Chair</span><br>cr.select(root).where(cb.like(root.get(<span class="hljs-string">&quot;itemName&quot;</span>), <span class="hljs-string">&quot;%chair%&quot;</span>));<br><span class="hljs-comment">// To check if the given property is not null:</span><br>cr.select(root).where(cb.isNotNull(root.get(<span class="hljs-string">&quot;itemDescription&quot;</span>)));<br></code></pre></td></tr></table></figure><h4 id="表达式链"><a class="markdownIt-Anchor" href="#表达式链"></a> 表达式链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate[] predicates = <span class="hljs-keyword">new</span> Predicate[<span class="hljs-number">2</span>];<br>predicates[<span class="hljs-number">0</span>] = cb.isNull(root.get(<span class="hljs-string">&quot;itemDescription&quot;</span>));<br>predicates[<span class="hljs-number">1</span>] = cb.like(root.get(<span class="hljs-string">&quot;itemName&quot;</span>), <span class="hljs-string">&quot;chair%&quot;</span>);<br>cr.select(root).where(predicates);<br><span class="hljs-comment">// or</span><br>cr.select(root).where(cb.or(predicates[<span class="hljs-number">0</span>], predicates[<span class="hljs-number">1</span>]));<br><span class="hljs-comment">// and</span><br>cr.select(root).where(cb.and(predicates[<span class="hljs-number">0</span>], predicates[<span class="hljs-number">1</span>]));<br></code></pre></td></tr></table></figure><h3 id="32-sorting"><a class="markdownIt-Anchor" href="#32-sorting"></a> 3.2 Sorting</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">cr.orderBy(<br>  cb.asc(root.get(<span class="hljs-string">&quot;itemName&quot;</span>)), <br>  cb.desc(root.get(<span class="hljs-string">&quot;itemPrice&quot;</span>)));<br></code></pre></td></tr></table></figure><h3 id="33-projections-aggregates-and-grouping-functions"><a class="markdownIt-Anchor" href="#33-projections-aggregates-and-grouping-functions"></a> 3.3 Projections, Aggregates, and Grouping Functions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">cr.select(cb.count(root));<br>cr.select(cb.avg(root.get(<span class="hljs-string">&quot;itemPrice&quot;</span>)));<br></code></pre></td></tr></table></figure><h3 id="34-criteriaupdate"><a class="markdownIt-Anchor" href="#34-criteriaupdate"></a> 3.4 CriteriaUpdate</h3><p>CriteriaUpdate 有一个 set() 方法，可以用来为数据库记录提供新值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CriteriaUpdate&lt;Item&gt; criteriaUpdate = cb.createCriteriaUpdate(Item.class);Root&lt;Item&gt; root = criteriaUpdate.from(Item.class);criteriaUpdate.set(<span class="hljs-string">&quot;itemPrice&quot;</span>, newPrice);criteriaUpdate.where(cb.equal(root.get(<span class="hljs-string">&quot;itemPrice&quot;</span>), oldPrice));Transaction transaction = session.beginTransaction();session.createQuery(criteriaUpdate).executeUpdate();transaction.commit();<br></code></pre></td></tr></table></figure><h3 id="35-criteriadelete"><a class="markdownIt-Anchor" href="#35-criteriadelete"></a> 3.5 CriteriaDelete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CriteriaDelete&lt;Item&gt; criteriaDelete = cb.createCriteriaDelete(Item.class);Root&lt;Item&gt; root = criteriaDelete.from(Item.class);criteriaDelete.where(cb.greaterThan(root.get(<span class="hljs-string">&quot;itemPrice&quot;</span>), targetPrice));Transaction transaction = session.beginTransaction();session.createQuery(criteriaDelete).executeUpdate();transaction.commit();<br></code></pre></td></tr></table></figure><h2 id="相对-hql-的优势"><a class="markdownIt-Anchor" href="#相对-hql-的优势"></a> 相对 HQL 的优势</h2><ul><li><strong>Object Oriented</strong></li><li>flexible</li><li>type-safety</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Hibernate</tag>
      
      <tag>JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 数据处理脚本的通用设计</title>
    <link href="/2021/07/20/zIn7XAv_S/"/>
    <url>/2021/07/20/zIn7XAv_S/</url>
    
    <content type="html"><![CDATA[<h2 id="常用库"><a class="markdownIt-Anchor" href="#常用库"></a> 常用库</h2><h3 id="pymysql"><a class="markdownIt-Anchor" href="#pymysql"></a> <a href="https://pymysql.readthedocs.io/en/latest/">PyMySQL</a></h3><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-comment"># 连接</span><br>connection = pymysql.connect(host, user, password, db, port, charset, <br>cursorclass=pymysql.cursors.DictCursor)<br>cursor = connection.cursor()<br><span class="hljs-comment"># 处理</span><br>cursor.execute(sql)<br>res = cursor.fetchall()  <span class="hljs-comment"># 查询语句需要 fetch 后 才能执行下一次查询</span><br><span class="hljs-comment"># connection.commit()  # 修改语句需要 commit  后 才能执行下一次查询</span><br><span class="hljs-comment"># 关闭</span><br>cursor.close()<br>connection.close()<br></code></pre></td></tr></table></figure><h3 id="openpyxl"><a class="markdownIt-Anchor" href="#openpyxl"></a> <a href="https://openpyxl.readthedocs.io/en/stable/">openpyxl</a></h3><p><strong>写</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<br><br>workbook = Workbook()<br>sheet = workbook.active<br>sheet[<span class="hljs-string">&#x27;A1&#x27;</span>] = <span class="hljs-number">42</span><br>sheet.append([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>sheet[<span class="hljs-string">&#x27;A2&#x27;</span>] = datetime.datetime.now()<br>workbook.save(<span class="hljs-string">&quot;sample.xlsx&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>读</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook<br><br>workbook = load_workbook(<span class="hljs-string">&quot;excelfile.xlsx&quot;</span>)<br>sheets = workbook.sheetnames<br>sheet = workbook[sheets[<span class="hljs-number">0</span>]]  <span class="hljs-comment"># sheet = workbook.active</span><br><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet.rows:<br>    val = row[<span class="hljs-number">0</span>].value<br>    <span class="hljs-built_in">print</span>(val)<br></code></pre></td></tr></table></figure><h2 id="几个较常用的-sql-写法"><a class="markdownIt-Anchor" href="#几个较常用的-sql-写法"></a> 几个较常用的 SQL 写法</h2><p>编写代码相对十分耗时且极易出错，复杂度不太高的任务可以用数据库客户端直接解决，总结下一些如按字段讨论、列连接成行的 SQL 写法</p><h3 id="按字段讨论"><a class="markdownIt-Anchor" href="#按字段讨论"></a> 按字段讨论</h3><p>之前业务升级某些数据前端不再展示，运营要统计某机构下学生离校时间，但这个时间在一张表不同字段表示，正常结课的课程用 <code>closed_time</code>，学生删除的用 <code>dropped_time</code>，班级删除的用 <code>delete_time</code>，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;学生id&#x27;</span>, create_time <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;入校时间&#x27;</span>,(<br><span class="hljs-keyword">CASE</span> `status` <br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">40</span> <span class="hljs-keyword">OR</span> <span class="hljs-number">24</span> <span class="hljs-keyword">THEN</span> dropped_time<br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">THEN</span> closed_time <br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">16</span> <span class="hljs-keyword">THEN</span> dropped_time<br><span class="hljs-keyword">END</span><br>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;离校时间&#x27;</span><br><span class="hljs-keyword">FROM</span> class_student <span class="hljs-keyword">WHERE</span> org_id<span class="hljs-operator">=</span>&#123;<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="多列数据连接成行展示"><a class="markdownIt-Anchor" href="#多列数据连接成行展示"></a> 多列数据连接成行展示</h3><p>如下是统计某一机构下每个班级的学生，要求按班级分类</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> org_id, class_id, GROUP_CONCAT(student_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> student_id)<br><span class="hljs-keyword">FROM</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> class_student<br><span class="hljs-keyword">WHERE</span> org_id<span class="hljs-operator">=</span><span class="hljs-number">2619</span><br>) t<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class_id<br></code></pre></td></tr></table></figure><h2 id="按路径获取文件"><a class="markdownIt-Anchor" href="#按路径获取文件"></a> 按路径获取文件</h2><p>由于系统路径分隔符不一致 Windows 下使用正斜杠分割路径如 <code>C:\Users\n8g\Desktop</code>，Linux 下则使用反斜杠分割路径如 <code>~/Documents</code>，于是在涉及读写本地文件需求相关的操作时，就要考虑代码的通用性，一个较不成熟的解决方案是用 python 标准库 os 做路径拼接处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">FILE_FOLDER = os.getcwd()  <span class="hljs-comment"># 当前工作路径</span><br>FILE_NAME = <span class="hljs-string">&quot;file_to_process.abc&quot;</span>  <span class="hljs-comment"># 待处理文件</span><br>fo = <span class="hljs-built_in">open</span>(os.path.join(FILE_FOLDER, FILE_NAME), <span class="hljs-string">&#x27;r&#x27;</span>)<br>...<br></code></pre></td></tr></table></figure><p>多文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">file_name_list = os.listdir(FILE_FOLDER)<br><span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> file_name_list:<br>    file_abs_path = os.path.join(FILE_FOLDER, f_name)<br>    fo = <span class="hljs-built_in">open</span>(file_abs_path)<br>    ...<br>...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
