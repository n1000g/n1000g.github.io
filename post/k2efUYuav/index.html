<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>【OS 基础课笔记】二、进程管理 | n1000g</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://n1000g.github.io/favicon.ico?v=1639699649295">
<link rel="stylesheet" href="https://n1000g.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1. 进程与线程
1.1 进程的定义与特征
在多道程序环境下，允许多个程序并发执行，此时它们失去封闭性，并具有间断性及不可再现性的特征。为此映入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性..." />
    <meta name="keywords" content="Linux,操作系统" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://n1000g.github.io">
        <img src="https://n1000g.github.io/images/avatar.png?v=1639699649295" class="site-logo">
        <h1 class="site-title">n1000g</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://n1000g.github.io" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://n1000g.github.io/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="https://n1000g.github.io/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://n1000g.github.io/extract" class="site-nav">
            摘译
          </a>
        
      
        
          <a href="about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      早日成长为一只老攻城狮
    </div>
    <div class="site-footer">
      <li>© 2021 GitHub, Inc.</li> | <a class="rss" href="https://n1000g.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">【OS 基础课笔记】二、进程管理</h2>
            <div class="post-date">2021-12-13</div>
            
              <div class="feature-container" style="background-image: url('https://n1000g.github.io/post-images/k2efUYuav.png')">
              </div>
            
            <div class="post-content" v-pre>
              <h2 id="1-进程与线程">1. 进程与线程</h2>
<h3 id="11-进程的定义与特征">1.1 进程的定义与特征</h3>
<p>在多道程序环境下，允许多个程序并发执行，此时它们失去封闭性，并具有间断性及不可再现性的特征。为此映入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p>
<p>为使并发的程序能独立运行，必须为止配置一个专门的数据结构，称为进程控制块（Process Control Block，PCB）。操作系统利用 PCB 描述一个进程的基本情况和运行状态，所谓创建进程就是创建一个 PCB。PCB、程序段和数据段三部分共同构成了<strong>进程实体</strong>，也即进程映像。进程是动态的，进程映像是静态的；</p>
<p>由此给出进程的定义——<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p>
<p>并可知进程的主要特征有动态性、并发性、独立性、异步性和结构性。</p>
<h3 id="12-进程控制块process-control-blockpcb">1.2 进程控制块（Process Control Block，PCB）</h3>
<p><strong>PCB 是进程存在的唯一标志</strong>，也是操作系统管理和控制并发执行进程的依据。它常驻内存并存放在操作系统专门开辟的 PCB 区。进程控制块中有如下信息：</p>
<ul>
<li>进程标识符
<ul>
<li>内部 PID、外部 PID</li>
<li>父进程、子进程、用户标识符</li>
</ul>
</li>
<li>处理器状态信息
<ul>
<li>通用寄存器、PC、PSW、用户栈指针寄存器等</li>
</ul>
</li>
<li>进程调度信息
<ul>
<li>进程状态、进程优先级、事件等</li>
</ul>
</li>
<li>进程控制信息
<ul>
<li>程序和数据地址、进程同步通信机制</li>
<li>资源清单、链接指针、进程图</li>
</ul>
</li>
</ul>
<p><strong>Linux 中对 PCB 的描述</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/a1414345/article/details/55550460">Linux中进程控制块（PCB）的task_struct结构描述</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/liexusong/linux-source-code-analyze/blob/master/process-management.md">linux-source-code-analyze/process-management.md</a></p>
</blockquote>
<h3 id="13-进程状态变迁">1.3 进程状态变迁</h3>
<p>进程在其生命周期内由于系统中各个进程之间相互制约关系和系统环境的变换，使得进程状态也在不断变化，通常具有如下五种状态：<br>
<img src="https://n1000g.github.io/post-images/1639525596602.png" alt="进程五态模型" loading="lazy"></p>
<p>进程的五态模型假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的，即七态模型：<br>
<img src="https://n1000g.github.io/post-images/1639525745466.png" alt="进程七态模型" loading="lazy"></p>
<p><strong>Linux 中的进程状态</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/zyboy2000/article/details/4179834">Linux进程状态(ps stat)之R、S、D、T、Z、X</a></p>
</blockquote>
<h3 id="14-进程同步">1.4 进程同步</h3>
<p>为了协调并发执行的进程只键的相互制约关系，引入了进程同步的概念。</p>
<h4 id="141-基本概念">1.4.1 基本概念</h4>
<p><strong>同步和互斥</strong><br>
同步也称直接制约关系，互斥也称间接制约关系。前者例如 A 进程通过单缓冲向 B 进程提供数据，缓冲区空时，B 进程需阻塞等待；后者例如 A、B进程都需要使用系统中仅有的唯一的 I/O 设备 C，C 被分配给 A 时，B 需要阻塞等待。</p>
<p><strong>临界资源和临界区</strong><br>
临界资源指一次仅仅运行一个进程使用的资源，例如打印机等物理设备、共享变量等；<br>
临界区指访问临界资源那段代码，又称临界段。临界区前的检查部分称进入区，临界区后的标志清除部分称退出区。</p>
<pre><code class="language-c">do {
    entry section;
    critical section;
    exit section;
    remainder section;
} while(true)
</code></pre>
<h4 id="142-进程同步准则">1.4.2 进程同步准则</h4>
<p>同步机制应当遵循如下准则：</p>
<ol>
<li>空闲让进——临界区空闲时，当运行一个请求进入临界区的进程立刻进入；</li>
<li>忙则等待——有进程进入临界区，其他试图进入临界区的进程必须等待；</li>
<li>有限等待——对请求访问的进程，需保证能在有限时间内进入临界区；</li>
<li>让权等待——当进程不能进入临界区时，应当释放处理器资源，防止进程忙等待。</li>
</ol>
<h4 id="143-进程同步机制">1.4.3 进程同步机制</h4>
<h5 id="1431-硬件方法">1.4.3.1 硬件方法</h5>
<ol>
<li>关中断——进入锁测试前屏蔽一切中断请求，不进行进程或线程切换；</li>
<li>Test-and-Set——指令，指令执行期间不允许被中断，获取所访问的临界资源的占用情况；</li>
<li>Swap 指令——同上，硬件逻辑实现</li>
</ol>
<h5 id="1432-软件方法">1.4.3.2 软件方法</h5>
<ol>
<li>
<p>单标志位——设置单标志位 <code>turn</code> 用于指示允许进入临界区的进程编号，两个进程循环进入临界区，一个进程结束另一个进程也无法访问自己的临界区，违反“空闲让进”原则</p>
<pre><code class="language-c">Process0:					    Process1:
	while(turn != 0);			    while(turn != 1);
	critical section;			    criticla section;
	turn = 1;					    turn = 0;
	remainder section;			    remainder section;
</code></pre>
</li>
<li>
<p>双标志位先检查——进入临界区前先检查是否被占用，但可能多个进程同时进入临界区，违反“忙则等待”原则</p>
<pre><code class="language-c">Process0:					    Process1:
	while(flag1);				    while(flag0);
	flag0 = true;				    flag1 = true;
	critical section;			    criticla section;
	flag0 = false;				    flag1 = false;
	remainder section;			    remainder section;
</code></pre>
</li>
<li>
<p>双标志位后检查——算法二先检查占用情况再设置自己占用标志位，算法三则先设置标志位后检查占用情况，避免了同时进入临界区违反“忙则等待“的情况，但出现了”饥饿“的现象，违反”空闲让进“原则</p>
<pre><code class="language-c">Process0:					    Process1:
	flag0 = true;				    flag1 = true;
	while(flag1);				    while(flag0);
	critical section;			    criticla section;
	flag0 = false;				    flag1 = false;
	remainder section;			    remainder section;
</code></pre>
</li>
<li>
<p>Peterson's Algorithm——既设置占用标志位 <code>flag</code> 也设置 <code>turn</code> 标志，利用 <code>flag</code> 解决互斥访问问题，利用 <code>turn</code> 解决”饥饿“现象</p>
<pre><code class="language-c">Process0:					    Process1:
	flag0 = true; turn=1;		    flag1 = true;turn = 0;
	while(flag1 &amp;&amp; turn == 1);	    while(flag0 &amp;&amp; turn == 0);
	critical section;			    criticla section;
	flag0 = false;				    flag1 = false;
	remainder section;			    remainder section;
</code></pre>
</li>
</ol>
<p>以上方案都没有遵守”让权等待“原则。</p>
<h5 id="1433-信号量机制">1.4.3.3 信号量机制</h5>
<p>信号量（Semaphore）机制于 1956 年由圣 Dijkstra 提出，是一种卓有成效的进程同步工具，现已被广泛运用在各类单处理机、多处理机和网络系统中。除了初始化操作外，信号量只能通过两个原子操作 <code>wait()</code> 和 <code>signal()</code>，也称 P 操作和 V 操作。</p>
<ol>
<li>
<p>整型信号量——整型信号量被定义为一个用于表示资源数目的整型量 S，P、V 操作分别定义为</p>
<pre><code class="language-c">wait(S) {
    while(S &lt;= 0);
    S--;
}

signal(S){
    S++;
}
</code></pre>
</li>
<li>
<p>记录型信号量——一个整型的 <code>S-&gt;value</code> 表示资源数目（大于 0）或阻塞队列的长度（小于 0）；进程列表 <code>S-&gt;list</code> 表示阻塞在该信号量上的进程队列；<code>S-&gt;value</code> 等于 1 时，记录型信号量转化为互斥信号量表示一个用于互斥访问的临界资源。</p>
<pre><code class="language-c">/**
 * 记录型信号量的进程阻塞队列
 */
typedef struct process_control_block {
    int pid; // 进程标识符
    struct process_control_block * next; // 队列指针
} process_control_block;

/**
 * semaphore 记录型信号量
 */
typedef struct {
    int value; // 资源数量
    process_control_block * list; // 阻塞队列头
} semaphore;

void wait(semaphore * S) {
    S-&gt;value --;
    if (S-&gt;value &lt; 0) block(S-&gt;list);
}

void signal(semaphore * S) {
    S-&gt;value ++;
    if (S-&gt;value &lt;= 0) wakeup(S-&gt;list);
}
</code></pre>
</li>
<li>
<p>AND 型信号量</p>
</li>
<li>
<p>信号量集机制（Unix）</p>
</li>
</ol>
<h5 id="1434-管程机制">1.4.3.4 管程机制</h5>
<p>信号量机制要求每个要访问临界资源的进程都自备同步操作 P 和 V，这给系统管理带来了极大的麻烦。计算机系统中的各类软硬件资源都可以用数据结构进行抽象描述，即用少量信息表征该资源而忽略内部结构和实现细节。据此，可用共享数据结构抽象地表示系统中的共享资源，并对该共享数据结构实施特定的操作定义为一组过程。管程是由一组数据及定义在这组数据上的对这组数据的操作组成的软件模块。</p>
<p>管程有如下基本特性：</p>
<ol>
<li>局部于管程的数据只能被局部与管程内的过程所访问；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>
<li>每次仅允许一个进程在管程内执行某个内部过程。</li>
</ol>
<p><strong>理解和相关资料</strong></p>
<blockquote>
<p><a href="https://www.zhihu.com/question/30641734">知乎：如何理解管程</a><br>
<a href="https://icecrea-blog.gitbook.io/blog/bing-fa/guan-cheng-mo-xing-yu-deng-dai-tong-zhi-ji-zhi">https://icecrea-blog.gitbook.io/blog/bing-fa/guan-cheng-mo-xing-yu-deng-dai-tong-zhi-ji-zhi</a><br>
<a href="https://segmentfault.com/a/1190000021557492">https://segmentfault.com/a/1190000021557492</a></p>
</blockquote>
<h4 id="144-进程同步经典问题">1.4.4 进程同步经典问题</h4>
<p><a href="https://n1000g.github.io/post/KKnYhVDri/">https://n1000g.github.io/post/KKnYhVDri/</a></p>
<h3 id="15-进程通信">1.5 进程通信</h3>
<p>进程通信指的是进程之间的信息交换。由于进程的互斥与同步也需要在进程间交换一些信息，故也可以把它们归为进程通信，称为低级进程通信。以信号量机制为例，它之所以低级的原因在于：① 效率低；② 通信对用户不透明。要在进程间传送大量数据，应当利用 OS 提供的高级通讯工具。<br>
<img src="https://n1000g.github.io/post-images/1639621745101.png" alt="进程通信模型" loading="lazy"></p>
<h4 id="151-进程通信的类型">1.5.1 进程通信的类型</h4>
<p>高级通信机制可分为四大类：</p>
<ol>
<li>共享存储器系统——基于共享存储结构或共享存储区；</li>
<li>管道（pipe）通信系统——所谓“管道”是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件；</li>
<li>消息传递系统——进程将要传递的数据封装到格式化的“消息”（message）中，利用 OS 提供的通信原语（直接通信方式）或某个共享的中间实体“邮箱”（间接通信方式）进行消息传递；</li>
<li>客户机-服务器系统——当前最主流的通信实现方式，可分为套接字（socket）、远程过程调用（RPC）和远程方法调用三类。</li>
</ol>
<h4 id="152-管道机制">1.5.2 管道机制</h4>
<p>传统的 Unix 系统为进程间的通信提供了管道机制，分为有名管道和无名管道。管道本质上是一个内核缓冲区，Unix 下“一切皆文件”，但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中；无名管道一般使用 fork 函数实现父子进程的通信，命名管道用于没有血缘关系的进程也可以进程间通信；管道面向字节流、自带同步互斥机制、半双工，只能单向通信。<br>
<img src="https://n1000g.github.io/post-images/1639622356041.png" alt="管道模型" loading="lazy"></p>
<h4 id="153-直接消息传递系统">1.5.3 直接消息传递系统</h4>
<p>直接消息传递系统中，发送进程利用 OS 提供消息发送原语，直接把消息发送给目标进程：<code>send(receiver, message);</code>，接收进程利用接收原语 <code>receive(sender, message);</code> 或 <code>receive(id, message);</code> 接收消息。</p>
<p>Unix 系统提供了消息队列的构建（msgget）、操作（msgctl）、发送（msgsnd）、接收（msgrcv）等系统调用。</p>
<h4 id="154-信箱通信间接消息传递系统">1.5.4 信箱通信（间接消息传递系统）</h4>
<p>类似直接消息传递系统，OS 提供邮箱的创建、撤销和消息的发送、接收等原语，信箱被定义为一种共享数据结构，既可以实现实时通信也可以实现延时通信。</p>
<h4 id="155-消息缓冲队列通信机制">1.5.5 消息缓冲队列通信机制</h4>
<p>消息缓冲队列通信机制最先由 Hansan 提出并实现，后来广泛运用于本地进程之间的通信中。它根据”生产者-消费者”原理，利用内存中公用消息缓冲区实现进程之间的信息交换。发送者进程使用 Send 原语将消息直接发送给接收进程，接收进程则利用 Receive 原语接收消息。</p>
<pre><code class="language-c">/**
 * 消息缓冲区——定义消息格式
 */
typedef struct message_buffer {
    int sender;             // 发送进程 PID
    int size;                  // 消息大小（用于向 OS 申请消息缓冲区时）
    char* text;             // 消息正文
    struct message_buffer *next;    //指向下一个消息缓冲区的指针
}

/**
 * 在进程 PCB 中新增的数据项
 */
typedef struct process_control_block {
    ...
    struct message_buffer *mq;      // 消息缓冲队列队首指针
    semaphore mq_mutex;             // 消息缓冲队列互斥信号量
    semaphore mq_resource;            // 消息缓冲队列资源信号量
    ...
}
</code></pre>
<ol>
<li>A 进程调用 Send 原语，申请一个消息缓冲区 buffer，把自身发送区数据拷贝到 buffer 中并挂载到 B 进程的 *mq 上；</li>
<li>B 进程调用 Receive 原语，从自身 *mq 上取下一个 buffer，读出数据到自身接受区，然后释放 buffer。</li>
</ol>
<p>以下是接受原语 Send 和发送原语 Receive 的描述：</p>
<pre><code class="language-c">/**
 * 发送原语（a 为发送区地址）
 */
void send(receiver, a) {
    getbuf(a.size, buffer_i);
    buffer_i.sender = a.sender; buffer_i.size = a.size; copy(a.text, buffer_i.text);
    buffer_i.next = 0;
    P(receiver.mq_mutex);
    insert(&amp;reveiver.mq, buffer_i);             // inqueue
    V(receiver.mq_mutex);
    V(receiver.mq_resource);
}

/**
 * 接收原语（b 为接收区地址）
 */
void receive(b) {
    p = get_cur_process();          // 进程自身 PCB
    P(p.mq_resource);
    P(p.mq_mutex);
    remove(p.mq, buffer_i);                        // dequeue
    V(p.mq_mutex);
    b.sender = buffer_i.sender; b.size = buffer_i.size; copy(buffer_i.text, b.text);
    releasebuf(buffer_i);
}
</code></pre>
<h3 id="16-线程thread和多线程模型">1.6 线程（Thread）和多线程模型</h3>
<p>引入进程是为例更好地使多道程序并发执行，提高系统资源利用率和吞吐量，增加并发程度，但进程并发机制存在一定缺陷如进程切换创建时空开销大，通信效率低等。克服这些缺陷的一个思路是使资源拥有与调度分派这两个进程的基本属性相分离，这就引入了线程。</p>
<p>**线程即”轻量级进程“，是一个基本的 CPU 执行单元，也即 CPU 独立调度的基本单位。**其基本特征除了 ① 是处理机的独立调度单位，可以并发执行外还有 ② 轻型实体，不拥有系统资源、③ 同一个进程下的线程共享进程资源和 ④ 有自己独立的生命周期。</p>
<h4 id="161-线程实现方式">1.6.1 线程实现方式</h4>
<p>线程分为<strong>内核支持线程</strong>（Kernel Supported Thread，KST）和<strong>用户级线程</strong>（User-Level Thread，ULT）。</p>
<ul>
<li>用户级线程中有关线程的实现与管理工作由应用程序完成，与 OS 平台无关。线程切换不涉及内核空间的转换，内核意识不到线程的存在，应用程序可以通过使用编程语言提供的线程库设计成多线程程序。故当某个线程执行一个系统调用时，进程下所有线程一起阻塞。所以在单纯的用户级线程实现方式中，即使是多线程应用也无法利用多处理机的并行优势。</li>
<li>内核级线程中，线程管理的所有工作由内核完成，内核为进程及其内部每个线程设立<em>线程控制块</em>维护上下文信息，应用程序没有进行线程管理的代码，只有一个到内核级线程的编码接口。大多数 OS 都支持内核级线程。相对进程，它只占有很小的数据结构和堆栈，切换快开销小；相对 ULK，多处理机系统下可调度同一个进程多线程并行执行，提高系统效率。</li>
</ul>
<h4 id="162-多线程模型">1.6.2 多线程模型</h4>
<p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的链接方式。即下图所示的一对一模型、一对多模型和多对多模型。<br>
<img src="https://n1000g.github.io/post-images/1639680944096.jpg" alt="多线程模型" loading="lazy"></p>
<ul>
<li>多对一模型，即将用户线程映射到一个内核控制线程（也就是内核里不支持线程），这些线程的管理调度在用户空间实现，仅当用户线程访问内核时才进行映射，每次仅允许一个线程进行映射。Unix 中内核中并不支持线程，可视作采用了这一模型；</li>
<li>一对一模型，下将每个用户级线程映射到一个内核支持线程，内核管理其调度运行，并发性最好，但系统开销巨大，OS 要对内核空间里的最大线程数有限制。Linux、Windows 等系统实现了该模型；</li>
<li>多对多模型，即允许多个用户级线程映射到若干个内核级线程上。综合了前两者的优缺点，但实现极端复杂，是个理论模型，曾由 IBM 主导的 NGPT 采用了多对多的线程模型，不过现在已废弃；</li>
</ul>
<h4 id="163-linux-多线程模型的实现linuxthreads-和-nptl">1.6.3 Linux 多线程模型的实现——LinuxThreads 和 NPTL</h4>
<p>多线程最初是由 LinuxThreads 这个工程带入到 Linux 的，但是 LinuxThreads 并不符合 POSIX 在线程方面的标准。之后的原生 POSIX 线程库（Native POSIX Thread Library，NPTL）比 LinuxThreads 更符合标准，且克服了后者的许多缺陷。</p>
<blockquote>
<p><strong><a href="https://en.wikipedia.org/wiki/POSIX">可移植操作系统接口 POSIX</a></strong> 和 <strong><a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">原生 POSIX 线程库 NPTL</a></strong><br>
<a href="http://cs.uns.edu.ar/~jechaiz/sosd/clases/extras/03-LinuxThreads%20and%20NPTL.pdf">Linux threading models compared: LinuxThreads<br>
and NPTL</a><br>
<a href="https://www.jianshu.com/p/6c507b966ad1">【译】Linux 线程模型比较：LinuxThreads 和 NPTL</a></p>
</blockquote>
<h2 id="2-处理机调度">2. 处理机调度</h2>
<p>调度的实质是资源分配，处理机调度即对处理机这个资源进行分配。处理机调度是多道程序操作系统的基础，也是操作系统设计的核心问题。</p>
<h3 id="21-处理机调度类型与模型">2.1 处理机调度类型与模型</h3>
<p>一个作业从提交到完成往往要经历三级调度。</p>
<ul>
<li>作业调度。又称高级调度，指内存与辅存之间的调度；</li>
<li>内存调度。又称中级调度，其作用是提高内存利用率与系统吞吐量，将暂时不能运行的进程调至外存等待，把此时的进程状态称为挂起态。</li>
<li>低级调度。又称进程调度，指分配处理机资源。<br>
<img src="https://n1000g.github.io/post-images/1639685424450.png" alt="多级调度示意图" loading="lazy"></li>
</ul>
<h3 id="22-处理机调度实现机制">2.2 处理机调度实现机制</h3>
<p>作业调度即创建和销毁进程，核心问题是内存分配，其实现机制主要在第三章内存管理讨论；中级调度涉及内存空间管理的兑换技术或虚拟存储技术，也是内存管理的主要功能；进程调度是 OS 中必不可少的一种调度，也是对系统性能影响最大的一种处理机调度，这里只讨论进程调度的实现方式和具体机制。</p>
<h4 id="221-进程调度的任务">2.2.1 进程调度的任务</h4>
<p>进程调度的任务主要有三：</p>
<ul>
<li>保护处理机的现场信息；</li>
<li>按某种算法选取进程；</li>
<li>分配处理机资源给进程，装入 PCB 中处理机现场信息到各寄存器，使之从上次断点处恢复运行。</li>
</ul>
<h4 id="222-进程调度机制">2.2.2 进程调度机制</h4>
<p>从进程调度的任务分析来看，进程调度机制中应当有如下三个基本部分：</p>
<ul>
<li>排队器，负责将每个就绪状态的进程插入就绪队列；</li>
<li>分派器，负责把进程调度程序所选定的进程从就绪队列中取出；</li>
<li>上下文切换器，处理机切换时候有两对上下文切换操作，即 ① 当前进程进程↔分派程序和 ② 分派程序↔新进程。这个过程要执行大量 load 和 store 等指令，一次上下文切换执行近千条指令，及其耗时。一般多使用硬件机制（加寄存器）加速这个过程。<br>
<img src="https://n1000g.github.io/post-images/1639687579233.png" alt="进程调度机制" loading="lazy"></li>
</ul>
<h4 id="223-进程调度方式">2.2.3 进程调度方式</h4>
<p>进程调度有非抢占式与抢占式两种调度方式</p>
<ul>
<li>非抢占式方式（Nonpreemptive Mode）。一旦处理机资源分配给某个进程，不会因为时钟中断或其他原因抢占其处理机，直到完成或被阻塞；</li>
<li>抢占式方式（Preemptive Mode）。允许调度程序根据某种原则抢占当前执行进程的处理机资源。这里的某种原则包括 ① 优先权原则、② 短作业优先原则和 ③ 时间片原则。</li>
</ul>
<h3 id="23-调度算法">2.3 调度算法</h3>
<h4 id="232-选择调度算法的若干准则">2.3.2 选择调度算法的若干准则</h4>
<p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑这些特性。为了比较不同处理机调度算法的性能，人民提出了若干评价准则：</p>
<ul>
<li>CPU 利用率；</li>
<li>系统吞吐量：单位时间 CPU 完成作业的数量。显然短作业越多系统吞吐量越大；</li>
<li>周转时间（从作业被提交给系统开始，到作业完成为止的这段时间间隔）：作业完成时间 - 作业提交时间
<ul>
<li>带权周转时间：周转时间 / 实际运行时间</li>
<li>平均周转时间：系统中多个进程的周转时间的平均值</li>
<li>平均带权周转时间</li>
</ul>
</li>
<li>等待时间：进程处于等待状态的时间总和；</li>
<li>响应时间：用户提交请求到系统首次产生响应所用的时间</li>
</ul>
<h4 id="232-典型的调度算法">2.3.2 典型的调度算法</h4>
<ul>
<li>非抢占式的先来先服务（First Come First Severd, FCFS）算法</li>
<li>最短作业优先（Shortest Job First, SJF）算法</li>
<li>优先级调度算法
<ul>
<li>抢占式优先级调度算法</li>
<li>非抢占式优先级调度算法</li>
<li>静态优先级调度算法</li>
<li>动态优先级调度算法</li>
</ul>
</li>
<li>高响应比优先调度算法
<ul>
<li>响应比 R<sub>p</sub> = (等待时间 + 要求服务时间) / 要求服务时间</li>
</ul>
</li>
<li>时间片轮转调度算法</li>
<li>多级反馈队列调度算法
<ul>
<li>设置多个优先级、时间片大小不同的就绪队列</li>
<li>抢占式方式</li>
</ul>
</li>
</ul>
<h2 id="3-死锁及处理方法">3 死锁及处理方法</h2>
<p>死锁（Deadlock）指多道程序系统中并发执行的多个进程因争夺资源而造成一种若无外力则有关进程都将永远不能向前推进的僵持状态。</p>
<h3 id="31-死锁产生的原因">3.1 死锁产生的原因</h3>
<p>死锁产生的原因有：</p>
<ol>
<li>对不可剥夺资源的竞争</li>
<li>非法的进程推进顺序</li>
<li>死锁产生的四个必要条件
<ol>
<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
</li>
</ol>
<h3 id="32-死锁的处理策略">3.2 死锁的处理策略</h3>
<p>死锁的处理可从如下四个角度分析：</p>
<ol>
<li>预防死锁。即破坏产生死锁的必要条件</li>
<li>避免死锁。资源分配时利用某种算法防止系统进入不安全状态</li>
<li>检测死锁。动态检测系统中死锁的发生，定位相关进程和相关资源</li>
<li>解除死锁。检测到死锁发生后撤销或挂起某进程以回收资源和再分配</li>
</ol>
<h4 id="321-死锁的预防策略">3.2.1 死锁的预防策略</h4>
<p>预防死锁指破坏死锁产生的必要条件即“互斥”条件、“不可剥夺”条件、“请求和保持”条件和“循环等待”条件。<br>
“互斥”条件作为资源的固有属性，无法破坏；<br>
破坏“请求和保持”条件，即在进程运行前就分配全部需要资源，显然不合理；<br>
破坏“不可剥夺”条件，即进程请求某个资源得不到响应是释放已得到的资源，结果是系统效率极大降低；<br>
破坏“循环等待”条件，即位资源按类型线性排列，让进程的资源请求严格按这个次序，使系统扩展性变差且有资源浪费的可能。</p>
<h4 id="322-死锁的检测与解除">3.2.2 死锁的检测与解除</h4>
<h5 id="3221-资源分配图">3.2.2.1 资源分配图</h5>
<p>用资源分配图描述系统死锁。如图，P 指进程，R 指资源，P 指向 R 的弧称请求边，R 指向 P 的弧称分配边。<br>
下图表示 P1 进程分配到了两个 R1 资源，且正在申请一个 R2 资源；P2 进程分配到了一个 R1 资源和一个 R2 资源且正在申请一个 R1 资源：<br>
<img src="https://n1000g.github.io/post-images/1639696366105.png" alt="资源分配图" loading="lazy"></p>
<h5 id="3222-死锁定理">3.2.2.2 死锁定理</h5>
<p>系统状态 S 为死锁当且仅当该状态下的资源分配图不可完全化简。</p>
<h5 id="3221-死锁解除">3.2.2.1 死锁解除</h5>
<p>解除死锁的方法有：</p>
<ol>
<li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li>
<li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li>
<li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>
<h4 id="324-死锁的避免策略和银行家算法">3.2.4 死锁的避免策略和银行家算法</h4>
<p>死锁避免的基本思想是：运行进程动态地申请资源，但系统在进行资源分配前要进行安全性检查，当且仅当此次分配不会导致系统陷入不安全状态才分配，否则拒绝。</p>
<h5 id="3221-系统的安全状态">3.2.2.1 系统的安全状态</h5>
<p>所谓安全状态指系统可按某个进程序列 &lt;P1, P2, P3, P4&gt; 来为进程分配资源所需资源，直至每个进程对资源的最大需求使每个进程都能顺利完成。例：</p>
<p>某系统中有总计 12 个磁带机资源，当前可用资源量为 3 ，相关进程和资源分配情况如下表：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>需求</th>
<th>已分配（尚需）</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>10</td>
<td>5（5）</td>
</tr>
<tr>
<td>P2</td>
<td>4</td>
<td>2（2）</td>
</tr>
<tr>
<td>P3</td>
<td>9</td>
<td>2（7）</td>
</tr>
</tbody>
</table>
<p>则对 T0 时刻，系统中存在安全分配序列 &lt;P2, P1, P3&gt;；<br>
若 T0 时刻当前资源可用量为 2，系统找不到一个安全分配序列，称系统处于不安全状态。</p>
<p>不安全分配状态不一定发生死锁。</p>
<h5 id="3222-银行家算法">3.2.2.2 银行家算法</h5>
<p>银行家算法是最著名的死锁避免算法。<br>
银行家算法的数据结构描述：</p>
<ul>
<li>可用资源向量 Available</li>
<li>最大需求矩阵 Max</li>
<li>分配矩阵 Allocation</li>
<li>需求矩阵 Need</li>
<li>请求向量 Request</li>
</ul>
<p>银行家算法描述：<br>
<img src="https://n1000g.github.io/post-images/1639699328472.png" alt="银行家算法" loading="lazy"></p>
<p>安全性检测算法描述：<br>
<img src="https://n1000g.github.io/post-images/1639699353822.png" alt="安全性检查" loading="lazy"></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://n1000g.github.io/tag/g6AsQXnCo/" class="tag">
                    Linux
                  </a>
                
                  <a href="https://n1000g.github.io/tag/SPkd31YUC/" class="tag">
                    操作系统
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://n1000g.github.io/post/f-vIjJNtK/">
                  <h3 class="post-title">
                    【OS 基础课笔记】一、操作系统引论
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
