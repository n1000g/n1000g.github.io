---
date: 2024/09/17
layout: post
category: blog
tags: [play]
---

[TOC]

# 0

这么多年来，尝试过各类 Markdown 软件、插件、在线文档服务等等。还是 Typora 用的最顺手，除了不支持 PlantUML 其他各方面体验完美。可惜收费后有点贵，有朝一日中了彩票一定补票支持

本文记录下本地文档中的图片自动上传到图床的折腾过程

在 **设置 - 偏好设置 - 图像 - 插入图片时** 选择上传图片，并设置 **上次服务设定** 为自定义命令

![image-20240917075318739](https://s2.loli.net/2024/09/17/XcWDxdaY6eFjIN7.png)

然后着手开发这个自定义命令工具

点击了解更多进入 Typora 的文档，相关部分文档内容如下

> ### Custom
>
> You could config a custom command to upload images, using tools that is not listed in above options, or even write your own tools / scripts. Typora will append all images that needs to be uploaded after the custom command you filled.
>
> Then, Typora will fetch image urls from the last N lines of the standard output of your custom command. (N is the number of images to upload).
>
> For example, if you write a tool `upload-image.sh`, then you can input `[some path]/upload-image.sh` in the command filed. Typora will call `[some path]/upload-image.sh "image-path-1" "image-path-2"` to upload two images located in `image-path-1` and `image-path-2`. Then the command may return something like:
>
> ```
> Upload Success:
> http://remote-image-1.png
> http://remote-image-2.png
> ```
>
> Then Typora will get the two remote image url from the output, and replace the original local images used in the Markdown document.
>
> You could click the “Test Uploader” button to verify your custom commands.
>
> #### Use current filename / filepath in custom commands
>
> You can use `${filename}` and `${filepath}` in your custom commands, they will be replace as the current markdown file name and current file path. For “untitled” files that have not been saved on your disk, they will be empty strings.

这里面规定了自定义工具的输出输出，即输入 n 个地址，输出 n 行 URI

这里选择 sm.ms 图床，到图床网站创建 Token 然后按照 API 开发即可

大概一个月前，突然想折腾这个事情，一开始通过 GPT 发现一个 `.ps1` 文件（powershell 脚本）直接生成 `.exe` 可执行文件的方案

> `PS2EXE` 是一个常用的工具，可以将 PowerShell 脚本转换为独立的 Windows 可执行文件。
>
> 1. 安装 PS2EXE:
>
>    你可以通过 PowerShell Gallery 安装 `PS2EXE` 模块。首先，打开 PowerShell 窗口并运行以下命令：
>
>    ```powershell
>    Install-Module -Name ps2exe
>    ```
>
> 2. 使用 PS2EXE 转换脚本:
>
>    运行以下命令将 PowerShell 脚本转换为 `.exe` 文件：
>
>    ```powershell
>    ps2exe -inputFile path\to\your\script.ps1 -outputFile path\to\output\script.exe
>    ```
>
>    你可以使用 `-iconFile` 参数指定一个自定义图标，如果需要的话。
>
>    ```powershell
>    ps2exe -inputFile path\to\your\script.ps1 -outputFile path\to\output\script.exe -iconFile path\to\icon.ico
>    ```
>
> ### 方法 2: 使用 **IExpress** 工具

几番调整，我的 ps1 脚本如下

```powershell
param (
    [string[]]$filePaths
)

# 固定的 API 密钥
$apiKey = "SHhYYcYSpIaRuvl1lveTaPhUdItGSxhC"

# API 地址
$apiUrl = "https://sm.ms/api/v2/upload"

# 解码 URL 编码
function Decode-Url {
    param (
        [string]$urlEncodedString
    )
    return [System.Uri]::UnescapeDataString($urlEncodedString)
}

# 函数：上传单个文件
function Upload-File {
    param (
        [string]$filePath
    )

    # 解码文件路径
    $decodedFilePath = Decode-Url -urlEncodedString $filePath

    # 检查文件是否存在
    if (-not (Test-Path $decodedFilePath)) {
        Write-Output "File not found: $decodedFilePath"
        return $null
    }

    # 创建 HttpWebRequest 对象
    $request = [System.Net.HttpWebRequest]::Create($apiUrl)
    $request.Method = "POST"
    $request.ContentType = "multipart/form-data; boundary=---------------------------" + [System.Guid]::NewGuid().ToString()
    $request.Headers.Add("Authorization", $apiKey)

    # 创建请求内容
    $boundary = $request.ContentType.Split('=')[1]
    $boundaryBytes = [System.Text.Encoding]::UTF8.GetBytes("--$boundary`r`n")
    $endBoundaryBytes = [System.Text.Encoding]::UTF8.GetBytes("`r`n--$boundary--`r`n")

    $stream = $request.GetRequestStream()

    # 写入文件字段头部
    $stream.Write($boundaryBytes, 0, $boundaryBytes.Length)
    $fileHeader = "Content-Disposition: form-data; name=`"smfile`"; filename=`"$(Split-Path -Leaf $decodedFilePath)`"`r`nContent-Type: application/octet-stream`r`n`r`n"
    $fileHeaderBytes = [System.Text.Encoding]::UTF8.GetBytes($fileHeader)
    $stream.Write($fileHeaderBytes, 0, $fileHeaderBytes.Length)

    # 写入文件内容
    $fileContent = [System.IO.File]::ReadAllBytes($decodedFilePath)
    $stream.Write($fileContent, 0, $fileContent.Length)

    # 结束边界
    $stream.Write($endBoundaryBytes, 0, $endBoundaryBytes.Length)
    $stream.Close()

    # 读取响应
    $response = $request.GetResponse()
    $responseStream = $response.GetResponseStream()
    $reader = New-Object System.IO.StreamReader($responseStream)
    $responseContent = $reader.ReadToEnd()
    $reader.Close()

    # 解析响应
    $jsonResponse = $responseContent | ConvertFrom-Json
    return $jsonResponse
}

# 处理每个文件
foreach ($filePath in $filePaths) {
    $uploadResult = Upload-File -filePath $filePath
    # Write-Output $uploadResult
    if ($uploadResult -and $uploadResult.success) {
        $url = $uploadResult.data.url
        Write-Output $url
    }
}
```

最后生成的可执行程序，在 powershell、cmd 里执行没发现异常，但是 Typora 里调用就不行（怀疑这种方式的 exe 有问题），最后道心破碎，放弃了折腾

今天本想记录一下之前这个折腾失败的过程，但是突发奇想，C# 编的 exe 肯定没问题，可以一试

第一步把之前留的 powershell 脚本转换成 C# 代码

```c#
using System;
using System.IO;
using System.Net;
using System.Runtime.Serialization.Json;
using System.Text;
using System.Threading.Tasks;

class Program
{
    private static readonly string ApiKey = "SHhYYcYSpIaRuvl1lveTaPhUdItGSxhC";
    private static readonly string ApiUrl = "https://sm.ms/api/v2/upload";

    static async Task Main(string[] args)
    {
        if (args.Length == 0)
        {
            Console.WriteLine("Please provide at least one file path.");
            return;
        }

        foreach (string filePath in args)
        {
            string url = await UploadFileAsync(filePath);
            if (!string.IsNullOrEmpty(url))
            {
                Console.WriteLine(url);
            }
        }
    }

    private static async Task<string> UploadFileAsync(string filePath)
    {
        string decodedFilePath = Uri.UnescapeDataString(filePath);

        if (!File.Exists(decodedFilePath))
        {
            Console.WriteLine("File not found: " + decodedFilePath);
            return null;
        }

        try
        {
            var request = (HttpWebRequest)WebRequest.Create(ApiUrl);
            request.Method = "POST";
            string boundary = "---------------------------" + Guid.NewGuid().ToString();
            request.ContentType = "multipart/form-data; boundary=" + boundary;
            request.Headers.Add("Authorization", ApiKey);

            var boundaryBytes = Encoding.UTF8.GetBytes("--" + boundary + "\r\n");
            var endBoundaryBytes = Encoding.UTF8.GetBytes("\r\n--" + boundary + "--\r\n");

            using (var requestStream = await request.GetRequestStreamAsync())
            {
                await requestStream.WriteAsync(boundaryBytes, 0, boundaryBytes.Length);

                string fileHeader = "Content-Disposition: form-data; name=\"smfile\"; filename=\"" + Path.GetFileName(decodedFilePath) + "\"\r\nContent-Type: application/octet-stream\r\n\r\n";
                var fileHeaderBytes = Encoding.UTF8.GetBytes(fileHeader);
                await requestStream.WriteAsync(fileHeaderBytes, 0, fileHeaderBytes.Length);

                byte[] fileContent = await File.ReadAllBytesAsync(decodedFilePath);
                await requestStream.WriteAsync(fileContent, 0, fileContent.Length);

                await requestStream.WriteAsync(endBoundaryBytes, 0, endBoundaryBytes.Length);
            }

            using (var response = (HttpWebResponse)await request.GetResponseAsync())
            using (var responseStream = response.GetResponseStream())
            {
                var serializer = new DataContractJsonSerializer(typeof(ApiResponse));
                var result = (ApiResponse)serializer.ReadObject(responseStream);

                if (result.Success)
                {
                    return result.Data.Url;
                }
                else
                {
                    Console.WriteLine("Upload failed: " + result.Message);
                    return null;
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Exception: " + ex.Message);
            return null;
        }
    }

    [System.Runtime.Serialization.DataContract]
    private class ApiResponse
    {
        [System.Runtime.Serialization.DataMember(Name = "success")]
        public bool Success { get; set; }

        [System.Runtime.Serialization.DataMember(Name = "data")]
        public ApiResponseData Data { get; set; }

        [System.Runtime.Serialization.DataMember(Name = "message")]
        public string Message { get; set; }
    }

    [System.Runtime.Serialization.DataContract]
    private class ApiResponseData
    {
        [System.Runtime.Serialization.DataMember(Name = "url")]
        public string Url { get; set; }
    }
}
```

但是我不想在 Windows 上装 .NET 环境（还没有过开发 Windows 程序的想法），最后的解决方案如下

1. Linux 虚拟机中装 Docker

   > https://cloud.tencent.com/developer/article/2383890
2. 装 dotnet 编译镜像
3. 在镜像里编译上面 C# 代码（upload.cs）

完整示例如下

```
# 拉取 .NET SDK 镜像
docker pull mcr.microsoft.com/dotnet/sdk

# 运行容器并挂载当前目录
docker run -it --rm -v $(pwd):/app -w /app mcr.microsoft.com/dotnet/sdk bash

# 创建项目
dotnet new console -o MyApp

# 复制源码
cp upload.cs MyApp/Program.cs

# 进入项目目录
cd MyApp

# 构建和发布项目
dotnet publish -r win-x64 -c Release --self-contained
```

上面命令直接编译出来的 exe 执行时还是报错 `You must install .NET to run this application.` 将项目根目录下的 `.csproc` 文件做如下修改后

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework> <!-- 确保这里的版本与你发布的版本匹配 -->
    <PublishSingleFile>true</PublishSingleFile> <!-- 可选：将所有文件打包成一个单一文件 -->
    <SelfContained>true</SelfContained>
  </PropertyGroup>
</Project>
```

重新编译，程序运行正常，功能正常（好像传两张图片不正常，懒得改了，我的基本使用场景没问题了）

