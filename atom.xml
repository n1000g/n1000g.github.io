<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://n1000g.github.io</id>
    <title>n1000g</title>
    <updated>2021-12-17T00:08:25.583Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://n1000g.github.io"/>
    <link rel="self" href="https://n1000g.github.io/atom.xml"/>
    <subtitle>早日成长为一只老攻城狮</subtitle>
    <logo>https://n1000g.github.io/images/avatar.png</logo>
    <icon>https://n1000g.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, n1000g</rights>
    <entry>
        <title type="html"><![CDATA[【OS 基础课笔记】经典进程同步问题的记录型信号量机制解决方案]]></title>
        <id>https://n1000g.github.io/post/KKnYhVDri/</id>
        <link href="https://n1000g.github.io/post/KKnYhVDri/">
        </link>
        <updated>2021-12-15T16:39:19.000Z</updated>
        <summary type="html"><![CDATA[<p>信号量（Semaphore）机制由圣 Dijkstra 于1956 年提出，是一种卓有成效的进程同步工具，现已被广泛运用在各类单处理机、多处理机和网络系统中。其中的记录型信号量机制今已成为考研操作系统重要考点。</p>
]]></summary>
        <content type="html"><![CDATA[<p>信号量（Semaphore）机制由圣 Dijkstra 于1956 年提出，是一种卓有成效的进程同步工具，现已被广泛运用在各类单处理机、多处理机和网络系统中。其中的记录型信号量机制今已成为考研操作系统重要考点。</p>
<!-- more -->
<h2 id="1-记录型信号量机制">1. 记录型信号量机制</h2>
<p>除了初始化操作外，信号量只能通过两个原子操作 <code>wait()</code> 和 <code>signal()</code>，也称 P 操作和 V 操作。其中记录型信号量定义为 ① 一个整型的 <code>S-&gt;value</code> 表示资源数目（大于 0）或阻塞队列的长度（小于 0）；② 进程列表 <code>S-&gt;list</code> 表示阻塞在该信号量上的进程队列。<br>
当 <code>S-&gt;value</code> 定义为 1 时，记录型信号量转化为互斥信号量表示一个用于互斥访问的临界资源。</p>
<p>记录型信号量的数据结构和 P、V 操作描述如下：</p>
<pre><code class="language-c">/**
 * 记录型信号量的进程阻塞队列
 */
typedef struct process_control_block {
    int pid; // 进程标识符
    struct process_control_block * next; // 队列指针
} process_control_block;

/**
 * semaphore 记录型信号量
 */
typedef struct {
    int value; // 资源数量
    process_control_block * list; // 阻塞队列头
} semaphore;

void wait(semaphore * S) {
    S-&gt;value --;
    if (S-&gt;value &lt; 0) block(S-&gt;list);
}

void signal(semaphore * S) {
    S-&gt;value ++;
    if (S-&gt;value &lt;= 0) wakeup(S-&gt;list);
}
</code></pre>
<p>其中 block() 和 wakeup() 是操作系统原语，分别用于 阻塞 和 唤醒 进程。</p>
<h2 id="2-生产者-消费者问题">2. 生产者-消费者问题</h2>
<blockquote>
<p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多进程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
</blockquote>
<h3 id="21-基于循环缓冲的解决方案">2.1 基于循环缓冲的解决方案</h3>
<p>假定缓冲池中有 n 个缓冲区并用循环结构组织，可以利用互斥信号量 mutex 实现各进程对缓冲池的互斥使用，用信号量 empty 和 full 分别表示缓冲池中空缓冲和满缓冲资源的数目。</p>
<pre><code class="language-c">int in = 0, out = 0;
item buffer[n];
semaphore mutex = 1, full = 0, empty = n;
/**
 * 生产者进程——
 * 申请空缓冲并生产数据项，如果无空缓冲区资源则自我阻塞直到被空缓冲区资源唤醒
 * 需注意缓冲池资源的互斥访问
 */
void producer() {
    do {
        item nextp = produce_an_item();
        P(empty);
        P(mutex);
        buffer[in] = nextp;
        in = (in+1) % n;
        V(mutex);
        V(full);
    } while(true);
}

/**
 * 消费者进程——
 * 申请满缓冲区并消费数据项，如果无满缓冲区资源则自我阻塞直到被满缓冲区资源唤醒
 */
void consumer() {
    do {
        P(full);
        P(mutex);
        item nextc = buffer[out];
        out = (out+1) % n;
        V(mutex);
        V(empty);
        consume_the_item(nextc);
    } while (true);
}
</code></pre>
<p>主程序描述</p>
<pre><code class="language-c">void main() {
    cobegin
        producer(); consumer();
    coend
}
</code></pre>
<h3 id="22-基于单缓冲的但生产者-单消费者类同步问题">2.2 基于单缓冲的但生产者-单消费者类同步问题</h3>
<p>在测控系统中，数据采集任务将数据送入一单缓冲区，计算任务对该但缓冲区中数据取出并做计算处理。在这类问题中，信号量 full 和 empty 已经可以表示单缓冲资源的互斥属性了，相对 2.1 的代码描述，可以不再定义互斥信号量 mutex。</p>
<h2 id="3-哲学家进餐问题">3. 哲学家进餐问题</h2>
<p>由圣 Dijkstra 于1971 年提出并解决的用来演示在并发计算中多线程同步时产生的问题，旨在说明避免死锁和资源耗尽等问题。它的具体描述如下：</p>
<blockquote>
<p>有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子，平时哲学家进行思考，饥饿时便试图取其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐，该哲学家进餐完毕后，放下左右两只筷子又继续思考。</p>
</blockquote>
<h3 id="31-信号量定义和哲学家活动描述">3.1 信号量定义和哲学家活动描述</h3>
<p>筷子作为临界资源，一段时间仅允许一位哲学家使用，为了实现对筷子的互斥使用，可以为每根筷子设置一个互斥信号量，于是第 i 位 哲学家的活动可描述为</p>
<pre><code class="language-c">/**
 * 临界资源筷子
 */
semaphore chopstick[5] = {1, 1, 1, 1, 1}; 
/**
 * 第 i 位哲学家
 */
void philosopher_i() {
    do {
        P(chopstick[i]);
        P(chopstick[(i+1) % 5]);
        // eat
        V(chopstick[i]);
        V(chopstick[(i+1) % 5]);
        // think
    } while (true);
}
</code></pre>
<h3 id="32-存在问题分析和进一步解决方案">3.2 存在问题分析和进一步解决方案</h3>
<p>上述方案中，每个哲学家先拿起左边筷子再拿起右边筷子，不会出现相邻的两个哲学家竞争同一根筷子的情况，但可能出现每个哲学家同时饥饿并拿起自己左边的筷子，引起死锁。</p>
<p>为了避免死锁，有如下三种解决方案：</p>
<ol>
<li>双筷同举——当且仅当拿起两根筷子才允许进餐</li>
<li>奇偶有别——1、3、5 号哲学家先左后右，2、4 号哲学家先右后左</li>
<li>进餐限制——最多允许 4 根筷子被同时申请</li>
</ol>
<p>代码描述分别如下：</p>
<pre><code class="language-c">/**
 * 1. 双筷齐举
 * 设置一个互斥信号量，同一时间只允许一个进程做申请资源 wait 操作
 * 可以解决死锁问题，但是显然进程并发性变差
 */
semaphore mutex = 1;

void philosopher_i() {
    do {
        P(mutex);
        P(chopstick[i]);
        P(chopstick[(i+1) % 5]);
        V(mutex);
        // eat
        V(chopstick[i]);
        V(chopstick[(i+1) % 5]);
        // think
    } while (true);
}

/**
 * 2. 奇偶有别
 * 1、3、5 号哲学家先申请 i 号筷子后申请 (i+1) % 5 号筷子
 * 2、4 号哲学家先申请  (i+1) % 5 号筷子后申请 i 号 筷子
 * 经分析，解决了死锁问题
 */
// 实现略

/**
 * 3. 进餐限数
 * 设置一个初始化值为 4 资源信号量表示申请资源的权力
 * 最多只允许 4 个哲学家在申请筷子资源
 * 可以解决死锁问题，而进程并发性也未变差
 */
semaphore limit = 4;

void philosopher_i() {
    do {
        P(limit);
        P(chopstick[i]);
        P(chopstick[(i+1) % 5]);
        V(limit);
        // eat
        V(chopstick[i]);
        V(chopstick[(i+1) % 5]);
        // think
    } while (true);
}
</code></pre>
<h3 id="33-其他资料">3.3 其他资料</h3>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/the-dining-philosophers/">https://leetcode-cn.com/problems/the-dining-philosophers/</a></p>
</blockquote>
<h2 id="4-读者-写者问题">4. 读者-写者问题</h2>
<p>读者-写者问题常用于测试新同步原语，其问题描述如下：<br>
多个进程共享一个数据对象，只要求读的进程称读者进程，有写或修改要求的进程称写者进程。读操作可由多个读者进程同时执行，而写操作具有排他性。</p>
<h3 id="41-读者优先">4.1 读者优先</h3>
<p>下图是读者-写者问题的读者优先解决方案也即一般化的解决方案<br>
<img src="https://n1000g.github.io/post-images/1639600123226.png" alt="读者优先" loading="lazy"></p>
<p>即第一个到来的读者进程和其他写者进程一同竞争数据对象的资源信号量，如果发现资源所有者为读者进程，新来的读者进程可以跳过申请，直接进行读操作。而实现这个过程又需要对读者进程进行计数：</p>
<ul>
<li>考虑到写者进程要与其他进程互斥执行，设置写互斥信号量 wmutex；</li>
<li>读者进程之间可并发执行，设置计数变量 readercount 初始为 0；</li>
<li>readercount 对于多个读者进程而言是临界资源，应为之设立互斥信号量 rmutex。</li>
</ul>
<pre><code class="language-c">int readercount = 0;
semaphore rmutex = 1, wmutex = 1;
/**
 * 写者进程——互斥访问
 */
void writer() {
    do {
        P(wmutex);
        写操作
        V(wmutex);
    } while(true);
}

/**
 * 读者进程——
 * 系统中只存在的当前唯一的读者进程 0 时，与写者进程竞争临界资源
 * 访问 readercount 并计数
 */
void reader() {
    do {
        P(rmutex);
        if (readercount == 0) P(wmutex);
        readercount++;
        V(rmutex);
        读操作
        P(rmutex);
        readercount--;
        if (readercount == 0) V(wmutex);
        V(rmutex);
    } while (true);
}
</code></pre>
<p>主程序描述</p>
<pre><code class="language-c">void main() {
    cobegin
        reader₁(); reader₂(); ...
        writer₁(); writer₂(); ...
    coend
}
</code></pre>
<h3 id="42-公平型读者-写者问题即解决方案">4.2 公平型读者-写者问题即解决方案</h3>
<p>上述解决方案对写者进程来说，一旦系统中有读者进程在进行读操作，就必须等待，直到 readercount 等于 0。要消除这个读者优先，实现新来进程无论是读者还是写者都阻塞于同一队列，公平竞争临界资源，即“公平型读者-写者问题”的解决方案如下：<br>
<img src="https://n1000g.github.io/post-images/1639601542576.png" alt="公平型读者写者" loading="lazy"></p>
<p>如图，设置一个互斥信号量 S，读者进程和写者进程都需要先竞争 S，再进行之前的操作，使得阻塞在 S 上的进程是什么属性都无所谓，实现公平竞争。</p>
<pre><code class="language-c">int readercount = 0;
semaphore rmutex = 1, wmutex = 1, S = 1;
/**
 * 写者进程
 */
void writer() {
    do {
        P(S);
        P(wmutex)
        V(S);
        写操作
        V(wmutex);
    } while(true);
}

/**
 * 读者进程
 */
void reader() {
    do {
        P(S);
        P(rmutex);
        if (readercount == 0) P(wmutex);
        readercount++;
        V(rmutex);
        V(S);
        读操作
        P(rmutex);
        readercount--;
        if (readercount == 0) V(wmutex);
        V(rmutex);
    } while (true);
}
</code></pre>
<h3 id="43-写者优先">4.3 写者优先</h3>
<p>如题。<br>
<img src="https://n1000g.github.io/post-images/1639601905558.png" alt="写者优先" loading="lazy"></p>
<p>仅第一个到达的写者进程与读者进程一起去 S 处排队</p>
<pre><code class="language-c">int readercount = 0, writercount = 0;
semaphore rmutex = 1, wmutex = 1, S = 1, mutex = 1;
/**
 * 写者进程——添加了与读者优先解决方案中与读者相似的逻辑
 */
void writer() {
    do {
        P(mutex);
        if (writercount == 0) P(S);
        writercount ++;
        V(mutex);

        P(wmutex)
        写操作
        V(wmutex);
        
        P(mutex);
        writercount --;
        if (writercount == 0) V(S);
        V(mutex);
    } while(true);
}

/**
 * 读者进程——同 4.3
 */
void reader() {
    do {
        P(S);
        P(rmutex);
        if (readercount == 0) P(wmutex);
        readercount++;
        V(rmutex);
        V(S);
        读操作
        P(rmutex);
        readercount--;
        if (readercount == 0) V(wmutex);
        V(rmutex);
    } while (true);
}
</code></pre>
<h3 id="44-限定读者问题">4.4 限定读者问题</h3>
<p>如题<br>
可增设 rmax 信号量，使多出来的读者进程阻塞至此。</p>
<pre><code class="language-c">int readercount = 0;
semaphore rmutex = 1, wmutex = 1;
/**
 * 写者进程——同 4.1
 */
void writer() {
    do {
        P(wmutex);
        写操作
        V(wmutex);
    } while(true);
}

/**
 * 读者进程——多余读者挂至 rmax 信号量阻塞队列
 */
void reader() {
    do {
        P(rmax);

        P(rmutex);
        if (readercount == 0) P(wmutex);
        readercount++;
        V(rmutex);
        读操作
        P(rmutex);
        readercount--;
        if (readercount == 0) V(wmutex);
        V(rmutex);

        V(rmax);
    } while (true);
}
</code></pre>
<h2 id="5-其他经典-p-v-操作问题">5. 其他经典 P-V 操作问题</h2>
<h3 id="51-独木桥-单行道问题">5.1 独木桥、单行道问题</h3>
<p>如题，南北通车，单行道上只能走同一方向的车辆。使用记录型信号量模拟道路情况。<br>
分析：两个方向的车辆基本性质完全相同，均类似读者-写者问题中写者进程。使每类第一个到达的进程与另一类进程竞争单行道这一临界资源。</p>
<pre><code class="language-c">/**
 * 南边来的和北边来的车辆数量
 * 和临界资源——单行道
 */
int southcount = 0, northcount = 0;
semaphore road = 1;
/**
 * 模拟由南向北的车辆
 */
void S2N() {
    do {
        P(smutex);
        if (southcount == 0) P(road);
        southcount++;
        V(smutex);
        通过单行道
        P(smutex);
        southcount--;
        if (southcount == 0) V(road);
        V(smutex);
    } while (true);
}

/**
 * 模拟由北向南的车辆
 */
void N2S() {
    do {
        P(nmutex);
        if (northcount == 0) P(road);
        northcount++;
        V(nmutex);
        通过单行道
        P(nmutex);
        northcount--;
        if (northcount == 0) V(road);
        V(nmutex);
    } while (true);
}
</code></pre>
<h3 id="52-司机售票员同步问题">5.2 司机售票员同步问题</h3>
<p>问题描述：汽车司机与售票员之间必须协同工作，一方面，只有售票员把车门关好了司机才能开车，因此，售票员关好车门应通知司机开车。另一方面，只有当司机已经停下，售票员才能开门上下客，故司机停车后应通知售票员。假定某辆公共汽车上有两名售票员与一名司机，汽车当前正在始发站停车上客，试设必要的信号灯及赋初值，写出他们的同步过程。</p>
<p><strong>问题解答</strong></p>
<blockquote>
<p><a href="https://www.codeleading.com/article/32956105455/">https://www.codeleading.com/article/32956105455/</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OS 基础课笔记】二、进程管理]]></title>
        <id>https://n1000g.github.io/post/k2efUYuav/</id>
        <link href="https://n1000g.github.io/post/k2efUYuav/">
        </link>
        <updated>2021-12-12T23:36:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-进程与线程">1. 进程与线程</h2>
<h3 id="11-进程的定义与特征">1.1 进程的定义与特征</h3>
<p>在多道程序环境下，允许多个程序并发执行，此时它们失去封闭性，并具有间断性及不可再现性的特征。为此映入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p>
<p>为使并发的程序能独立运行，必须为止配置一个专门的数据结构，称为进程控制块（Process Control Block，PCB）。操作系统利用 PCB 描述一个进程的基本情况和运行状态，所谓创建进程就是创建一个 PCB。PCB、程序段和数据段三部分共同构成了<strong>进程实体</strong>，也即进程映像。进程是动态的，进程映像是静态的；</p>
<p>由此给出进程的定义——<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p>
<p>并可知进程的主要特征有动态性、并发性、独立性、异步性和结构性。</p>
<h3 id="12-进程控制块process-control-blockpcb">1.2 进程控制块（Process Control Block，PCB）</h3>
<p><strong>PCB 是进程存在的唯一标志</strong>，也是操作系统管理和控制并发执行进程的依据。它常驻内存并存放在操作系统专门开辟的 PCB 区。进程控制块中有如下信息：</p>
<ul>
<li>进程标识符
<ul>
<li>内部 PID、外部 PID</li>
<li>父进程、子进程、用户标识符</li>
</ul>
</li>
<li>处理器状态信息
<ul>
<li>通用寄存器、PC、PSW、用户栈指针寄存器等</li>
</ul>
</li>
<li>进程调度信息
<ul>
<li>进程状态、进程优先级、事件等</li>
</ul>
</li>
<li>进程控制信息
<ul>
<li>程序和数据地址、进程同步通信机制</li>
<li>资源清单、链接指针、进程图</li>
</ul>
</li>
</ul>
<p><strong>Linux 中对 PCB 的描述</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/a1414345/article/details/55550460">Linux中进程控制块（PCB）的task_struct结构描述</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/liexusong/linux-source-code-analyze/blob/master/process-management.md">linux-source-code-analyze/process-management.md</a></p>
</blockquote>
<h3 id="13-进程状态变迁">1.3 进程状态变迁</h3>
<p>进程在其生命周期内由于系统中各个进程之间相互制约关系和系统环境的变换，使得进程状态也在不断变化，通常具有如下五种状态：<br>
<img src="https://n1000g.github.io/post-images/1639525596602.png" alt="进程五态模型" loading="lazy"></p>
<p>进程的五态模型假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的，即七态模型：<br>
<img src="https://n1000g.github.io/post-images/1639525745466.png" alt="进程七态模型" loading="lazy"></p>
<p><strong>Linux 中的进程状态</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/zyboy2000/article/details/4179834">Linux进程状态(ps stat)之R、S、D、T、Z、X</a></p>
</blockquote>
<h3 id="14-进程同步">1.4 进程同步</h3>
<p>为了协调并发执行的进程只键的相互制约关系，引入了进程同步的概念。</p>
<h4 id="141-基本概念">1.4.1 基本概念</h4>
<p><strong>同步和互斥</strong><br>
同步也称直接制约关系，互斥也称间接制约关系。前者例如 A 进程通过单缓冲向 B 进程提供数据，缓冲区空时，B 进程需阻塞等待；后者例如 A、B进程都需要使用系统中仅有的唯一的 I/O 设备 C，C 被分配给 A 时，B 需要阻塞等待。</p>
<p><strong>临界资源和临界区</strong><br>
临界资源指一次仅仅运行一个进程使用的资源，例如打印机等物理设备、共享变量等；<br>
临界区指访问临界资源那段代码，又称临界段。临界区前的检查部分称进入区，临界区后的标志清除部分称退出区。</p>
<pre><code class="language-c">do {
    entry section;
    critical section;
    exit section;
    remainder section;
} while(true)
</code></pre>
<h4 id="142-进程同步准则">1.4.2 进程同步准则</h4>
<p>同步机制应当遵循如下准则：</p>
<ol>
<li>空闲让进——临界区空闲时，当运行一个请求进入临界区的进程立刻进入；</li>
<li>忙则等待——有进程进入临界区，其他试图进入临界区的进程必须等待；</li>
<li>有限等待——对请求访问的进程，需保证能在有限时间内进入临界区；</li>
<li>让权等待——当进程不能进入临界区时，应当释放处理器资源，防止进程忙等待。</li>
</ol>
<h4 id="143-进程同步机制">1.4.3 进程同步机制</h4>
<h5 id="1431-硬件方法">1.4.3.1 硬件方法</h5>
<ol>
<li>关中断——进入锁测试前屏蔽一切中断请求，不进行进程或线程切换；</li>
<li>Test-and-Set——指令，指令执行期间不允许被中断，获取所访问的临界资源的占用情况；</li>
<li>Swap 指令——同上，硬件逻辑实现</li>
</ol>
<h5 id="1432-软件方法">1.4.3.2 软件方法</h5>
<ol>
<li>
<p>单标志位——设置单标志位 <code>turn</code> 用于指示允许进入临界区的进程编号，两个进程循环进入临界区，一个进程结束另一个进程也无法访问自己的临界区，违反“空闲让进”原则</p>
<pre><code class="language-c">Process0:					    Process1:
	while(turn != 0);			    while(turn != 1);
	critical section;			    criticla section;
	turn = 1;					    turn = 0;
	remainder section;			    remainder section;
</code></pre>
</li>
<li>
<p>双标志位先检查——进入临界区前先检查是否被占用，但可能多个进程同时进入临界区，违反“忙则等待”原则</p>
<pre><code class="language-c">Process0:					    Process1:
	while(flag1);				    while(flag0);
	flag0 = true;				    flag1 = true;
	critical section;			    criticla section;
	flag0 = false;				    flag1 = false;
	remainder section;			    remainder section;
</code></pre>
</li>
<li>
<p>双标志位后检查——算法二先检查占用情况再设置自己占用标志位，算法三则先设置标志位后检查占用情况，避免了同时进入临界区违反“忙则等待“的情况，但出现了”饥饿“的现象，违反”空闲让进“原则</p>
<pre><code class="language-c">Process0:					    Process1:
	flag0 = true;				    flag1 = true;
	while(flag1);				    while(flag0);
	critical section;			    criticla section;
	flag0 = false;				    flag1 = false;
	remainder section;			    remainder section;
</code></pre>
</li>
<li>
<p>Peterson's Algorithm——既设置占用标志位 <code>flag</code> 也设置 <code>turn</code> 标志，利用 <code>flag</code> 解决互斥访问问题，利用 <code>turn</code> 解决”饥饿“现象</p>
<pre><code class="language-c">Process0:					    Process1:
	flag0 = true; turn=1;		    flag1 = true;turn = 0;
	while(flag1 &amp;&amp; turn == 1);	    while(flag0 &amp;&amp; turn == 0);
	critical section;			    criticla section;
	flag0 = false;				    flag1 = false;
	remainder section;			    remainder section;
</code></pre>
</li>
</ol>
<p>以上方案都没有遵守”让权等待“原则。</p>
<h5 id="1433-信号量机制">1.4.3.3 信号量机制</h5>
<p>信号量（Semaphore）机制于 1956 年由圣 Dijkstra 提出，是一种卓有成效的进程同步工具，现已被广泛运用在各类单处理机、多处理机和网络系统中。除了初始化操作外，信号量只能通过两个原子操作 <code>wait()</code> 和 <code>signal()</code>，也称 P 操作和 V 操作。</p>
<ol>
<li>
<p>整型信号量——整型信号量被定义为一个用于表示资源数目的整型量 S，P、V 操作分别定义为</p>
<pre><code class="language-c">wait(S) {
    while(S &lt;= 0);
    S--;
}

signal(S){
    S++;
}
</code></pre>
</li>
<li>
<p>记录型信号量——一个整型的 <code>S-&gt;value</code> 表示资源数目（大于 0）或阻塞队列的长度（小于 0）；进程列表 <code>S-&gt;list</code> 表示阻塞在该信号量上的进程队列；<code>S-&gt;value</code> 等于 1 时，记录型信号量转化为互斥信号量表示一个用于互斥访问的临界资源。</p>
<pre><code class="language-c">/**
 * 记录型信号量的进程阻塞队列
 */
typedef struct process_control_block {
    int pid; // 进程标识符
    struct process_control_block * next; // 队列指针
} process_control_block;

/**
 * semaphore 记录型信号量
 */
typedef struct {
    int value; // 资源数量
    process_control_block * list; // 阻塞队列头
} semaphore;

void wait(semaphore * S) {
    S-&gt;value --;
    if (S-&gt;value &lt; 0) block(S-&gt;list);
}

void signal(semaphore * S) {
    S-&gt;value ++;
    if (S-&gt;value &lt;= 0) wakeup(S-&gt;list);
}
</code></pre>
</li>
<li>
<p>AND 型信号量</p>
</li>
<li>
<p>信号量集机制（Unix）</p>
</li>
</ol>
<h5 id="1434-管程机制">1.4.3.4 管程机制</h5>
<p>信号量机制要求每个要访问临界资源的进程都自备同步操作 P 和 V，这给系统管理带来了极大的麻烦。计算机系统中的各类软硬件资源都可以用数据结构进行抽象描述，即用少量信息表征该资源而忽略内部结构和实现细节。据此，可用共享数据结构抽象地表示系统中的共享资源，并对该共享数据结构实施特定的操作定义为一组过程。管程是由一组数据及定义在这组数据上的对这组数据的操作组成的软件模块。</p>
<p>管程有如下基本特性：</p>
<ol>
<li>局部于管程的数据只能被局部与管程内的过程所访问；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>
<li>每次仅允许一个进程在管程内执行某个内部过程。</li>
</ol>
<p><strong>理解和相关资料</strong></p>
<blockquote>
<p><a href="https://www.zhihu.com/question/30641734">知乎：如何理解管程</a><br>
<a href="https://icecrea-blog.gitbook.io/blog/bing-fa/guan-cheng-mo-xing-yu-deng-dai-tong-zhi-ji-zhi">https://icecrea-blog.gitbook.io/blog/bing-fa/guan-cheng-mo-xing-yu-deng-dai-tong-zhi-ji-zhi</a><br>
<a href="https://segmentfault.com/a/1190000021557492">https://segmentfault.com/a/1190000021557492</a></p>
</blockquote>
<h4 id="144-进程同步经典问题">1.4.4 进程同步经典问题</h4>
<p><a href="https://n1000g.github.io/post/KKnYhVDri/">https://n1000g.github.io/post/KKnYhVDri/</a></p>
<h3 id="15-进程通信">1.5 进程通信</h3>
<p>进程通信指的是进程之间的信息交换。由于进程的互斥与同步也需要在进程间交换一些信息，故也可以把它们归为进程通信，称为低级进程通信。以信号量机制为例，它之所以低级的原因在于：① 效率低；② 通信对用户不透明。要在进程间传送大量数据，应当利用 OS 提供的高级通讯工具。<br>
<img src="https://n1000g.github.io/post-images/1639621745101.png" alt="进程通信模型" loading="lazy"></p>
<h4 id="151-进程通信的类型">1.5.1 进程通信的类型</h4>
<p>高级通信机制可分为四大类：</p>
<ol>
<li>共享存储器系统——基于共享存储结构或共享存储区；</li>
<li>管道（pipe）通信系统——所谓“管道”是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件；</li>
<li>消息传递系统——进程将要传递的数据封装到格式化的“消息”（message）中，利用 OS 提供的通信原语（直接通信方式）或某个共享的中间实体“邮箱”（间接通信方式）进行消息传递；</li>
<li>客户机-服务器系统——当前最主流的通信实现方式，可分为套接字（socket）、远程过程调用（RPC）和远程方法调用三类。</li>
</ol>
<h4 id="152-管道机制">1.5.2 管道机制</h4>
<p>传统的 Unix 系统为进程间的通信提供了管道机制，分为有名管道和无名管道。管道本质上是一个内核缓冲区，Unix 下“一切皆文件”，但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中；无名管道一般使用 fork 函数实现父子进程的通信，命名管道用于没有血缘关系的进程也可以进程间通信；管道面向字节流、自带同步互斥机制、半双工，只能单向通信。<br>
<img src="https://n1000g.github.io/post-images/1639622356041.png" alt="管道模型" loading="lazy"></p>
<h4 id="153-直接消息传递系统">1.5.3 直接消息传递系统</h4>
<p>直接消息传递系统中，发送进程利用 OS 提供消息发送原语，直接把消息发送给目标进程：<code>send(receiver, message);</code>，接收进程利用接收原语 <code>receive(sender, message);</code> 或 <code>receive(id, message);</code> 接收消息。</p>
<p>Unix 系统提供了消息队列的构建（msgget）、操作（msgctl）、发送（msgsnd）、接收（msgrcv）等系统调用。</p>
<h4 id="154-信箱通信间接消息传递系统">1.5.4 信箱通信（间接消息传递系统）</h4>
<p>类似直接消息传递系统，OS 提供邮箱的创建、撤销和消息的发送、接收等原语，信箱被定义为一种共享数据结构，既可以实现实时通信也可以实现延时通信。</p>
<h4 id="155-消息缓冲队列通信机制">1.5.5 消息缓冲队列通信机制</h4>
<p>消息缓冲队列通信机制最先由 Hansan 提出并实现，后来广泛运用于本地进程之间的通信中。它根据”生产者-消费者”原理，利用内存中公用消息缓冲区实现进程之间的信息交换。发送者进程使用 Send 原语将消息直接发送给接收进程，接收进程则利用 Receive 原语接收消息。</p>
<pre><code class="language-c">/**
 * 消息缓冲区——定义消息格式
 */
typedef struct message_buffer {
    int sender;             // 发送进程 PID
    int size;                  // 消息大小（用于向 OS 申请消息缓冲区时）
    char* text;             // 消息正文
    struct message_buffer *next;    //指向下一个消息缓冲区的指针
}

/**
 * 在进程 PCB 中新增的数据项
 */
typedef struct process_control_block {
    ...
    struct message_buffer *mq;      // 消息缓冲队列队首指针
    semaphore mq_mutex;             // 消息缓冲队列互斥信号量
    semaphore mq_resource;            // 消息缓冲队列资源信号量
    ...
}
</code></pre>
<ol>
<li>A 进程调用 Send 原语，申请一个消息缓冲区 buffer，把自身发送区数据拷贝到 buffer 中并挂载到 B 进程的 *mq 上；</li>
<li>B 进程调用 Receive 原语，从自身 *mq 上取下一个 buffer，读出数据到自身接受区，然后释放 buffer。</li>
</ol>
<p>以下是接受原语 Send 和发送原语 Receive 的描述：</p>
<pre><code class="language-c">/**
 * 发送原语（a 为发送区地址）
 */
void send(receiver, a) {
    getbuf(a.size, buffer_i);
    buffer_i.sender = a.sender; buffer_i.size = a.size; copy(a.text, buffer_i.text);
    buffer_i.next = 0;
    P(receiver.mq_mutex);
    insert(&amp;reveiver.mq, buffer_i);             // inqueue
    V(receiver.mq_mutex);
    V(receiver.mq_resource);
}

/**
 * 接收原语（b 为接收区地址）
 */
void receive(b) {
    p = get_cur_process();          // 进程自身 PCB
    P(p.mq_resource);
    P(p.mq_mutex);
    remove(p.mq, buffer_i);                        // dequeue
    V(p.mq_mutex);
    b.sender = buffer_i.sender; b.size = buffer_i.size; copy(buffer_i.text, b.text);
    releasebuf(buffer_i);
}
</code></pre>
<h3 id="16-线程thread和多线程模型">1.6 线程（Thread）和多线程模型</h3>
<p>引入进程是为例更好地使多道程序并发执行，提高系统资源利用率和吞吐量，增加并发程度，但进程并发机制存在一定缺陷如进程切换创建时空开销大，通信效率低等。克服这些缺陷的一个思路是使资源拥有与调度分派这两个进程的基本属性相分离，这就引入了线程。</p>
<p>**线程即”轻量级进程“，是一个基本的 CPU 执行单元，也即 CPU 独立调度的基本单位。**其基本特征除了 ① 是处理机的独立调度单位，可以并发执行外还有 ② 轻型实体，不拥有系统资源、③ 同一个进程下的线程共享进程资源和 ④ 有自己独立的生命周期。</p>
<h4 id="161-线程实现方式">1.6.1 线程实现方式</h4>
<p>线程分为<strong>内核支持线程</strong>（Kernel Supported Thread，KST）和<strong>用户级线程</strong>（User-Level Thread，ULT）。</p>
<ul>
<li>用户级线程中有关线程的实现与管理工作由应用程序完成，与 OS 平台无关。线程切换不涉及内核空间的转换，内核意识不到线程的存在，应用程序可以通过使用编程语言提供的线程库设计成多线程程序。故当某个线程执行一个系统调用时，进程下所有线程一起阻塞。所以在单纯的用户级线程实现方式中，即使是多线程应用也无法利用多处理机的并行优势。</li>
<li>内核级线程中，线程管理的所有工作由内核完成，内核为进程及其内部每个线程设立<em>线程控制块</em>维护上下文信息，应用程序没有进行线程管理的代码，只有一个到内核级线程的编码接口。大多数 OS 都支持内核级线程。相对进程，它只占有很小的数据结构和堆栈，切换快开销小；相对 ULK，多处理机系统下可调度同一个进程多线程并行执行，提高系统效率。</li>
</ul>
<h4 id="162-多线程模型">1.6.2 多线程模型</h4>
<p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的链接方式。即下图所示的一对一模型、一对多模型和多对多模型。<br>
<img src="https://n1000g.github.io/post-images/1639680944096.jpg" alt="多线程模型" loading="lazy"></p>
<ul>
<li>多对一模型，即将用户线程映射到一个内核控制线程（也就是内核里不支持线程），这些线程的管理调度在用户空间实现，仅当用户线程访问内核时才进行映射，每次仅允许一个线程进行映射。Unix 中内核中并不支持线程，可视作采用了这一模型；</li>
<li>一对一模型，下将每个用户级线程映射到一个内核支持线程，内核管理其调度运行，并发性最好，但系统开销巨大，OS 要对内核空间里的最大线程数有限制。Linux、Windows 等系统实现了该模型；</li>
<li>多对多模型，即允许多个用户级线程映射到若干个内核级线程上。综合了前两者的优缺点，但实现极端复杂，是个理论模型，曾由 IBM 主导的 NGPT 采用了多对多的线程模型，不过现在已废弃；</li>
</ul>
<h4 id="163-linux-多线程模型的实现linuxthreads-和-nptl">1.6.3 Linux 多线程模型的实现——LinuxThreads 和 NPTL</h4>
<p>多线程最初是由 LinuxThreads 这个工程带入到 Linux 的，但是 LinuxThreads 并不符合 POSIX 在线程方面的标准。之后的原生 POSIX 线程库（Native POSIX Thread Library，NPTL）比 LinuxThreads 更符合标准，且克服了后者的许多缺陷。</p>
<blockquote>
<p><strong><a href="https://en.wikipedia.org/wiki/POSIX">可移植操作系统接口 POSIX</a></strong> 和 <strong><a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">原生 POSIX 线程库 NPTL</a></strong><br>
<a href="http://cs.uns.edu.ar/~jechaiz/sosd/clases/extras/03-LinuxThreads%20and%20NPTL.pdf">Linux threading models compared: LinuxThreads<br>
and NPTL</a><br>
<a href="https://www.jianshu.com/p/6c507b966ad1">【译】Linux 线程模型比较：LinuxThreads 和 NPTL</a></p>
</blockquote>
<h2 id="2-处理机调度">2. 处理机调度</h2>
<p>调度的实质是资源分配，处理机调度即对处理机这个资源进行分配。处理机调度是多道程序操作系统的基础，也是操作系统设计的核心问题。</p>
<h3 id="21-处理机调度类型与模型">2.1 处理机调度类型与模型</h3>
<p>一个作业从提交到完成往往要经历三级调度。</p>
<ul>
<li>作业调度。又称高级调度，指内存与辅存之间的调度；</li>
<li>内存调度。又称中级调度，其作用是提高内存利用率与系统吞吐量，将暂时不能运行的进程调至外存等待，把此时的进程状态称为挂起态。</li>
<li>低级调度。又称进程调度，指分配处理机资源。<br>
<img src="https://n1000g.github.io/post-images/1639685424450.png" alt="多级调度示意图" loading="lazy"></li>
</ul>
<h3 id="22-处理机调度实现机制">2.2 处理机调度实现机制</h3>
<p>作业调度即创建和销毁进程，核心问题是内存分配，其实现机制主要在第三章内存管理讨论；中级调度涉及内存空间管理的兑换技术或虚拟存储技术，也是内存管理的主要功能；进程调度是 OS 中必不可少的一种调度，也是对系统性能影响最大的一种处理机调度，这里只讨论进程调度的实现方式和具体机制。</p>
<h4 id="221-进程调度的任务">2.2.1 进程调度的任务</h4>
<p>进程调度的任务主要有三：</p>
<ul>
<li>保护处理机的现场信息；</li>
<li>按某种算法选取进程；</li>
<li>分配处理机资源给进程，装入 PCB 中处理机现场信息到各寄存器，使之从上次断点处恢复运行。</li>
</ul>
<h4 id="222-进程调度机制">2.2.2 进程调度机制</h4>
<p>从进程调度的任务分析来看，进程调度机制中应当有如下三个基本部分：</p>
<ul>
<li>排队器，负责将每个就绪状态的进程插入就绪队列；</li>
<li>分派器，负责把进程调度程序所选定的进程从就绪队列中取出；</li>
<li>上下文切换器，处理机切换时候有两对上下文切换操作，即 ① 当前进程进程↔分派程序和 ② 分派程序↔新进程。这个过程要执行大量 load 和 store 等指令，一次上下文切换执行近千条指令，及其耗时。一般多使用硬件机制（加寄存器）加速这个过程。<br>
<img src="https://n1000g.github.io/post-images/1639687579233.png" alt="进程调度机制" loading="lazy"></li>
</ul>
<h4 id="223-进程调度方式">2.2.3 进程调度方式</h4>
<p>进程调度有非抢占式与抢占式两种调度方式</p>
<ul>
<li>非抢占式方式（Nonpreemptive Mode）。一旦处理机资源分配给某个进程，不会因为时钟中断或其他原因抢占其处理机，直到完成或被阻塞；</li>
<li>抢占式方式（Preemptive Mode）。允许调度程序根据某种原则抢占当前执行进程的处理机资源。这里的某种原则包括 ① 优先权原则、② 短作业优先原则和 ③ 时间片原则。</li>
</ul>
<h3 id="23-调度算法">2.3 调度算法</h3>
<h4 id="232-选择调度算法的若干准则">2.3.2 选择调度算法的若干准则</h4>
<p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑这些特性。为了比较不同处理机调度算法的性能，人民提出了若干评价准则：</p>
<ul>
<li>CPU 利用率；</li>
<li>系统吞吐量：单位时间 CPU 完成作业的数量。显然短作业越多系统吞吐量越大；</li>
<li>周转时间（从作业被提交给系统开始，到作业完成为止的这段时间间隔）：作业完成时间 - 作业提交时间
<ul>
<li>带权周转时间：周转时间 / 实际运行时间</li>
<li>平均周转时间：系统中多个进程的周转时间的平均值</li>
<li>平均带权周转时间</li>
</ul>
</li>
<li>等待时间：进程处于等待状态的时间总和；</li>
<li>响应时间：用户提交请求到系统首次产生响应所用的时间</li>
</ul>
<h4 id="232-典型的调度算法">2.3.2 典型的调度算法</h4>
<ul>
<li>非抢占式的先来先服务（First Come First Severd, FCFS）算法</li>
<li>最短作业优先（Shortest Job First, SJF）算法</li>
<li>优先级调度算法
<ul>
<li>抢占式优先级调度算法</li>
<li>非抢占式优先级调度算法</li>
<li>静态优先级调度算法</li>
<li>动态优先级调度算法</li>
</ul>
</li>
<li>高响应比优先调度算法
<ul>
<li>响应比 R<sub>p</sub> = (等待时间 + 要求服务时间) / 要求服务时间</li>
</ul>
</li>
<li>时间片轮转调度算法</li>
<li>多级反馈队列调度算法
<ul>
<li>设置多个优先级、时间片大小不同的就绪队列</li>
<li>抢占式方式</li>
</ul>
</li>
</ul>
<h2 id="3-死锁及处理方法">3 死锁及处理方法</h2>
<p>死锁（Deadlock）指多道程序系统中并发执行的多个进程因争夺资源而造成一种若无外力则有关进程都将永远不能向前推进的僵持状态。</p>
<h3 id="31-死锁产生的原因">3.1 死锁产生的原因</h3>
<p>死锁产生的原因有：</p>
<ol>
<li>对不可剥夺资源的竞争</li>
<li>非法的进程推进顺序</li>
<li>死锁产生的四个必要条件
<ol>
<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
</li>
</ol>
<h3 id="32-死锁的处理策略">3.2 死锁的处理策略</h3>
<p>死锁的处理可从如下四个角度分析：</p>
<ol>
<li>预防死锁。即破坏产生死锁的必要条件</li>
<li>避免死锁。资源分配时利用某种算法防止系统进入不安全状态</li>
<li>检测死锁。动态检测系统中死锁的发生，定位相关进程和相关资源</li>
<li>解除死锁。检测到死锁发生后撤销或挂起某进程以回收资源和再分配</li>
</ol>
<h4 id="321-死锁的预防策略">3.2.1 死锁的预防策略</h4>
<p>预防死锁指破坏死锁产生的必要条件即“互斥”条件、“不可剥夺”条件、“请求和保持”条件和“循环等待”条件。<br>
“互斥”条件作为资源的固有属性，无法破坏；<br>
破坏“请求和保持”条件，即在进程运行前就分配全部需要资源，显然不合理；<br>
破坏“不可剥夺”条件，即进程请求某个资源得不到响应是释放已得到的资源，结果是系统效率极大降低；<br>
破坏“循环等待”条件，即位资源按类型线性排列，让进程的资源请求严格按这个次序，使系统扩展性变差且有资源浪费的可能。</p>
<h4 id="322-死锁的检测与解除">3.2.2 死锁的检测与解除</h4>
<h5 id="3221-资源分配图">3.2.2.1 资源分配图</h5>
<p>用资源分配图描述系统死锁。如图，P 指进程，R 指资源，P 指向 R 的弧称请求边，R 指向 P 的弧称分配边。<br>
下图表示 P1 进程分配到了两个 R1 资源，且正在申请一个 R2 资源；P2 进程分配到了一个 R1 资源和一个 R2 资源且正在申请一个 R1 资源：<br>
<img src="https://n1000g.github.io/post-images/1639696366105.png" alt="资源分配图" loading="lazy"></p>
<h5 id="3222-死锁定理">3.2.2.2 死锁定理</h5>
<p>系统状态 S 为死锁当且仅当该状态下的资源分配图不可完全化简。</p>
<h5 id="3221-死锁解除">3.2.2.1 死锁解除</h5>
<p>解除死锁的方法有：</p>
<ol>
<li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li>
<li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li>
<li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>
<h4 id="324-死锁的避免策略和银行家算法">3.2.4 死锁的避免策略和银行家算法</h4>
<p>死锁避免的基本思想是：运行进程动态地申请资源，但系统在进行资源分配前要进行安全性检查，当且仅当此次分配不会导致系统陷入不安全状态才分配，否则拒绝。</p>
<h5 id="3221-系统的安全状态">3.2.2.1 系统的安全状态</h5>
<p>所谓安全状态指系统可按某个进程序列 &lt;P1, P2, P3, P4&gt; 来为进程分配资源所需资源，直至每个进程对资源的最大需求使每个进程都能顺利完成。例：</p>
<p>某系统中有总计 12 个磁带机资源，当前可用资源量为 3 ，相关进程和资源分配情况如下表：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>需求</th>
<th>已分配（尚需）</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>10</td>
<td>5（5）</td>
</tr>
<tr>
<td>P2</td>
<td>4</td>
<td>2（2）</td>
</tr>
<tr>
<td>P3</td>
<td>9</td>
<td>2（7）</td>
</tr>
</tbody>
</table>
<p>则对 T0 时刻，系统中存在安全分配序列 &lt;P2, P1, P3&gt;；<br>
若 T0 时刻当前资源可用量为 2，系统找不到一个安全分配序列，称系统处于不安全状态。</p>
<p>不安全分配状态不一定发生死锁。</p>
<h5 id="3222-银行家算法">3.2.2.2 银行家算法</h5>
<p>银行家算法是最著名的死锁避免算法。<br>
银行家算法的数据结构描述：</p>
<ul>
<li>可用资源向量 Available</li>
<li>最大需求矩阵 Max</li>
<li>分配矩阵 Allocation</li>
<li>需求矩阵 Need</li>
<li>请求向量 Request</li>
</ul>
<p>银行家算法描述：<br>
<img src="https://n1000g.github.io/post-images/1639699328472.png" alt="银行家算法" loading="lazy"></p>
<p>安全性检测算法描述：<br>
<img src="https://n1000g.github.io/post-images/1639699353822.png" alt="安全性检查" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OS 基础课笔记】一、操作系统引论]]></title>
        <id>https://n1000g.github.io/post/f-vIjJNtK/</id>
        <link href="https://n1000g.github.io/post/f-vIjJNtK/">
        </link>
        <updated>2021-12-12T21:21:33.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="1-操作系统概述">1. 操作系统概述</h1>
<h2 id="11操作系统的概念和特征">1.1操作系统的概念和特征</h2>
<p>计算机系统的由软硬件共同组成，其中软件又可划分为应用软件和系统软件，操作系统（Operating System，OS）是配置在计算机硬件社上的第一层软件是对硬件系统的首次扩充。管理下层硬件设备，提高设备利用效率，并为上层用户程序提供方便的接口以操作硬件设备完成目标功能即是操作系统的主要功能。</p>
<p>操作系统的基本特征包括并发、共享、虚拟和异步。</p>
<ul>
<li>并发（Concurrence）指同一时间间隔内处理和调度多个程序的能力，主要通过分时得以实现；</li>
<li>共享（Sharing）指系统中资源可供多个并发执行的进程共享使用，包括互斥共享方式和同时访问方式；</li>
<li>虚拟（Virtual）指把一个物理上的实体抽象为若干个逻辑上的对应物，虚拟技术包括时分复用技术（如处理器的分时）和空分复用技术（如虚拟存储技术）；</li>
<li>异步（Asynchronism）指 OS 要保证多个并发执行的进程在同一个环境下多次运行后能获得相同的结果。</li>
</ul>
<h2 id="12-操作系统的目标和作用">1.2 操作系统的目标和作用</h2>
<p>操作系统的设计目标包括<strong>方便性</strong>、<strong>有效性</strong>、<strong>可扩充性</strong>和<strong>开放性</strong>。</p>
<ul>
<li>方便性即提供用户接口，使计算机更方便使用；</li>
<li>有效性即有效管理和分配软硬件资源以及合理组织计算机工作流程，以改善资源利用率提高系统吞吐量；</li>
<li>可扩充性是面向未来的，OS 应当适应计算机硬件和体系架构的迅猛发展及其对应的更高的功能和性能要求；</li>
<li>开放性指适应不同厂家与不同类型的计算机及其设备的网络化集成和协同工作，实现应用程序的可移植性和互操作性；</li>
</ul>
<p>操作系统在计算机系统中所起的作用，可从用户、资源管理和资源抽象等角度分析讨论。</p>
<ul>
<li>OS 是用户与计算机硬件系统之间的接口，包括面向一般用户的命令式、图形化接口和面向应用程序的<a href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">系统调用</a>接口；</li>
<li>OS 是系统资源的管理者，管理对象包括处理器、存储器、各类外围设备以及其信息（数据和软件），管理操作例如资源的分配回收、访问操作、共享保护等；</li>
<li>OS 实现了对计算机资源的抽象，例如为了方便用户使用 I/O 设备，人们在裸机上铺设一层 I/O 设备管理软件，隐藏具体细节并向用户提供一个对硬件设备操作的抽象模型，用户无需了解硬件物理接口等细节便可用该模型提供的抽象接口使用计算机硬件资源。同理，为了方便用户使用文件系统，可在第一层软件上再覆盖一层用于文件管理的软件，以此类推。由此可知，OS 是铺设在计算机硬件上的多层软件的集合。</li>
</ul>
<h1 id="2-操作系统层次模型">2. 操作系统层次模型</h1>
<p>笼统地说，操作系统层次模型分为三层，自底向上分别是操作系统对象、操作和管理有关对象的软件集合、用户接口：<br>
<img src="https://n1000g.github.io/post-images/1639348511445.png" alt="OS 层次模型 1" loading="lazy"><br>
对这个层次模型以 Linux 或 Unix 系统为例进行细化。由下至上，操作系统内核（Kernel）通过读写硬件接口实现对硬件资源的管理，然后应用程序或命令解释程序（外壳 Shell）通过内核提供的系统调用程序实现用户功能：<br>
<img src="https://n1000g.github.io/post-images/1639348723935.png" alt="OS 层次模型 2" loading="lazy"></p>
<h1 id="3-操作系统接口分类和组成">3. 操作系统接口分类和组成</h1>
<p>用户接口是系统和用户之间进行交互和信息交换的媒介，方便用户使用和管理计算机系统资源，基于接口表现形式可分为用户交互接口和用户程序接口，前者包括脱机/联机命令接口和图形化用户接口方便一般用户直接使用系统资源，后者方便用户程序访问系统资源，由一组系统调用组成。<br>
<img src="https://n1000g.github.io/post-images/1639511501081.jpg" alt="用户接口分类" loading="lazy"></p>
<h2 id="31-命令接口">3.1 命令接口</h2>
<p>按照作业控制方式的不同，可分为联机命令接口（交互式）和脱机命令接口（批处理），由命令解释程序（shell、cmd 等）控制执行。</p>
<blockquote>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></p>
</blockquote>
<h2 id="32-图形用户接口gui">3.2 图形用户接口（GUI）</h2>
<p>现代主流操作系统一般都提供 GUI，方便用户使用，以 Windows 为例，系统初始化后 OS 为终端用户生成一个名为 explorer.exe 的进程，它允许一个巨头窗口界面的命令解释程序，即所谓“桌面”。</p>
<h2 id="33-程序接口">3.3 程序接口</h2>
<p>程序接口是 OS 专门为用户程序设置的，供程序员编程使用，也是用户程序获取 OS 服务的唯一途径。它由一组系统调用（system call）组成。系统调用不仅可供所有应用程序使用，也可供 OS 自身使用，每个操作系统中通常有几十上百条系统调用，每条系统调用都是一个完成特定功能的子程序。</p>
<h3 id="331-系统调用的基本概念">3.3.1 系统调用的基本概念</h3>
<p>大多数计算机系统将 CPU 执行状态分为<strong>目态</strong>（核心态）与<strong>管态</strong>（用户态），CPU 的状态属于程序状态字 PSW 的一位，即系统模式（0）和用户模式（1），CPU 交替执行操作系统程序和用户程序。相应地，现代多数 OS 将 CPU 的指令集分为特权指令和非特权指令两类。前者指在系统态下运行的指令，为外设和内存的访问不受限制；后者是在用户态运行的指令，不能对系统硬件和软件直接访问，对内存的访问也限制在用户空间。</p>
<p>OS 提供系统调用的目的显而易见，即为用户程序提供调用 OS 内核中相关过程的手段，以获取 OS 内核的系统服务。系统调用本质是应用程序请求 OS 内核完成某个功能时的一种过程调用。</p>
<p>系统调用区别于一般过程调用的显著特征：</p>
<ul>
<li>调用程序运行在管态，被调用程序运行在目态；</li>
<li>涉及系统状态（CPU 状态）的转换；</li>
<li>返回问题，调用过程结束后不一定返回被调用过程；</li>
<li>嵌套调用，一般 OS 要设置最大嵌套深度。</li>
</ul>
<h3 id="332-系统调用的分类">3.3.2 系统调用的分类</h3>
<p>一般 OS 的系统调用可分为如下几大类：</p>
<ul>
<li>进程控制类
<ul>
<li>进程创建、结束、等待子进程结束</li>
<li>进程属性设置和获取</li>
<li>执行一个文件</li>
</ul>
</li>
<li>文件操纵类
<ul>
<li>文件创建、打开、关闭、读写等</li>
</ul>
</li>
<li>进程通信类
<ul>
<li>连接的打开关闭、消息的发送接收等</li>
</ul>
</li>
<li>系统信息的维护
<ul>
<li>时间的设置与获取等</li>
</ul>
</li>
</ul>
<h3 id="333-系统调用的实现机理">3.3.3 系统调用的实现机理</h3>
<p>系统调用是通过中断机制实现的，并且一个操作系统所有的系统调用都通过一个中断入口实现。在 Windows 操作系统中是 <code>int 0x21</code> 号中断，Linux 系统中是 <code>int 0x80</code> 号中断。与其他中断实现机制类似，以下是有关系统调用实现机理的数据结构和详细过程。</p>
<p>涉及的两个数据结构：</p>
<ul>
<li>中断向量表（interrupt vector table，IVT）——中断源的识别标志，提供中断类型号到中断处理程序的映射；</li>
<li>系统调用表（sys_call_table）——系统调用号到对应的系统过程映射。</li>
</ul>
<p>实现流程（以 Linux 为例）：</p>
<ol>
<li>用户进程形成一个系统调用号（送入 EAX 寄存器）和参数（送入参数表），执行系统调用命令并触发 <code>int 0x80</code> 号中断；</li>
<li>中断总控模块处理 128 号中断，跳到它的中断处理程序（即系统调用总控模块）；
<ol>
<li>切换处理机状态（核心态 → 用户态）；</li>
<li>由硬件和内核程序进行系统调用的一般性处理，即保护 CPU 现场，保存用户定义的参数；</li>
</ol>
</li>
<li>终端总控模块查系统调用表并转到对应的系统调用处理子程序；</li>
<li>恢复 CPU 现场返回被中断进程或设置新的 CPU 现场转入新进程。</li>
</ol>
<blockquote>
<p><strong>外中断与内中断</strong>——中断也称外中断、硬中断，由来自 CPU 执行指令以外的发生事件造成，通常来自外设请求，中断号由中断控制器提供；内中断也称异常、陷入、软中断，源自 CPU 指令内部事件如缺页指令、非法操作码、地址越界、Linux 1、2、3、128 号中断等，中断号由指令直接指出，无需使用中断控制器。</p>
</blockquote>
<h2 id="34-linux-系统调用">3.4 Linux 系统调用</h2>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1492374">Linux syscall过程分析（万字长文）</a><br>
<a href="https://docs.huihoo.com/joyfire.net/6-1.html#I452">https://docs.huihoo.com/joyfire.net/6-1.html#I452</a></p>
</blockquote>
<h1 id="4-操作系统的发展与演化">4. 操作系统的发展与演化</h1>
<figure data-type="image" tabindex="1"><img src="https://n1000g.github.io/post-images/1639520072572.jpg" alt="OS 的发展与演化" loading="lazy"></figure>
<ul>
<li>批处理系统——作业先进入磁盘再调入进内存
<ul>
<li>单道批处理系统——把一批作业脱机方式输入磁带上，在所系统配置的监督程序控制下依次连续处理</li>
<li>多道批处理系统——用作业调度算法分配资源，具有多道性、无序性、调度性</li>
</ul>
</li>
<li>分时系统——一台主机、多个终端、多个用户同时以交互方式使用、作业直接进入内存、按时间片轮转策略分配处理机，具有多路性、独立性、及时性和交互性</li>
<li>实时系统——及时响应外部事件请求并能控制所有事实任务协调一致地运行，相对分时系统，系统高度可靠</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPA Criteria Queries]]></title>
        <id>https://n1000g.github.io/post/hfZT72Yi5/</id>
        <link href="https://n1000g.github.io/post/hfZT72Yi5/">
        </link>
        <updated>2021-07-26T05:08:58.000Z</updated>
        <summary type="html"><![CDATA[<p>摘译自 <a href="https://www.baeldung.com/hibernate-criteria-queries#Criteria">baeldung</a><br>
条件查询（Criteria Query）是 JPA 的一个重要特性。自 Hibernate 5.2 以后，Hibernate Criteria API 被官方声明为弃用方法，转而推荐使用 JPA Criteria API。本教程将围绕如何使用 Hibernate 和 JPA 来构建 Criteria Queries 展开讨论。</p>
]]></summary>
        <content type="html"><![CDATA[<p>摘译自 <a href="https://www.baeldung.com/hibernate-criteria-queries#Criteria">baeldung</a><br>
条件查询（Criteria Query）是 JPA 的一个重要特性。自 Hibernate 5.2 以后，Hibernate Criteria API 被官方声明为弃用方法，转而推荐使用 JPA Criteria API。本教程将围绕如何使用 Hibernate 和 JPA 来构建 Criteria Queries 展开讨论。</p>
<!-- more -->
<h2 id="1-概述">1. 概述</h2>
<p>在本教程中，我们将讨论一个非常有用的 JPA 特性——条件查询。</p>
<p>它不仅使我们能够在不使用纯 SQL 的情况下编写查询，而且还为查询提供了一些面向对象的控制，这也即 Hibernate 的主要特性之一。Criteria API 允许我们以编程的方式构建一个应用不同的过滤规则和逻辑条件的 Criteria 查询对象。</p>
<p>从Hibernate 5.2开始，Hibernate Criteria API 就被弃用了，新的开发集中在 JPA Criteria API 上。我们将探索如何使用 Hibernate 和 JPA 来构建 Criteria Queries。</p>
<h2 id="2-maven-依赖">2. Maven 依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;   
    &lt;version&gt;5.3.2.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="3-简单示例">3. 简单示例</h2>
<p>我们以如何从数据库中获取特定类（Item）的所有实例为例：</p>
<pre><code class="language-java">public class Item implements Serializable {

    private Integer itemId;
    private String itemName;
    private String itemDescription;
    private Integer itemPrice;

   // standard setters and getters
}
</code></pre>
<p>它的 Criteria Query 如下：</p>
<pre><code class="language-java">public List&lt;T&gt; getAll() {
    Session session = HibernateUtil.getHibernateSession();
    CriteriaBuilder cb = session.getCriteriaBuilder();
    CriteriaQuery&lt;Item&gt; cr = cb.createQuery(Item.class);
    Root&lt;Item&gt; root = cr.from(Item.class);
    cr.select(root);
    Query&lt;Item&gt; query = session.createQuery(cr);
    return query.getResultList();
}
</code></pre>
<p>上面的查询是如何获取所有项的简单演示。让我们一步一步来看看我们做了什么：</p>
<ol>
<li>从 SessionFactory 对象创建一个 Session 实例</li>
<li>通过调用 getCriteriaBuilder() 方法创建一个 CriteriaBuilder 实例</li>
<li>通过调用 CriteriaBuilder 的 createQuery()方法创建一个 CriteriaQuery 实例</li>
<li>通过调用 Session 的 createQuery() 方法创建 Query 的实例</li>
<li>调用查询对象的getResultList()方法，它将给出结果</li>
</ol>
<pre><code class="language-mermaid">graph LR;
    SessionFactory --&gt; Session;
    Session --&gt; CriteriaBuilder;
    subgraph build criteriaQuery;
    	CriteriaBuilder --Item.class--&gt; CriteriaQuery;
    	Root --Item.class--&gt; CriteriaQuery;
    end;
    CriteriaQuery --&gt; Query;
    Query --&gt; results;
</code></pre>
<p>现在我们已经介绍了基础知识，让我们继续了解条件查询的一些特性:</p>
<h3 id="31-expressions">3.1 Expressions</h3>
<p>CriteriaBuilder 可用于基于特定条件限制查询结果：</p>
<h4 id="where-子句">Where 子句</h4>
<pre><code class="language-java">// where itemPrice &gt; 1000
cr.select(root).where(cb.gt(root.get(&quot;itemPrice&quot;), 1000));
// where itemPrice &lt; 1000
cr.select(root).where(cb.lt(root.get(&quot;itemPrice&quot;), 1000));
// Items having itemName contain Chair
cr.select(root).where(cb.like(root.get(&quot;itemName&quot;), &quot;%chair%&quot;));
// To check if the given property is not null:
cr.select(root).where(cb.isNotNull(root.get(&quot;itemDescription&quot;)));
</code></pre>
<h4 id="表达式链">表达式链</h4>
<pre><code class="language-java">Predicate[] predicates = new Predicate[2];
predicates[0] = cb.isNull(root.get(&quot;itemDescription&quot;));
predicates[1] = cb.like(root.get(&quot;itemName&quot;), &quot;chair%&quot;);
cr.select(root).where(predicates);
// or
cr.select(root).where(cb.or(predicates[0], predicates[1]));
// and
cr.select(root).where(cb.and(predicates[0], predicates[1]));
</code></pre>
<h3 id="32-sorting">3.2 Sorting</h3>
<pre><code class="language-java">cr.orderBy(
  cb.asc(root.get(&quot;itemName&quot;)), 
  cb.desc(root.get(&quot;itemPrice&quot;)));
</code></pre>
<h3 id="33-projections-aggregates-and-grouping-functions">3.3 Projections, Aggregates, and Grouping Functions</h3>
<pre><code class="language-java">cr.select(cb.count(root));
cr.select(cb.avg(root.get(&quot;itemPrice&quot;)));
</code></pre>
<h3 id="34-criteriaupdate">3.4 CriteriaUpdate</h3>
<p>CriteriaUpdate 有一个 set() 方法，可以用来为数据库记录提供新值:</p>
<pre><code class="language-java">CriteriaUpdate&lt;Item&gt; criteriaUpdate = cb.createCriteriaUpdate(Item.class);Root&lt;Item&gt; root = criteriaUpdate.from(Item.class);criteriaUpdate.set(&quot;itemPrice&quot;, newPrice);criteriaUpdate.where(cb.equal(root.get(&quot;itemPrice&quot;), oldPrice));Transaction transaction = session.beginTransaction();session.createQuery(criteriaUpdate).executeUpdate();transaction.commit();
</code></pre>
<h3 id="35-criteriadelete">3.5 CriteriaDelete</h3>
<pre><code class="language-java">CriteriaDelete&lt;Item&gt; criteriaDelete = cb.createCriteriaDelete(Item.class);Root&lt;Item&gt; root = criteriaDelete.from(Item.class);criteriaDelete.where(cb.greaterThan(root.get(&quot;itemPrice&quot;), targetPrice));Transaction transaction = session.beginTransaction();session.createQuery(criteriaDelete).executeUpdate();transaction.commit();
</code></pre>
<h2 id="相对-hql-的优势">相对 HQL 的优势</h2>
<ul>
<li><strong>Object Oriented</strong></li>
<li>flexible</li>
<li>type-safety</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python 数据处理脚本的通用设计]]></title>
        <id>https://n1000g.github.io/post/zIn7XAv_S/</id>
        <link href="https://n1000g.github.io/post/zIn7XAv_S/">
        </link>
        <updated>2021-07-20T12:08:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用库">常用库</h2>
<h3 id="pymysql"><a href="https://pymysql.readthedocs.io/en/latest/">PyMySQL</a></h3>
<pre><code class="language-python">import pymysql
# 连接
connection = pymysql.connect(host, user, password, db, port, charset, 
cursorclass=pymysql.cursors.DictCursor)
cursor = connection.cursor()
# 处理
cursor.execute(sql)
res = cursor.fetchall()  # 查询语句需要 fetch 后 才能执行下一次查询
# connection.commit()  # 修改语句需要 commit  后 才能执行下一次查询
# 关闭
cursor.close()
connection.close()
</code></pre>
<h3 id="openpyxl"><a href="https://openpyxl.readthedocs.io/en/stable/">openpyxl</a></h3>
<p><strong>写</strong></p>
<pre><code class="language-python">from openpyxl import Workbook

workbook = Workbook()
sheet = workbook.active
sheet['A1'] = 42
sheet.append([1, 2, 3])
sheet['A2'] = datetime.datetime.now()
workbook.save(&quot;sample.xlsx&quot;)
</code></pre>
<p><strong>读</strong></p>
<pre><code class="language-python">from openpyxl import load_workbook

workbook = load_workbook(&quot;excelfile.xlsx&quot;)
sheets = workbook.sheetnames
sheet = workbook[sheets[0]]  # sheet = workbook.active

for row in sheet.rows:
    val = row[0].value
    print(val)
</code></pre>
<h2 id="几个较常用的-sql-写法">几个较常用的 SQL 写法</h2>
<p>编写代码相对十分耗时且极易出错，复杂度不太高的任务可以用数据库客户端直接解决，总结下一些如按字段讨论、列连接成行的 SQL 写法</p>
<h3 id="按字段讨论">按字段讨论</h3>
<p>之前业务升级某些数据前端不再展示，运营要统计某机构下学生离校时间，但这个时间在一张表不同字段表示，正常结课的课程用 <code>closed_time</code>，学生删除的用 <code>dropped_time</code>，班级删除的用 <code>delete_time</code>，</p>
<pre><code class="language-sql">SELECT id AS '学生id', create_time AS '入校时间',(
	CASE `status` 
	WHEN 40 OR 24 THEN dropped_time
	WHEN -1 THEN closed_time 
	WHEN 16 THEN dropped_time
	END
) AS '离校时间'
FROM class_student WHERE org_id={0}
</code></pre>
<h3 id="多列数据连接成行展示">多列数据连接成行展示</h3>
<p>如下是统计某一机构下每个班级的学生，要求按班级分类</p>
<pre><code class="language-sql">SELECT org_id, class_id, GROUP_CONCAT(student_id ORDER BY student_id)
FROM (
	SELECT *
	FROM class_student
	WHERE org_id=2619
) t
GROUP BY class_id
</code></pre>
<h2 id="按路径获取文件">按路径获取文件</h2>
<p>由于系统路径分隔符不一致 Windows 下使用正斜杠分割路径如 <code>C:\Users\n8g\Desktop</code>，Linux 下则使用反斜杠分割路径如 <code>~/Documents</code>，于是在涉及读写本地文件需求相关的操作时，就要考虑代码的通用性，一个较不成熟的解决方案是用 python 标准库 os 做路径拼接处理</p>
<pre><code class="language-python">FILE_FOLDER = os.getcwd()  # 当前工作路径
FILE_NAME = &quot;file_to_process.abc&quot;  # 待处理文件
fo = open(os.path.join(FILE_FOLDER, FILE_NAME), 'r')
...
</code></pre>
<p>多文件</p>
<pre><code class="language-python">file_name_list = os.listdir(FILE_FOLDER)
for fname in file_name_list:
    file_abs_path = os.path.join(FILE_FOLDER, f_name)
    fo = open(file_abs_path)
    ...
...
</code></pre>
]]></content>
    </entry>
</feed>