<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://n1000g.github.io</id>
    <title>n1000g</title>
    <updated>2021-12-15T17:28:45.561Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://n1000g.github.io"/>
    <link rel="self" href="https://n1000g.github.io/atom.xml"/>
    <subtitle>早日成长为一只老攻城狮</subtitle>
    <logo>https://n1000g.github.io/images/avatar.png</logo>
    <icon>https://n1000g.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, n1000g</rights>
    <entry>
        <title type="html"><![CDATA[【OS 基础课笔记】一、操作系统引论]]></title>
        <id>https://n1000g.github.io/post/f-vIjJNtK/</id>
        <link href="https://n1000g.github.io/post/f-vIjJNtK/">
        </link>
        <updated>2021-12-12T21:21:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="-more-"><!-- more --></h2>
<h1 id="操作系统概述">操作系统概述</h1>
<h2 id="操作系统的概念和特征">操作系统的概念和特征</h2>
<p>计算机系统的由软硬件共同组成，其中软件又可划分为应用软件和系统软件，操作系统（Operating System，OS）是配置在计算机硬件社上的第一层软件是对硬件系统的首次扩充。管理下层硬件设备，提高设备利用效率，并为上层用户程序提供方便的接口以操作硬件设备完成目标功能即是操作系统的主要功能。</p>
<p>操作系统的基本特征包括并发、共享、虚拟和异步。</p>
<ul>
<li>并发（Concurrence）指同一时间间隔内处理和调度多个程序的能力，主要通过分时得以实现；</li>
<li>共享（Sharing）指系统中资源可供多个并发执行的进程共享使用，包括互斥共享方式和同时访问方式；</li>
<li>虚拟（Virtual）指把一个物理上的实体抽象为若干个逻辑上的对应物，虚拟技术包括时分复用技术（如处理器的分时）和空分复用技术（如虚拟存储技术）；</li>
<li>异步（Asynchronism）指 OS 要保证多个并发执行的进程在同一个环境下多次运行后能获得相同的结果。</li>
</ul>
<h2 id="操作系统的目标和作用">操作系统的目标和作用</h2>
<p>操作系统的设计目标包括方便性、有效性、可扩充性和开放性。</p>
<ul>
<li>方便性即提供用户接口，使计算机更方便使用；</li>
<li>有效性即有效管理和分配软硬件资源以及合理组织计算机工作流程，以改善资源利用率提高系统吞吐量；</li>
<li>可扩充性是面向未来的，OS 应当适应计算机硬件和体系架构的迅猛发展及其对应的更高的功能和性能要求；</li>
<li>开放性指适应不同厂家与不同类型的计算机及其设备的网络化集成和协同工作，实现应用程序的可移植性和互操作性；</li>
</ul>
<p>操作系统在计算机系统中所起的作用，可从用户、资源管理和资源抽象等角度分析讨论。</p>
<ul>
<li>OS 是用户与计算机硬件系统之间的接口，包括面向一般用户的命令式、图形化接口和面向应用程序的<a href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">系统调用</a>接口；</li>
<li>OS 是系统资源的管理者，管理对象包括处理器、存储器、各类外围设备以及其信息（数据和软件），管理操作例如资源的分配回收、访问操作、共享保护等；</li>
<li>OS 实现了对计算机资源的抽象，例如为了方便用户使用 I/O 设备，人们在裸机上铺设一层 I/O 设备管理软件，隐藏具体细节并向用户提供一个对硬件设备操作的抽象模型，用户无需了解硬件物理接口等细节便可用该模型提供的抽象接口使用计算机硬件资源。同理，为了方便用户使用文件系统，可在第一层软件上再覆盖一层用于文件管理的软件，以此类推。由此可知，OS 是铺设在计算机硬件上的多层软件的集合。</li>
</ul>
<h1 id="操作系统层次模型">操作系统层次模型</h1>
<p>笼统地说，操作系统层次模型分为三层，自底向上分别是操作系统对象、操作和管理有关对象的软件集合、用户接口：<br>
<img src="https://n1000g.github.io/post-images/1639348511445.png" alt="OS 层次模型 1" loading="lazy"><br>
对这个层次模型以 Linux 或 Unix 系统为例进行细化。由下至上，操作系统内核（Kernel）通过读写硬件接口实现对硬件资源的管理，然后应用程序或命令解释程序（外壳 Shell）通过内核提供的系统调用程序实现用户功能：<br>
<img src="https://n1000g.github.io/post-images/1639348723935.png" alt="OS 层次模型 2" loading="lazy"></p>
<h1 id="操作系统接口分类和组成">操作系统接口分类和组成</h1>
<p>用户接口是系统和用户之间进行交互和信息交换的媒介，方便用户使用和管理计算机系统资源，基于接口表现形式可分为用户交互接口和用户程序接口，前者包括脱机/联机命令接口和图形化用户接口方便一般用户直接使用系统资源，后者方便用户程序访问系统资源，由一组系统调用组成。<br>
<img src="https://n1000g.github.io/post-images/1639511501081.jpg" alt="用户接口分类" loading="lazy"></p>
<h2 id="命令接口">命令接口</h2>
<!-- more -->
<p>按照作业控制方式的不同，分为联机命令接口（交互式）和脱机命令接口（批处理），由命令解释程序（shell、cmd 等）控制执行，下图为 Linux Shell 的执行流程：</p>
<h2 id="图形用户接口gui">图形用户接口（GUI）</h2>
<p>现代主流操作系统一般都提供 GUI，方便用户使用，以 Windows 为例，系统初始化后 OS 为终端用户生成一个名为 explorer.exe 的进程，它允许一个巨头窗口界面的命令解释程序，即所谓“桌面”。</p>
<h2 id="程序接口">程序接口</h2>
<p>程序接口是 OS 专门为用户程序设置的，供程序员编程使用，也是用户程序获取 OS 服务的唯一途径。它由一组系统调用（system call）组成。系统调用不仅可供所有应用程序使用，也可供 OS 自身使用，每个操作系统中通常有几十上百条系统调用，每条系统调用都是一个完成特定功能的子程序。</p>
<h3 id="系统调用的基本概念">系统调用的基本概念</h3>
<p>大多数计算机系统将 CPU 执行状态分为<strong>目态</strong>（核心态）与<strong>管态</strong>（用户态），CPU 的状态属于程序状态字 PSW 的一位，即系统模式（0）和用户模式（1），CPU 交替执行操作系统程序和用户程序。相应地，现代多数 OS 将 CPU 的指令集分为特权指令和非特权指令两类。前者指在系统态下运行的指令，为外设和内存的访问不受限制；后者是在用户态运行的指令，不能对系统硬件和软件直接访问，对内存的访问也限制在用户空间。</p>
<p>OS 提供系统调用的目的显而易见，即为用户程序提供调用 OS 内核中相关过程的手段，以获取 OS 内核的系统服务。系统调用本质是应用程序请求 OS 内核完成某个功能时的一种过程调用。</p>
<p>系统调用区别于一般过程调用的显著特征：</p>
<ul>
<li>调用程序运行在管态，被调用程序运行在目态；</li>
<li>涉及系统状态（CPU 状态）的转换；</li>
<li>返回问题，调用过程结束后不一定返回被调用过程；</li>
<li>嵌套调用，一般 OS 要设置最大嵌套深度。</li>
</ul>
<h3 id="系统调用的分类">系统调用的分类</h3>
<p>一般 OS 的系统调用可分为如下几大类：</p>
<ul>
<li>进程控制类
<ul>
<li>进程创建、结束、等待子进程结束</li>
<li>进程属性设置和获取</li>
<li>执行一个文件</li>
</ul>
</li>
<li>文件操纵类
<ul>
<li>文件创建、打开、关闭、读写等</li>
</ul>
</li>
<li>进程通信类
<ul>
<li>连接的打开关闭、消息的发送接收等</li>
</ul>
</li>
<li>系统信息的维护
<ul>
<li>时间的设置与获取等</li>
</ul>
</li>
</ul>
<h3 id="系统调用的实现机理">系统调用的实现机理</h3>
<p>系统调用是通过中断机制实现的，并且一个操作系统所有的系统调用都通过一个中断入口实现。在 Windows 操作系统中是 <code>int 0x21</code> 号中断，Linux 系统中是 <code>int 0x80</code> 号中断。与其他中断实现机制类似，以下是有关系统调用实现机理的数据结构和详细过程。</p>
<p>涉及的两个数据结构：</p>
<ul>
<li>中断向量表（interrupt vector table，IVT）——中断源的识别标志，提供中断类型号到中断处理程序的映射；</li>
<li>系统调用表（sys_call_table）——系统调用号到对应的系统过程映射。</li>
</ul>
<p>实现流程（以 Linux 为例）：</p>
<ol>
<li>用户进程形成一个系统调用号（送入 EAX 寄存器）和参数（送入参数表），执行系统调用命令并触发 <code>int 0x80</code> 号中断；</li>
<li>中断总控模块处理 128 号中断，跳到它的中断处理程序（即系统调用总控模块）；
<ol>
<li>切换处理机状态（核心态 → 用户态）；</li>
<li>由硬件和内核程序进行系统调用的一般性处理，即保护 CPU 现场，保存用户定义的参数；</li>
</ol>
</li>
<li>终端总控模块查系统调用表并转到对应的系统调用处理子程序；</li>
<li>恢复 CPU 现场返回被中断进程或设置新的 CPU 现场转入新进程。</li>
</ol>
<blockquote>
<p><strong>外中断与内中断</strong>——中断也称外中断、硬中断，由来自 CPU 执行指令以外的发生事件造成，通常来自外设请求，中断号由中断控制器提供；内中断也称异常、陷入、软中断，源自 CPU 指令内部事件如缺页指令、非法操作码、地址越界、Linux 1、2、3、128 号中断等，中断号由指令直接指出，无需使用中断控制器。</p>
</blockquote>
<h2 id="linux-系统调用">Linux 系统调用</h2>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1492374">Linux syscall过程分析（万字长文）</a><br>
<a href="https://docs.huihoo.com/joyfire.net/6-1.html#I452">https://docs.huihoo.com/joyfire.net/6-1.html#I452</a></p>
</blockquote>
<h1 id="操作系统的发展与演化">操作系统的发展与演化</h1>
<figure data-type="image" tabindex="1"><img src="https://n1000g.github.io/post-images/1639520072572.jpg" alt="" loading="lazy"></figure>
<ul>
<li>批处理系统——作业先进入磁盘再调入进内存
<ul>
<li>单道批处理系统——把一批作业脱机方式输入磁带上，在所系统配置的监督程序控制下依次连续处理</li>
<li>多道批处理系统——用作业调度算法分配资源，具有多道性、无序性、调度性</li>
</ul>
</li>
<li>分时系统——一台主机、多个终端、多个用户同时以交互方式使用、作业直接进入内存、按时间片轮转策略分配处理机，具有多路性、独立性、及时性和交互性</li>
<li>实时系统——及时响应外部事件请求并能控制所有事实任务协调一致地运行，相对分时系统，系统高度可靠</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ @Import vs @ComponentScan]]></title>
        <id>https://n1000g.github.io/post/WFejoTCZs/</id>
        <link href="https://n1000g.github.io/post/WFejoTCZs/">
        </link>
        <updated>2021-07-26T13:03:16.000Z</updated>
        <summary type="html"><![CDATA[<p>译自<a href="https://www.baeldung.com/spring-import-annotation">baeldung</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>译自<a href="https://www.baeldung.com/spring-import-annotation">baeldung</a></p>
<!-- more -->
<h2 id="similarities">Similarities</h2>
<p>两者都可以接收任何 <code>@Component</code> 或 <code>@Configuration</code> 注解的类（Bean 和配置类）</p>
<p>下面是使用 <code>@Import</code> 注册 Bean 的例子：</p>
<pre><code class="language-java">@Configuration
@Import(Bug.class)
class BugConfig {
}

@Component(value = &quot;bug&quot;)
class Bug {
}
</code></pre>
<h2 id="conceptual-sup概念上的sup-difference">Conceptual <sup>概念上的</sup> Difference</h2>
<p>简单地说，我们可以用这两个注释得到相同的结果。那么，它们之间有什么区别？</p>
<p>要回答这个问题，让我们记住 Spring 通常提倡约定高于配置的方法。</p>
<p>与我们的注释进行类比，<code>@ComponentScan</code> 更像是约定，而 <code>@Import</code> 更像是配置。</p>
<h2 id="what-happens-in-real-applications">What Happens in Real Applications</h2>
<p>通常，我们在根包中使用 <code>@ComponentScan</code> 启动应用程序，这样它就可以为我们找到所有组件。正如 Spring Boot 中 <code>@SpringBootApplication</code> 已经包含了 <code>@ComponentScan</code>。这显示了约定的力量。<br>
现在，让我们假设我们的应用程序扩展了很多。现在我们需要处理来自所有不同地方的 bean，比如组件、不同的包结构，以及我们自己和第三方构建的模块。<br>
在这种情况下，将所有内容添加到上下文可能会引发关于使用哪个bean的冲突。除此之外，我们的启动时间可能会比较慢。另一方面，我们也不想为每个新组件都写一个 <code>@Import</code>，因为这样做会适得其反。<br>
以我们的动物为例。我们确实可以在上下文声明中隐藏导入，但是我们仍然需要记住每个 Config 类的 <code>@Import</code>。</p>
<h2 id="working-together">Working Together</h2>
<p>我们也可以以兼顾两者为目标。试想，我们有一个只包含 animals 的包（或组件或模块等等）。</p>
<p>这个包上有一个 <code>@ComponentScan</code> 注解</p>
<pre><code class="language-java">package com.baeldung.importannotation.animal;

// imports...

@Configuration
@ComponentScan
public class AnimalScanConfiguration {
}
</code></pre>
<p>和一个 <code>@Import</code> 注解用于控制我们要添加到上下文的信息</p>
<pre><code class="language-java">package com.baeldung.importannotation.zoo;

// imports...

@Configuration
@Import(AnimalScanConfiguration.class)
class ZooApplication {
}
</code></pre>
<p>最后，添加到动物包中的任何新 bean 都将由上下文自动找到。我们仍然可以明确地控制我们所使用的构型。</p>
<h2 id="conclusion">Conclusion</h2>
<p>*<strong>@Import* is very</strong> <strong>similar to @*ComponentScan*</strong>, except for the fact that <strong>@*Import* has an explicit approach while @*ComponentScan* uses an implicit one</strong>.</p>
<p><a href="https://github.com/eugenp/tutorials/tree/master/spring-core-4">示例项目地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPA Criteria Queries]]></title>
        <id>https://n1000g.github.io/post/hfZT72Yi5/</id>
        <link href="https://n1000g.github.io/post/hfZT72Yi5/">
        </link>
        <updated>2021-07-26T05:08:58.000Z</updated>
        <summary type="html"><![CDATA[<p>摘译自 <a href="https://www.baeldung.com/hibernate-criteria-queries#Criteria">baeldung</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>摘译自 <a href="https://www.baeldung.com/hibernate-criteria-queries#Criteria">baeldung</a></p>
<!-- more -->
<hr>
<h2 id="1-概述">1. 概述</h2>
<p>在本教程中，我们将讨论一个非常有用的 JPA 特性——标准查询。</p>
<p>它不仅使我们能够在不使用纯 SQL 的情况下编写查询，而且还为查询提供了一些面向对象的控制，这也即 Hibernate 的主要特性之一。Criteria API 允许我们以编程的方式构建一个应用不同的过滤规则和逻辑条件的 Criteria 查询对象。</p>
<p>从Hibernate 5.2开始，Hibernate Criteria API 就被弃用了，新的开发集中在 JPA Criteria API 上。我们将探索如何使用Hibernate和JPA来构建Criteria Queries。</p>
<h2 id="2-maven-依赖">2. Maven 依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;   
    &lt;version&gt;5.3.2.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="3-简单示例">3. 简单示例</h2>
<p>我们以如何从数据库中获取特定类（Item）的所有实例为例：</p>
<pre><code class="language-java">public class Item implements Serializable {

    private Integer itemId;
    private String itemName;
    private String itemDescription;
    private Integer itemPrice;

   // standard setters and getters
}
</code></pre>
<p>它的 Criteria Query 如下：</p>
<pre><code class="language-java">public List&lt;T&gt; getAll() {
    Session session = HibernateUtil.getHibernateSession();
    CriteriaBuilder cb = session.getCriteriaBuilder();
    CriteriaQuery&lt;Item&gt; cr = cb.createQuery(Item.class);
    Root&lt;Item&gt; root = cr.from(Item.class);
    cr.select(root);
    Query&lt;Item&gt; query = session.createQuery(cr);
    return query.getResultList();
}
</code></pre>
<p>上面的查询是如何获取所有项的简单演示。让我们一步一步来看看我们做了什么：</p>
<ol>
<li>从 SessionFactory 对象创建一个 Session 实例</li>
<li>通过调用 getCriteriaBuilder() 方法创建一个 CriteriaBuilder 实例</li>
<li>通过调用 CriteriaBuilder 的 createQuery()方法创建一个 CriteriaQuery 实例</li>
<li>通过调用 Session 的 createQuery() 方法创建 Query 的实例</li>
<li>调用查询对象的getResultList()方法，它将给出结果</li>
</ol>
<pre><code class="language-mermaid">graph LR;
    SessionFactory --&gt; Session;
    Session --&gt; CriteriaBuilder;
    subgraph build criteriaQuery;
    	CriteriaBuilder --Item.class--&gt; CriteriaQuery;
    	Root --Item.class--&gt; CriteriaQuery;
    end;
    CriteriaQuery --&gt; Query;
    Query --&gt; results;
</code></pre>
<p>现在我们已经介绍了基础知识，让我们继续了解条件查询的一些特性:</p>
<h3 id="31-expressions">3.1 Expressions</h3>
<p>CriteriaBuilder 可用于基于特定条件限制查询结果：</p>
<h4 id="where-子句">Where 子句</h4>
<pre><code class="language-java">// where itemPrice &gt; 1000
cr.select(root).where(cb.gt(root.get(&quot;itemPrice&quot;), 1000));
// where itemPrice &lt; 1000
cr.select(root).where(cb.lt(root.get(&quot;itemPrice&quot;), 1000));
// Items having itemName contain Chair
cr.select(root).where(cb.like(root.get(&quot;itemName&quot;), &quot;%chair%&quot;));
// To check if the given property is not null:
cr.select(root).where(cb.isNotNull(root.get(&quot;itemDescription&quot;)));
</code></pre>
<h4 id="表达式链">表达式链</h4>
<pre><code class="language-java">Predicate[] predicates = new Predicate[2];
predicates[0] = cb.isNull(root.get(&quot;itemDescription&quot;));
predicates[1] = cb.like(root.get(&quot;itemName&quot;), &quot;chair%&quot;);
cr.select(root).where(predicates);
// or
cr.select(root).where(cb.or(predicates[0], predicates[1]));
// and
cr.select(root).where(cb.and(predicates[0], predicates[1]));
</code></pre>
<h3 id="32-sorting">3.2 Sorting</h3>
<pre><code class="language-java">cr.orderBy(
  cb.asc(root.get(&quot;itemName&quot;)), 
  cb.desc(root.get(&quot;itemPrice&quot;)));
</code></pre>
<h3 id="33-projections-aggregates-and-grouping-functions">3.3 Projections, Aggregates, and Grouping Functions</h3>
<pre><code class="language-java">cr.select(cb.count(root));
cr.select(cb.avg(root.get(&quot;itemPrice&quot;)));
</code></pre>
<h3 id="34-criteriaupdate">3.4 CriteriaUpdate</h3>
<p>CriteriaUpdate 有一个 set() 方法，可以用来为数据库记录提供新值:</p>
<pre><code class="language-java">CriteriaUpdate&lt;Item&gt; criteriaUpdate = cb.createCriteriaUpdate(Item.class);Root&lt;Item&gt; root = criteriaUpdate.from(Item.class);criteriaUpdate.set(&quot;itemPrice&quot;, newPrice);criteriaUpdate.where(cb.equal(root.get(&quot;itemPrice&quot;), oldPrice));Transaction transaction = session.beginTransaction();session.createQuery(criteriaUpdate).executeUpdate();transaction.commit();
</code></pre>
<h3 id="35-criteriadelete">3.5 CriteriaDelete</h3>
<pre><code class="language-java">CriteriaDelete&lt;Item&gt; criteriaDelete = cb.createCriteriaDelete(Item.class);Root&lt;Item&gt; root = criteriaDelete.from(Item.class);criteriaDelete.where(cb.greaterThan(root.get(&quot;itemPrice&quot;), targetPrice));Transaction transaction = session.beginTransaction();session.createQuery(criteriaDelete).executeUpdate();transaction.commit();
</code></pre>
<h2 id="相对-hql-的优势">相对 HQL 的优势</h2>
<ul>
<li><strong>Object Oriented</strong></li>
<li>flexible</li>
<li>type-safety</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python 数据处理脚本的通用设计]]></title>
        <id>https://n1000g.github.io/post/zIn7XAv_S/</id>
        <link href="https://n1000g.github.io/post/zIn7XAv_S/">
        </link>
        <updated>2021-07-20T12:08:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用库">常用库</h2>
<h3 id="pymysql"><a href="https://pymysql.readthedocs.io/en/latest/">PyMySQL</a></h3>
<pre><code class="language-python">import pymysql
# 连接
connection = pymysql.connect(host, user, password, db, port, charset, 
cursorclass=pymysql.cursors.DictCursor)
cursor = connection.cursor()
# 处理
cursor.execute(sql)
res = cursor.fetchall()  # 查询语句需要 fetch 后 才能执行下一次查询
# connection.commit()  # 修改语句需要 commit  后 才能执行下一次查询
# 关闭
cursor.close()
connection.close()
</code></pre>
<h3 id="openpyxl"><a href="https://openpyxl.readthedocs.io/en/stable/">openpyxl</a></h3>
<p><strong>写</strong></p>
<pre><code class="language-python">from openpyxl import Workbook

workbook = Workbook()
sheet = workbook.active
sheet['A1'] = 42
sheet.append([1, 2, 3])
sheet['A2'] = datetime.datetime.now()
workbook.save(&quot;sample.xlsx&quot;)
</code></pre>
<p><strong>读</strong></p>
<pre><code class="language-python">from openpyxl import load_workbook

workbook = load_workbook(&quot;excelfile.xlsx&quot;)
sheets = workbook.sheetnames
sheet = workbook[sheets[0]]  # sheet = workbook.active

for row in sheet.rows:
    val = row[0].value
    print(val)
</code></pre>
<h2 id="几个较常用的-sql-写法">几个较常用的 SQL 写法</h2>
<p>编写代码相对十分耗时且极易出错，复杂度不太高的任务可以用数据库客户端直接解决，总结下一些如按字段讨论、列连接成行的 SQL 写法</p>
<h3 id="按字段讨论">按字段讨论</h3>
<p>之前业务升级某些数据前端不再展示，运营要统计某机构下学生离校时间，但这个时间在一张表不同字段表示，正常结课的课程用 <code>closed_time</code>，学生删除的用 <code>dropped_time</code>，班级删除的用 <code>delete_time</code>，</p>
<pre><code class="language-sql">SELECT id AS '学生id', create_time AS '入校时间',(
	CASE `status` 
	WHEN 40 OR 24 THEN dropped_time
	WHEN -1 THEN closed_time 
	WHEN 16 THEN dropped_time
	END
) AS '离校时间'
FROM class_student WHERE org_id={0}
</code></pre>
<h3 id="多列数据连接成行展示">多列数据连接成行展示</h3>
<p>如下是统计某一机构下每个班级的学生，要求按班级分类</p>
<pre><code class="language-sql">SELECT org_id, class_id, GROUP_CONCAT(student_id ORDER BY student_id)
FROM (
	SELECT *
	FROM class_student
	WHERE org_id=2619
) t
GROUP BY class_id
</code></pre>
<h2 id="按路径获取文件">按路径获取文件</h2>
<p>由于系统路径分隔符不一致 Windows 下使用正斜杠分割路径如 <code>C:\Users\n8g\Desktop</code>，Linux 下则使用反斜杠分割路径如 <code>~/Documents</code>，于是在涉及读写本地文件需求相关的操作时，就要考虑代码的通用性，一个较不成熟的解决方案是用 python 标准库 os 做路径拼接处理</p>
<pre><code class="language-python">FILE_FOLDER = os.getcwd()  # 当前工作路径
FILE_NAME = &quot;file_to_process.abc&quot;  # 待处理文件
fo = open(os.path.join(FILE_FOLDER, FILE_NAME), 'r')
...
</code></pre>
<p>多文件</p>
<pre><code class="language-python">file_name_list = os.listdir(FILE_FOLDER)
for fname in file_name_list:
    file_abs_path = os.path.join(FILE_FOLDER, f_name)
    fo = open(file_abs_path)
    ...
...
</code></pre>
]]></content>
    </entry>
</feed>