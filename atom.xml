<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://n1000g.github.io</id>
    <title>n1000g</title>
    <updated>2021-12-15T21:48:17.943Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://n1000g.github.io"/>
    <link rel="self" href="https://n1000g.github.io/atom.xml"/>
    <subtitle>早日成长为一只老攻城狮</subtitle>
    <logo>https://n1000g.github.io/images/avatar.png</logo>
    <icon>https://n1000g.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, n1000g</rights>
    <entry>
        <title type="html"><![CDATA[【OS 基础课笔记】经典进程同步问题的记录型信号量机制解决方案]]></title>
        <id>https://n1000g.github.io/post/KKnYhVDri/</id>
        <link href="https://n1000g.github.io/post/KKnYhVDri/">
        </link>
        <updated>2021-12-15T16:39:19.000Z</updated>
        <summary type="html"><![CDATA[<p>进程同步问题<br>
信号量（Semaphore）机制由圣 Dijkstra 于1956 年提出，是一种卓有成效的进程同步工具，现已被广泛运用在各类单处理机、多处理机和网络系统中。其中的记录型信号量机制今已成为考研操作系统重要考点。</p>
]]></summary>
        <content type="html"><![CDATA[<p>进程同步问题<br>
信号量（Semaphore）机制由圣 Dijkstra 于1956 年提出，是一种卓有成效的进程同步工具，现已被广泛运用在各类单处理机、多处理机和网络系统中。其中的记录型信号量机制今已成为考研操作系统重要考点。</p>
<!-- more -->
<h2 id="1-记录型信号量机制">1. 记录型信号量机制</h2>
<p>除了初始化操作外，信号量只能通过两个原子操作 <code>wait()</code> 和 <code>signal()</code>，也称 P 操作和 V 操作。其中记录型信号量定义为 ① 一个整型的 <code>S-&gt;value</code> 表示资源数目（大于 0）或阻塞队列的长度（小于 0）；② 进程列表 <code>S-&gt;list</code> 表示阻塞在该信号量上的进程队列。<br>
当 <code>S-&gt;value</code> 定义为 1 时，记录型信号量转化为互斥信号量表示一个用于互斥访问的临界资源。</p>
<p>记录型信号量的数据结构和 P、V 操作描述如下：</p>
<pre><code class="language-c">/**
 * 记录型信号量的进程阻塞队列
 */
typedef struct process_control_block {
    int pid; // 进程标识符
    struct process_control_block * next; // 队列指针
} process_control_block;

/**
 * semaphore 记录型信号量
 */
typedef struct {
    int value; // 资源数量
    process_control_block * list; // 阻塞队列头
} semaphore;

void wait(semaphore * S) {
    S-&gt;value --;
    if (S-&gt;value &lt; 0) block(S-&gt;list);
}

void signal(semaphore * S) {
    S-&gt;value ++;
    if (S-&gt;value &lt;= 0) wakeup(S-&gt;list);
}
</code></pre>
<p>其中 block() 和 wakeup() 是操作系统原语，分别用于 阻塞 和 唤醒 进程。</p>
<h2 id="2-生产者-消费者问题">2. 生产者-消费者问题</h2>
<blockquote>
<p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多进程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
</blockquote>
<h3 id="21-基于循环缓冲的解决方案">2.1 基于循环缓冲的解决方案</h3>
<p>假定缓冲池中有 n 个缓冲区并用循环结构组织，可以利用互斥信号量 mutex 实现各进程对缓冲池的互斥使用，用信号量 empty 和 full 分别表示缓冲池中空缓冲和满缓冲资源的数目。</p>
<pre><code class="language-c">int in = 0, out = 0;
item buffer[n];
semaphore mutex = 1, full = 0, empty = n;
/**
 * 生产者进程——
 * 申请空缓冲并生产数据项，如果无空缓冲区资源则自我阻塞直到被空缓冲区资源唤醒
 * 需注意缓冲池资源的互斥访问
 */
void producer() {
    do {
        item nextp = produce_an_item();
        P(empty);
        P(mutex);
        buffer[in] = nextp;
        in = (in+1) % n;
        V(mutex);
        V(full);
    } while(true);
}

/**
 * 消费者进程——
 * 申请满缓冲区并消费数据项，如果无满缓冲区资源则自我阻塞直到被满缓冲区资源唤醒
 */
void consumer() {
    do {
        P(full);
        P(mutex);
        item nextc = buffer[out];
        out = (out+1) % n;
        V(mutex);
        V(empty);
        consume_the_item(nextc);
    } while (true);
}
</code></pre>
<p>主程序描述</p>
<pre><code class="language-c">void main() {
    cobegin
        producer(); consumer();
    coend
}
</code></pre>
<h3 id="22-基于单缓冲的但生产者-单消费者类同步问题">2.2 基于单缓冲的但生产者-单消费者类同步问题</h3>
<p>在测控系统中，数据采集任务将数据送入一单缓冲区，计算任务对该但缓冲区中数据取出并做计算处理。在这类问题中，信号量 full 和 empty 已经可以表示单缓冲资源的互斥属性了，相对 2.1 的代码描述，可以不再定义互斥信号量 mutex。</p>
<h2 id="3-哲学家进餐问题">3. 哲学家进餐问题</h2>
<p>由圣 Dijkstra 于1971 年提出并解决的用来演示在并发计算中多线程同步时产生的问题，旨在说明避免死锁和资源耗尽等问题。它的具体描述如下：</p>
<blockquote>
<p>有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子，平时哲学家进行思考，饥饿时便试图取其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐，该哲学家进餐完毕后，放下左右两只筷子又继续思考。</p>
</blockquote>
<h3 id="31-信号量定义和哲学家活动描述">3.1 信号量定义和哲学家活动描述</h3>
<p>筷子作为临界资源，一段时间仅允许一位哲学家使用，为了实现对筷子的互斥使用，可以为每根筷子设置一个互斥信号量，于是第 i 位 哲学家的活动可描述为</p>
<pre><code class="language-c">/**
 * 临界资源筷子
 */
semaphore chopstick[5] = {1, 1, 1, 1, 1}; 
/**
 * 第 i 位哲学家
 */
void philosopher_i() {
    do {
        P(chopstick[i]);
        P(chopstick[(i+1) % 5]);
        // eat
        V(chopstick[i]);
        V(chopstick[(i+1) % 5]);
        // think
    } while (true);
}
</code></pre>
<h3 id="32-存在问题分析和进一步解决方案">3.2 存在问题分析和进一步解决方案</h3>
<p>上述方案中，每个哲学家先拿起左边筷子再拿起右边筷子，不会出现相邻的两个哲学家竞争同一根筷子的情况，但可能出现每个哲学家同时饥饿并拿起自己左边的筷子，引起死锁。</p>
<p>为了避免死锁，有如下三种解决方案：</p>
<ol>
<li>双筷同举——当且仅当拿起两根筷子才允许进餐</li>
<li>奇偶有别——1、3、5 号哲学家先左后右，2、4 号哲学家先右后左</li>
<li>进餐限制——最多允许 4 根筷子被同时申请</li>
</ol>
<p>代码描述分别如下：</p>
<pre><code class="language-c">/**
 * 1. 双筷齐举
 * 设置一个互斥信号量，同一时间只允许一个进程做申请资源 wait 操作
 * 可以解决死锁问题，但是显然进程并发性变差
 */
semaphore mutex = 1;

void philosopher_i() {
    do {
        P(mutex);
        P(chopstick[i]);
        P(chopstick[(i+1) % 5]);
        V(mutex);
        // eat
        V(chopstick[i]);
        V(chopstick[(i+1) % 5]);
        // think
    } while (true);
}

/**
 * 2. 奇偶有别
 * 1、3、5 号哲学家先申请 i 号筷子后申请 (i+1) % 5 号筷子
 * 2、4 号哲学家先申请  (i+1) % 5 号筷子后申请 i 号 筷子
 * 经分析，解决了死锁问题
 */
// 实现略

/**
 * 3. 进餐限数
 * 设置一个初始化值为 4 资源信号量表示申请资源的权力
 * 最多只允许 4 个哲学家在申请筷子资源
 * 可以解决死锁问题，而进程并发性也未变差
 */
semaphore limit = 4;

void philosopher_i() {
    do {
        P(limit);
        P(chopstick[i]);
        P(chopstick[(i+1) % 5]);
        V(limit);
        // eat
        V(chopstick[i]);
        V(chopstick[(i+1) % 5]);
        // think
    } while (true);
}
</code></pre>
<h3 id="33-其他资料">3.3 其他资料</h3>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/the-dining-philosophers/">https://leetcode-cn.com/problems/the-dining-philosophers/</a></p>
</blockquote>
<h2 id="4-读者-写者问题">4. 读者-写者问题</h2>
<p>读者-写者问题常用于测试新同步原语，其问题描述如下：<br>
多个进程共享一个数据对象，只要求读的进程称读者进程，有写或修改要求的进程称写者进程。读操作可由多个读者进程同时执行，而写操作具有排他性。</p>
<h3 id="41-读者优先">4.1 读者优先</h3>
<p>下图是读者-写者问题的读者优先解决方案也即一般化的解决方案<br>
<img src="https://n1000g.github.io/post-images/1639600123226.png" alt="读者优先" loading="lazy"></p>
<p>即第一个到来的读者进程和其他写者进程一同竞争数据对象的资源信号量，如果发现资源所有者为读者进程，新来的读者进程可以跳过申请，直接进行读操作。而实现这个过程又需要对读者进程进行计数：</p>
<ul>
<li>考虑到写者进程要与其他进程互斥执行，设置写互斥信号量 wmutex；</li>
<li>读者进程之间可并发执行，设置计数变量 readercount 初始为 0；</li>
<li>readercount 对于多个读者进程而言是临界资源，应为之设立互斥信号量 rmutex。</li>
</ul>
<pre><code class="language-c">int readercount = 0;
semaphore rmutex = 1, wmutex = 1;
/**
 * 写者进程——互斥访问
 */
void writer() {
    do {
        P(wmutex);
        写操作
        V(wmutex);
    } while(true);
}

/**
 * 读者进程——
 * 系统中只存在的当前唯一的读者进程 0 时，与写者进程竞争临界资源
 * 访问 readercount 并计数
 */
void reader() {
    do {
        P(rmutex);
        if (readercount == 0) P(wmutex);
        readercount++;
        V(rmutex);
        读操作
        P(rmutex);
        readercount--;
        if (readercount == 0) V(wmutex);
        V(rmutex);
    } while (true);
}
</code></pre>
<p>主程序描述</p>
<pre><code class="language-c">void main() {
    cobegin
        reader₁(); reader₂(); ...
        writer₁(); writer₂(); ...
    coend
}
</code></pre>
<h3 id="42-公平型读者-写者问题即解决方案">4.2 公平型读者-写者问题即解决方案</h3>
<p>上述解决方案对写者进程来说，一旦系统中有读者进程在进行读操作，就必须等待，直到 readercount 等于 0。要消除这个读者优先，实现新来进程无论是读者还是写者都阻塞于同一队列，公平竞争临界资源，即“公平型读者-写者问题”的解决方案如下：<br>
<img src="https://n1000g.github.io/post-images/1639601542576.png" alt="公平型读者写者" loading="lazy"></p>
<p>如图，设置一个互斥信号量 S，读者进程和写者进程都需要先竞争 S，再进行之前的操作，使得阻塞在 S 上的进程是什么属性都无所谓，实现公平竞争。</p>
<pre><code class="language-c">int readercount = 0;
semaphore rmutex = 1, wmutex = 1, S = 1;
/**
 * 写者进程
 */
void writer() {
    do {
        P(S);
        P(wmutex)
        V(S);
        写操作
        V(wmutex);
    } while(true);
}

/**
 * 读者进程
 */
void reader() {
    do {
        P(S);
        P(rmutex);
        if (readercount == 0) P(wmutex);
        readercount++;
        V(rmutex);
        V(S);
        读操作
        P(rmutex);
        readercount--;
        if (readercount == 0) V(wmutex);
        V(rmutex);
    } while (true);
}
</code></pre>
<h3 id="43-写者优先">4.3 写者优先</h3>
<p>如题。<br>
<img src="https://n1000g.github.io/post-images/1639601905558.png" alt="写者优先" loading="lazy"></p>
<p>仅第一个到达的写者进程与读者进程一起去 S 处排队</p>
<pre><code class="language-c">int readercount = 0, writercount = 0;
semaphore rmutex = 1, wmutex = 1, S = 1, mutex = 1;
/**
 * 写者进程——添加了与读者优先解决方案中与读者相似的逻辑
 */
void writer() {
    do {
        P(mutex);
        if (writercount == 0) P(S);
        writercount ++;
        V(mutex);

        P(wmutex)
        写操作
        V(wmutex);
        
        P(mutex);
        writercount --;
        if (writercount == 0) V(S);
        V(mutex);
    } while(true);
}

/**
 * 读者进程——同 4.3
 */
void reader() {
    do {
        P(S);
        P(rmutex);
        if (readercount == 0) P(wmutex);
        readercount++;
        V(rmutex);
        V(S);
        读操作
        P(rmutex);
        readercount--;
        if (readercount == 0) V(wmutex);
        V(rmutex);
    } while (true);
}
</code></pre>
<h3 id="44-限定读者问题">4.4 限定读者问题</h3>
<p>如题<br>
可增设 rmax 信号量，使多出来的读者进程阻塞至此。</p>
<pre><code class="language-c">int readercount = 0;
semaphore rmutex = 1, wmutex = 1;
/**
 * 写者进程——同 4.1
 */
void writer() {
    do {
        P(wmutex);
        写操作
        V(wmutex);
    } while(true);
}

/**
 * 读者进程——多余读者挂至 rmax 信号量阻塞队列
 */
void reader() {
    do {
        P(rmax);

        P(rmutex);
        if (readercount == 0) P(wmutex);
        readercount++;
        V(rmutex);
        读操作
        P(rmutex);
        readercount--;
        if (readercount == 0) V(wmutex);
        V(rmutex);

        V(rmax);
    } while (true);
}
</code></pre>
<h2 id="5-独木桥-单行道问题">5. 独木桥、单行道问题</h2>
<p>如题，南北通车，单行道上只能走同一方向的车辆。使用记录型信号量模拟道路情况。<br>
分析：两个方向的车辆基本性质完全相同，均类似读者-写者问题中写者进程。使每类第一个到达的进程与另一类进程竞争单行道这一临界资源。</p>
<pre><code class="language-c">/**
 * 南边来的和北边来的车辆数量
 * 和临界资源——单行道
 */
int southcount = 0, northcount = 0;
semaphore road = 1;
/**
 * 模拟由南向北的车辆
 */
void S2N() {
    do {
        P(smutex);
        if (southcount == 0) P(road);
        southcount++;
        V(smutex);
        通过单行道
        P(smutex);
        southcount--;
        if (southcount == 0) V(road);
        V(smutex);
    } while (true);
}

/**
 * 模拟由北向南的车辆
 */
void N2S() {
    do {
        P(nmutex);
        if (northcount == 0) P(road);
        northcount++;
        V(nmutex);
        通过单行道
        P(nmutex);
        northcount--;
        if (northcount == 0) V(road);
        V(nmutex);
    } while (true);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OS 基础课笔记】一、操作系统引论]]></title>
        <id>https://n1000g.github.io/post/f-vIjJNtK/</id>
        <link href="https://n1000g.github.io/post/f-vIjJNtK/">
        </link>
        <updated>2021-12-12T21:21:33.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="1-操作系统概述">1. 操作系统概述</h1>
<h2 id="11操作系统的概念和特征">1.1操作系统的概念和特征</h2>
<p>计算机系统的由软硬件共同组成，其中软件又可划分为应用软件和系统软件，操作系统（Operating System，OS）是配置在计算机硬件社上的第一层软件是对硬件系统的首次扩充。管理下层硬件设备，提高设备利用效率，并为上层用户程序提供方便的接口以操作硬件设备完成目标功能即是操作系统的主要功能。</p>
<p>操作系统的基本特征包括并发、共享、虚拟和异步。</p>
<ul>
<li>并发（Concurrence）指同一时间间隔内处理和调度多个程序的能力，主要通过分时得以实现；</li>
<li>共享（Sharing）指系统中资源可供多个并发执行的进程共享使用，包括互斥共享方式和同时访问方式；</li>
<li>虚拟（Virtual）指把一个物理上的实体抽象为若干个逻辑上的对应物，虚拟技术包括时分复用技术（如处理器的分时）和空分复用技术（如虚拟存储技术）；</li>
<li>异步（Asynchronism）指 OS 要保证多个并发执行的进程在同一个环境下多次运行后能获得相同的结果。</li>
</ul>
<h2 id="12-操作系统的目标和作用">1.2 操作系统的目标和作用</h2>
<p>操作系统的设计目标包括<strong>方便性</strong>、<strong>有效性</strong>、<strong>可扩充性</strong>和<strong>开放性</strong>。</p>
<ul>
<li>方便性即提供用户接口，使计算机更方便使用；</li>
<li>有效性即有效管理和分配软硬件资源以及合理组织计算机工作流程，以改善资源利用率提高系统吞吐量；</li>
<li>可扩充性是面向未来的，OS 应当适应计算机硬件和体系架构的迅猛发展及其对应的更高的功能和性能要求；</li>
<li>开放性指适应不同厂家与不同类型的计算机及其设备的网络化集成和协同工作，实现应用程序的可移植性和互操作性；</li>
</ul>
<p>操作系统在计算机系统中所起的作用，可从用户、资源管理和资源抽象等角度分析讨论。</p>
<ul>
<li>OS 是用户与计算机硬件系统之间的接口，包括面向一般用户的命令式、图形化接口和面向应用程序的<a href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">系统调用</a>接口；</li>
<li>OS 是系统资源的管理者，管理对象包括处理器、存储器、各类外围设备以及其信息（数据和软件），管理操作例如资源的分配回收、访问操作、共享保护等；</li>
<li>OS 实现了对计算机资源的抽象，例如为了方便用户使用 I/O 设备，人们在裸机上铺设一层 I/O 设备管理软件，隐藏具体细节并向用户提供一个对硬件设备操作的抽象模型，用户无需了解硬件物理接口等细节便可用该模型提供的抽象接口使用计算机硬件资源。同理，为了方便用户使用文件系统，可在第一层软件上再覆盖一层用于文件管理的软件，以此类推。由此可知，OS 是铺设在计算机硬件上的多层软件的集合。</li>
</ul>
<h1 id="2-操作系统层次模型">2. 操作系统层次模型</h1>
<p>笼统地说，操作系统层次模型分为三层，自底向上分别是操作系统对象、操作和管理有关对象的软件集合、用户接口：<br>
<img src="https://n1000g.github.io/post-images/1639348511445.png" alt="OS 层次模型 1" loading="lazy"><br>
对这个层次模型以 Linux 或 Unix 系统为例进行细化。由下至上，操作系统内核（Kernel）通过读写硬件接口实现对硬件资源的管理，然后应用程序或命令解释程序（外壳 Shell）通过内核提供的系统调用程序实现用户功能：<br>
<img src="https://n1000g.github.io/post-images/1639348723935.png" alt="OS 层次模型 2" loading="lazy"></p>
<h1 id="3-操作系统接口分类和组成">3. 操作系统接口分类和组成</h1>
<p>用户接口是系统和用户之间进行交互和信息交换的媒介，方便用户使用和管理计算机系统资源，基于接口表现形式可分为用户交互接口和用户程序接口，前者包括脱机/联机命令接口和图形化用户接口方便一般用户直接使用系统资源，后者方便用户程序访问系统资源，由一组系统调用组成。<br>
<img src="https://n1000g.github.io/post-images/1639511501081.jpg" alt="用户接口分类" loading="lazy"></p>
<h2 id="31-命令接口">3.1 命令接口</h2>
<p>按照作业控制方式的不同，可分为联机命令接口（交互式）和脱机命令接口（批处理），由命令解释程序（shell、cmd 等）控制执行。</p>
<blockquote>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></p>
</blockquote>
<h2 id="32-图形用户接口gui">3.2 图形用户接口（GUI）</h2>
<p>现代主流操作系统一般都提供 GUI，方便用户使用，以 Windows 为例，系统初始化后 OS 为终端用户生成一个名为 explorer.exe 的进程，它允许一个巨头窗口界面的命令解释程序，即所谓“桌面”。</p>
<h2 id="33-程序接口">3.3 程序接口</h2>
<p>程序接口是 OS 专门为用户程序设置的，供程序员编程使用，也是用户程序获取 OS 服务的唯一途径。它由一组系统调用（system call）组成。系统调用不仅可供所有应用程序使用，也可供 OS 自身使用，每个操作系统中通常有几十上百条系统调用，每条系统调用都是一个完成特定功能的子程序。</p>
<h3 id="331-系统调用的基本概念">3.3.1 系统调用的基本概念</h3>
<p>大多数计算机系统将 CPU 执行状态分为<strong>目态</strong>（核心态）与<strong>管态</strong>（用户态），CPU 的状态属于程序状态字 PSW 的一位，即系统模式（0）和用户模式（1），CPU 交替执行操作系统程序和用户程序。相应地，现代多数 OS 将 CPU 的指令集分为特权指令和非特权指令两类。前者指在系统态下运行的指令，为外设和内存的访问不受限制；后者是在用户态运行的指令，不能对系统硬件和软件直接访问，对内存的访问也限制在用户空间。</p>
<p>OS 提供系统调用的目的显而易见，即为用户程序提供调用 OS 内核中相关过程的手段，以获取 OS 内核的系统服务。系统调用本质是应用程序请求 OS 内核完成某个功能时的一种过程调用。</p>
<p>系统调用区别于一般过程调用的显著特征：</p>
<ul>
<li>调用程序运行在管态，被调用程序运行在目态；</li>
<li>涉及系统状态（CPU 状态）的转换；</li>
<li>返回问题，调用过程结束后不一定返回被调用过程；</li>
<li>嵌套调用，一般 OS 要设置最大嵌套深度。</li>
</ul>
<h3 id="332-系统调用的分类">3.3.2 系统调用的分类</h3>
<p>一般 OS 的系统调用可分为如下几大类：</p>
<ul>
<li>进程控制类
<ul>
<li>进程创建、结束、等待子进程结束</li>
<li>进程属性设置和获取</li>
<li>执行一个文件</li>
</ul>
</li>
<li>文件操纵类
<ul>
<li>文件创建、打开、关闭、读写等</li>
</ul>
</li>
<li>进程通信类
<ul>
<li>连接的打开关闭、消息的发送接收等</li>
</ul>
</li>
<li>系统信息的维护
<ul>
<li>时间的设置与获取等</li>
</ul>
</li>
</ul>
<h3 id="333-系统调用的实现机理">3.3.3 系统调用的实现机理</h3>
<p>系统调用是通过中断机制实现的，并且一个操作系统所有的系统调用都通过一个中断入口实现。在 Windows 操作系统中是 <code>int 0x21</code> 号中断，Linux 系统中是 <code>int 0x80</code> 号中断。与其他中断实现机制类似，以下是有关系统调用实现机理的数据结构和详细过程。</p>
<p>涉及的两个数据结构：</p>
<ul>
<li>中断向量表（interrupt vector table，IVT）——中断源的识别标志，提供中断类型号到中断处理程序的映射；</li>
<li>系统调用表（sys_call_table）——系统调用号到对应的系统过程映射。</li>
</ul>
<p>实现流程（以 Linux 为例）：</p>
<ol>
<li>用户进程形成一个系统调用号（送入 EAX 寄存器）和参数（送入参数表），执行系统调用命令并触发 <code>int 0x80</code> 号中断；</li>
<li>中断总控模块处理 128 号中断，跳到它的中断处理程序（即系统调用总控模块）；
<ol>
<li>切换处理机状态（核心态 → 用户态）；</li>
<li>由硬件和内核程序进行系统调用的一般性处理，即保护 CPU 现场，保存用户定义的参数；</li>
</ol>
</li>
<li>终端总控模块查系统调用表并转到对应的系统调用处理子程序；</li>
<li>恢复 CPU 现场返回被中断进程或设置新的 CPU 现场转入新进程。</li>
</ol>
<blockquote>
<p><strong>外中断与内中断</strong>——中断也称外中断、硬中断，由来自 CPU 执行指令以外的发生事件造成，通常来自外设请求，中断号由中断控制器提供；内中断也称异常、陷入、软中断，源自 CPU 指令内部事件如缺页指令、非法操作码、地址越界、Linux 1、2、3、128 号中断等，中断号由指令直接指出，无需使用中断控制器。</p>
</blockquote>
<h2 id="34-linux-系统调用">3.4 Linux 系统调用</h2>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1492374">Linux syscall过程分析（万字长文）</a><br>
<a href="https://docs.huihoo.com/joyfire.net/6-1.html#I452">https://docs.huihoo.com/joyfire.net/6-1.html#I452</a></p>
</blockquote>
<h1 id="4-操作系统的发展与演化">4. 操作系统的发展与演化</h1>
<figure data-type="image" tabindex="1"><img src="https://n1000g.github.io/post-images/1639520072572.jpg" alt="OS 的发展与演化" loading="lazy"></figure>
<ul>
<li>批处理系统——作业先进入磁盘再调入进内存
<ul>
<li>单道批处理系统——把一批作业脱机方式输入磁带上，在所系统配置的监督程序控制下依次连续处理</li>
<li>多道批处理系统——用作业调度算法分配资源，具有多道性、无序性、调度性</li>
</ul>
</li>
<li>分时系统——一台主机、多个终端、多个用户同时以交互方式使用、作业直接进入内存、按时间片轮转策略分配处理机，具有多路性、独立性、及时性和交互性</li>
<li>实时系统——及时响应外部事件请求并能控制所有事实任务协调一致地运行，相对分时系统，系统高度可靠</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ @Import vs @ComponentScan]]></title>
        <id>https://n1000g.github.io/post/WFejoTCZs/</id>
        <link href="https://n1000g.github.io/post/WFejoTCZs/">
        </link>
        <updated>2021-07-26T13:03:16.000Z</updated>
        <summary type="html"><![CDATA[<p>译自 <a href="https://www.baeldung.com/spring-import-annotation">baeldung</a><br>
本文将系统介绍 Spring 中用于注册 Bean 对象的两个重要注解 <code>@Import</code> 和 <code>@ComponentScan</code> 的联系与区别，以及它们各自的适用场景。</p>
]]></summary>
        <content type="html"><![CDATA[<p>译自 <a href="https://www.baeldung.com/spring-import-annotation">baeldung</a><br>
本文将系统介绍 Spring 中用于注册 Bean 对象的两个重要注解 <code>@Import</code> 和 <code>@ComponentScan</code> 的联系与区别，以及它们各自的适用场景。</p>
<!-- more -->
<h2 id="联系">联系</h2>
<p>两者都可以接收任何 <code>@Component</code> 或 <code>@Configuration</code> 注解的类（Bean 和配置类）</p>
<p>下面是使用 <code>@Import</code> 注册 Bean 的例子：</p>
<pre><code class="language-java">@Configuration
@Import(Bug.class)
class BugConfig {
}

@Component(value = &quot;bug&quot;)
class Bug {
}
</code></pre>
<h2 id="概念上的区别subconceptual-differencessub">概念上的区别<sub>Conceptual Differences</sub></h2>
<p>简单地说，我们可以用这两个注释得到相同的结果。那么，它们之间有什么区别？</p>
<p>要回答这个问题，让我们记住 Spring 通常提倡<strong>约定高于配置</strong>的方法。</p>
<p>与我们的注释进行类比，<code>@ComponentScan</code> 更像是约定，而 <code>@Import</code> 更像是配置。</p>
<h2 id="实际应用中真正发生了什么">实际应用中真正发生了什么</h2>
<p>通常，我们在根包中使用 <code>@ComponentScan</code> 启动应用程序，这样它就可以为我们找到所有组件。正如 Spring Boot 中 <code>@SpringBootApplication</code> 已经包含了 <code>@ComponentScan</code>。这显示了约定的力量。<br>
现在，让我们假设我们的应用程序扩展了很多。现在我们需要处理来自所有不同地方的 bean，比如组件、不同的包结构，以及我们自己和第三方构建的模块。<br>
在这种情况下，将所有内容添加到上下文可能会引发关于使用哪个bean的冲突。除此之外，我们的启动时间可能会比较慢。另一方面，我们也不想为每个新组件都写一个 <code>@Import</code>，因为这样做会适得其反。<br>
以我们的动物为例。我们确实可以在上下文声明中隐藏导入，但是我们仍然需要记住每个 Config 类的 <code>@Import</code>。</p>
<h2 id="协同使用两者">协同使用两者</h2>
<p>我们也可以以兼顾两者为目标。试想，我们有一个只包含 animals 的包（或组件或模块等等）。</p>
<p>这个包上有一个 <code>@ComponentScan</code> 注解</p>
<pre><code class="language-java">package com.baeldung.importannotation.animal;

// imports...

@Configuration
@ComponentScan
public class AnimalScanConfiguration {
}
</code></pre>
<p>和一个 <code>@Import</code> 注解用于控制我们要添加到上下文的信息</p>
<pre><code class="language-java">package com.baeldung.importannotation.zoo;

// imports...

@Configuration
@Import(AnimalScanConfiguration.class)
class ZooApplication {
}
</code></pre>
<p>最后，添加到动物包中的任何新 bean 都将由上下文自动找到。我们仍然可以明确地控制我们所使用的构型。</p>
<h2 id="conclusion">Conclusion</h2>
<p>*<strong>@Import* is very</strong> <strong>similar to @*ComponentScan*</strong>, except for the fact that <strong>@*Import* has an explicit approach while @*ComponentScan* uses an implicit one</strong>.</p>
<p><a href="https://github.com/eugenp/tutorials/tree/master/spring-core-4">示例项目地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPA Criteria Queries]]></title>
        <id>https://n1000g.github.io/post/hfZT72Yi5/</id>
        <link href="https://n1000g.github.io/post/hfZT72Yi5/">
        </link>
        <updated>2021-07-26T05:08:58.000Z</updated>
        <summary type="html"><![CDATA[<p>摘译自 <a href="https://www.baeldung.com/hibernate-criteria-queries#Criteria">baeldung</a><br>
条件查询（Criteria Query）是 JPA 的一个重要特性。自 Hibernate 5.2 以后，Hibernate Criteria API 被官方声明为弃用方法，转而推荐使用 JPA Criteria API。本教程将围绕如何使用 Hibernate 和 JPA 来构建 Criteria Queries 展开讨论。</p>
]]></summary>
        <content type="html"><![CDATA[<p>摘译自 <a href="https://www.baeldung.com/hibernate-criteria-queries#Criteria">baeldung</a><br>
条件查询（Criteria Query）是 JPA 的一个重要特性。自 Hibernate 5.2 以后，Hibernate Criteria API 被官方声明为弃用方法，转而推荐使用 JPA Criteria API。本教程将围绕如何使用 Hibernate 和 JPA 来构建 Criteria Queries 展开讨论。</p>
<!-- more -->
<h2 id="1-概述">1. 概述</h2>
<p>在本教程中，我们将讨论一个非常有用的 JPA 特性——条件查询。</p>
<p>它不仅使我们能够在不使用纯 SQL 的情况下编写查询，而且还为查询提供了一些面向对象的控制，这也即 Hibernate 的主要特性之一。Criteria API 允许我们以编程的方式构建一个应用不同的过滤规则和逻辑条件的 Criteria 查询对象。</p>
<p>从Hibernate 5.2开始，Hibernate Criteria API 就被弃用了，新的开发集中在 JPA Criteria API 上。我们将探索如何使用 Hibernate 和 JPA 来构建 Criteria Queries。</p>
<h2 id="2-maven-依赖">2. Maven 依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;   
    &lt;version&gt;5.3.2.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="3-简单示例">3. 简单示例</h2>
<p>我们以如何从数据库中获取特定类（Item）的所有实例为例：</p>
<pre><code class="language-java">public class Item implements Serializable {

    private Integer itemId;
    private String itemName;
    private String itemDescription;
    private Integer itemPrice;

   // standard setters and getters
}
</code></pre>
<p>它的 Criteria Query 如下：</p>
<pre><code class="language-java">public List&lt;T&gt; getAll() {
    Session session = HibernateUtil.getHibernateSession();
    CriteriaBuilder cb = session.getCriteriaBuilder();
    CriteriaQuery&lt;Item&gt; cr = cb.createQuery(Item.class);
    Root&lt;Item&gt; root = cr.from(Item.class);
    cr.select(root);
    Query&lt;Item&gt; query = session.createQuery(cr);
    return query.getResultList();
}
</code></pre>
<p>上面的查询是如何获取所有项的简单演示。让我们一步一步来看看我们做了什么：</p>
<ol>
<li>从 SessionFactory 对象创建一个 Session 实例</li>
<li>通过调用 getCriteriaBuilder() 方法创建一个 CriteriaBuilder 实例</li>
<li>通过调用 CriteriaBuilder 的 createQuery()方法创建一个 CriteriaQuery 实例</li>
<li>通过调用 Session 的 createQuery() 方法创建 Query 的实例</li>
<li>调用查询对象的getResultList()方法，它将给出结果</li>
</ol>
<pre><code class="language-mermaid">graph LR;
    SessionFactory --&gt; Session;
    Session --&gt; CriteriaBuilder;
    subgraph build criteriaQuery;
    	CriteriaBuilder --Item.class--&gt; CriteriaQuery;
    	Root --Item.class--&gt; CriteriaQuery;
    end;
    CriteriaQuery --&gt; Query;
    Query --&gt; results;
</code></pre>
<p>现在我们已经介绍了基础知识，让我们继续了解条件查询的一些特性:</p>
<h3 id="31-expressions">3.1 Expressions</h3>
<p>CriteriaBuilder 可用于基于特定条件限制查询结果：</p>
<h4 id="where-子句">Where 子句</h4>
<pre><code class="language-java">// where itemPrice &gt; 1000
cr.select(root).where(cb.gt(root.get(&quot;itemPrice&quot;), 1000));
// where itemPrice &lt; 1000
cr.select(root).where(cb.lt(root.get(&quot;itemPrice&quot;), 1000));
// Items having itemName contain Chair
cr.select(root).where(cb.like(root.get(&quot;itemName&quot;), &quot;%chair%&quot;));
// To check if the given property is not null:
cr.select(root).where(cb.isNotNull(root.get(&quot;itemDescription&quot;)));
</code></pre>
<h4 id="表达式链">表达式链</h4>
<pre><code class="language-java">Predicate[] predicates = new Predicate[2];
predicates[0] = cb.isNull(root.get(&quot;itemDescription&quot;));
predicates[1] = cb.like(root.get(&quot;itemName&quot;), &quot;chair%&quot;);
cr.select(root).where(predicates);
// or
cr.select(root).where(cb.or(predicates[0], predicates[1]));
// and
cr.select(root).where(cb.and(predicates[0], predicates[1]));
</code></pre>
<h3 id="32-sorting">3.2 Sorting</h3>
<pre><code class="language-java">cr.orderBy(
  cb.asc(root.get(&quot;itemName&quot;)), 
  cb.desc(root.get(&quot;itemPrice&quot;)));
</code></pre>
<h3 id="33-projections-aggregates-and-grouping-functions">3.3 Projections, Aggregates, and Grouping Functions</h3>
<pre><code class="language-java">cr.select(cb.count(root));
cr.select(cb.avg(root.get(&quot;itemPrice&quot;)));
</code></pre>
<h3 id="34-criteriaupdate">3.4 CriteriaUpdate</h3>
<p>CriteriaUpdate 有一个 set() 方法，可以用来为数据库记录提供新值:</p>
<pre><code class="language-java">CriteriaUpdate&lt;Item&gt; criteriaUpdate = cb.createCriteriaUpdate(Item.class);Root&lt;Item&gt; root = criteriaUpdate.from(Item.class);criteriaUpdate.set(&quot;itemPrice&quot;, newPrice);criteriaUpdate.where(cb.equal(root.get(&quot;itemPrice&quot;), oldPrice));Transaction transaction = session.beginTransaction();session.createQuery(criteriaUpdate).executeUpdate();transaction.commit();
</code></pre>
<h3 id="35-criteriadelete">3.5 CriteriaDelete</h3>
<pre><code class="language-java">CriteriaDelete&lt;Item&gt; criteriaDelete = cb.createCriteriaDelete(Item.class);Root&lt;Item&gt; root = criteriaDelete.from(Item.class);criteriaDelete.where(cb.greaterThan(root.get(&quot;itemPrice&quot;), targetPrice));Transaction transaction = session.beginTransaction();session.createQuery(criteriaDelete).executeUpdate();transaction.commit();
</code></pre>
<h2 id="相对-hql-的优势">相对 HQL 的优势</h2>
<ul>
<li><strong>Object Oriented</strong></li>
<li>flexible</li>
<li>type-safety</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python 数据处理脚本的通用设计]]></title>
        <id>https://n1000g.github.io/post/zIn7XAv_S/</id>
        <link href="https://n1000g.github.io/post/zIn7XAv_S/">
        </link>
        <updated>2021-07-20T12:08:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用库">常用库</h2>
<h3 id="pymysql"><a href="https://pymysql.readthedocs.io/en/latest/">PyMySQL</a></h3>
<pre><code class="language-python">import pymysql
# 连接
connection = pymysql.connect(host, user, password, db, port, charset, 
cursorclass=pymysql.cursors.DictCursor)
cursor = connection.cursor()
# 处理
cursor.execute(sql)
res = cursor.fetchall()  # 查询语句需要 fetch 后 才能执行下一次查询
# connection.commit()  # 修改语句需要 commit  后 才能执行下一次查询
# 关闭
cursor.close()
connection.close()
</code></pre>
<h3 id="openpyxl"><a href="https://openpyxl.readthedocs.io/en/stable/">openpyxl</a></h3>
<p><strong>写</strong></p>
<pre><code class="language-python">from openpyxl import Workbook

workbook = Workbook()
sheet = workbook.active
sheet['A1'] = 42
sheet.append([1, 2, 3])
sheet['A2'] = datetime.datetime.now()
workbook.save(&quot;sample.xlsx&quot;)
</code></pre>
<p><strong>读</strong></p>
<pre><code class="language-python">from openpyxl import load_workbook

workbook = load_workbook(&quot;excelfile.xlsx&quot;)
sheets = workbook.sheetnames
sheet = workbook[sheets[0]]  # sheet = workbook.active

for row in sheet.rows:
    val = row[0].value
    print(val)
</code></pre>
<h2 id="几个较常用的-sql-写法">几个较常用的 SQL 写法</h2>
<p>编写代码相对十分耗时且极易出错，复杂度不太高的任务可以用数据库客户端直接解决，总结下一些如按字段讨论、列连接成行的 SQL 写法</p>
<h3 id="按字段讨论">按字段讨论</h3>
<p>之前业务升级某些数据前端不再展示，运营要统计某机构下学生离校时间，但这个时间在一张表不同字段表示，正常结课的课程用 <code>closed_time</code>，学生删除的用 <code>dropped_time</code>，班级删除的用 <code>delete_time</code>，</p>
<pre><code class="language-sql">SELECT id AS '学生id', create_time AS '入校时间',(
	CASE `status` 
	WHEN 40 OR 24 THEN dropped_time
	WHEN -1 THEN closed_time 
	WHEN 16 THEN dropped_time
	END
) AS '离校时间'
FROM class_student WHERE org_id={0}
</code></pre>
<h3 id="多列数据连接成行展示">多列数据连接成行展示</h3>
<p>如下是统计某一机构下每个班级的学生，要求按班级分类</p>
<pre><code class="language-sql">SELECT org_id, class_id, GROUP_CONCAT(student_id ORDER BY student_id)
FROM (
	SELECT *
	FROM class_student
	WHERE org_id=2619
) t
GROUP BY class_id
</code></pre>
<h2 id="按路径获取文件">按路径获取文件</h2>
<p>由于系统路径分隔符不一致 Windows 下使用正斜杠分割路径如 <code>C:\Users\n8g\Desktop</code>，Linux 下则使用反斜杠分割路径如 <code>~/Documents</code>，于是在涉及读写本地文件需求相关的操作时，就要考虑代码的通用性，一个较不成熟的解决方案是用 python 标准库 os 做路径拼接处理</p>
<pre><code class="language-python">FILE_FOLDER = os.getcwd()  # 当前工作路径
FILE_NAME = &quot;file_to_process.abc&quot;  # 待处理文件
fo = open(os.path.join(FILE_FOLDER, FILE_NAME), 'r')
...
</code></pre>
<p>多文件</p>
<pre><code class="language-python">file_name_list = os.listdir(FILE_FOLDER)
for fname in file_name_list:
    file_abs_path = os.path.join(FILE_FOLDER, f_name)
    fo = open(file_abs_path)
    ...
...
</code></pre>
]]></content>
    </entry>
</feed>